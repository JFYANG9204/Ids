import { BasicTypeDefinitions } from "./basic";
import { BuiltInDefinition } from "./types";

export const builtInFunctions = new Set<BuiltInDefinition>([
    {
        name: "AnswerCount",
        label: "AnswerCount(Val: Categorical): Long",
        insertText: "AnswerCount",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "Categorical value.",
            }
        ],
        note: [
            "```ds",
            "(function) AnswerCount(Val: Categorical): Long",
            "```",
            "------------------------------------------",
            "Returns the number of categories selected in a category list.",
            "+ `Val`: *Categorical* - Categorical value.",
            "+ `return`: *Long* - Number of categories in Val.",
            "### Example",
            "For example, to define a quota for respondentswho can name more than five brands of fizzy drinks:",
            "```ds",
            "fizzy.AnswerCount() > 5",
            "```",
        ].join("\n"),
    },
    {
        name: "ContainsAll",
        label: "ContainsAll(Val: Categorical, Answers: Variant, [Exactly: Boolean]): Boolean",
        insertText: "ContainsAll",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "Categorical value.",
            },
            {
                name: "Answers",
                type: BasicTypeDefinitions.variant,
                note: "Variant value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *True*, unless `Exactly` is *True* and `Val` is not empty.",
            },
            {
                name: "Exactly",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                note: "Optional. If *True*, the function returns *True* only if `Val` contains all of the categories in `Answers` and no others. If `Exactly` is omitted or *False*, the function returns *True* if all of the categories in `Answers` are in `Val`, even if `Val` contains other categories."
            }
        ],
        note: [
            "```ds",
            "(function) ContainsAll(Val: Categorical, Answers: Variant, [Exactly: Boolean]): Boolean",
            "```",
            "-----------------------------------",
            "Identifies whether a category list contains all of the categories in a given list.",
            "+ `Val`: *Categorical* - Categorical value.",
            "+ `Answers`: *Variant* - Variant value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *True*, unless `Exactly` is *True* and `Val` is not empty.",
            "+ `Exactly`: *Boolean* - Optional. If *True*, the function returns *True* only if `Val` contains all of the categories in `Answers` and no others. If `Exactly` is omitted or *False*, the function returns *True* if all of the categories in `Answers` are in `Val`, even if `Val` contains other categories.",
            "+ `return`: *Boolean* - *True* if `Val` contains all of the categories in `Answers`, otherwise *False*. ",
            "",
            "### Remark",
            "+ If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is *False*. If `Answers` is *NULL*, the return value is *False*.",
            "+ This function is equivalent to the >= comparison operator for *Categorical* values, except that the *NULL* behavior is different. However, using the >= operator is generally faster than using the `ContainsAll` function.",
            "",
            "### Examples",
            "Like `ContainsAny` and `ContainsSome`, `ContainsAll` is typically used to filter multiple response data. The Museum sample data set contains a multiple response variable called *remember*, which records the galleries that respondents remember viewing. You could use the following example to create a filter to select respondents who chose the *Fossils* and *Dinosaurs* categories in response to the question:",
            "",
            "```ds",
            "remember.ContainsAll({fossils, dinosaurs})",
            "```",
            "",
            "This filter will select respondents who chose both *Fossils* and *Dinosaurs* regardless of whether they chose any additional categories. To restrict the filter to respondents who chose *Fossils* and *Dinosaurs* and no other categories, set `Exactly` to *True*:",
            "",
            "```ds",
            "remember.ContainsAll({fossils, dinosaurs}, True)",
            "```",
        ].join("\n"),
    },
    {
        name: "ContainsSome",
        label: "ContainsSome(Val: Categorical, Answers: Variant, [Min: Long], [Max: Long], [Exactly: Boolean]): Boolean",
        insertText: "ContainsSome",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "*Categorical* value. ",
            },
            {
                name: "Answers",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *True* (unless `Exactly` is *True* and `Val` is not empty)."
            },
            {
                name: "Min",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The minimum number of categories in `Answers` that must be in `Val` for the function to return *True*. If omitted, the minimum is one. ",
            },
            {
                name: "Max",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The maximum number of categories in `Answers` that must be in `Val` for the function to return *True*. If omitted, the maximum is the number of categories in `Answers`."
            },
            {
                name: "Exactly",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                note: "*True* if `Val` contains the specified categories, otherwise *False*."
            }
        ],
        note: [
            "```ds",
            "(function) ContainsSome(Val: Categorical, Answers: Variant, [Min: Long], [Max: Long], [Exactly: Boolean]): Boolean",
            "```",
            "-----------------------------------",
            "Identifies whether a category list contains some of the categories in a given list.",
            "+ `Val`: *Categorical* - *Categorical* value. ",
            "+ `Answers`: *Variant* - *Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *True* (unless `Exactly` is *True* and `Val` is not empty).",
            "+ `Min`: *Long* - Optional. The minimum number of categories in `Answers` that must be in `Val` for the function to return *True*. If omitted, the minimum is one. ",
            "+ `Max`: *Long* - Optional. The maximum number of categories in `Answers` that must be in `Val` for the function to return *True*. If omitted, the maximum is the number of categories in `Answers`.  ",
            "+ `Exactly`: *Boolean* - Optional. If *True*, the function returns *True* only if `Val` contains the specified number of categories and no others. If `Exactly` is omitted or *False*, the function returns *True* if the specifiednumber of categories in `Answers` are in `Val`, even if `Val` contains other categories.",
            "+ `return`: *Boolean* - *True* if `Val` contains the specified categories, otherwise *False*.",
            "",
            "### Remarks",
            "If the current value is *NULL*, `Val` is an empty Categorical value ({}) and the return value is *False*. If `Answers` is *NULL*, the return value is *False*.",
            "",
            "### Examples",
            "Like `ContainsAll` and `ContainsAny`, `ContainsSome` is typically used to filter multiple response data. The Museum sample data set contains a multiple response variable called *remember*, which records the galleries that respondents *remember* viewing. You could use the following example to create a filter to select respondents who chose two or more of four specified categories in response to the question:",
            "```ds",
            "remember.ContainsSome({fossils, dinosaurs, birds, whales}, 2)",
            "```",
            "To restrict the filter to respondents who chose at least two, but not more than three, of the four categories, set `Max` to 3:",
            "```",
            "remember.ContainsSome({fossils, dinosaurs, birds, whales}, 2, 3)",
            "```",
            "To restrict the filter to respondents who chose at least two, but not more than three, of the four categories and no others, set `Exactly` to *True*:",
            "```",
            "remember.ContainsSome({fossils, dinosaurs, birds, whales}, 2, 3, True)",
            "```",
        ].join("\n"),
    },
    {
        name: "ContainsAny",
        label: "ContainsAny(Val: Categorical, Answers: Variant, [Exactly: Boolean]): Boolean",
        insertText: "ContainsAny",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "*Categorical* value."
            },
            {
                name: "Answers",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *False*."
            },
            {
                name: "Exactly",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                note: "Optional. If *True*, the function returns *False* if `Val` contains any categories that are not in `Answers`. If `Exactly` is omitted or *False*, the function returns *True* if any of the categories in `Answers` are in `Val`, even if `Val` contains other categories."
            }
        ],
        note: [
            "```ds",
            "(function) ContainsAny(Val: Categorical, Answers: Variant, [Exactly: Boolean]): Boolean",
            "```",
            "-----------------------------------",
            "Identifies whether a category list contains one or more categories in a given list.",
            "+ `Val`: *Categorical* - *Categorical* value.",
            "+ `Answers`: *None* - *Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *False*.",
            "+ `Exactly`: *Boolean* - Optional. If *True*, the function returns *False* if `Val` contains any categories that are not in `Answers`. If `Exactly` is omitted or *False*, the function returns *True* if any of the categories in `Answers` are in `Val`, even if `Val` contains other categories.",
            "+ `return`: *Boolean* - *True* if `Val` contains the categories as specified, otherwise *False*.",
            "",
            "### Remarks",
            "If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is *False*. If `Answers` is *NULL*, the return value is *False*.",
            "",
            "### Examples",
            "Like `ContainsAll` and `ContainsSome`, `ContainsAny` is typically used to filter multiple response data. The Museum sample data set contains a multiple response variable called *remember*, which records the galleries that respondents *remember* viewing. You could use the following example to create a filter to select respondents who chose either or both of the *Fossils* and *Dinosaurs* categories in response to the question:",
            "```ds",
            "remember.ContainsAny({fossils, dinosaurs})",
            "```",
            "This filter will select respondents who chose either one or both of the two categories regardless of whether they chose any additional categories. For example, it will select respondents who chose any of the following:",
            "+ The *Fossils* category only.",
            "+ The *Dinosaurs* category only.",
            "+ The *Fossils* and *Dinosaurs* categories only.",
            "+ The *Fossils* category and any other category. ",
            "+ The *Dinosaurs* category and any other category.",
            "",
            "To restrict the filter to respondents who chose either or both of the two specified categories and no others, set `Exactly` to *True*:",
            "```ds",
            "remember.ContainsAny({fossils, dinosaurs}, True)",
            "```",
        ].join("\n"),
    },
    {
        name: "DefinedCategories",
        label: "DefinedCategories(Val: Categorical, [Answers: Variant]): Categorical",
        insertText: "DefinedCategories",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "*Categorical* value, used only to specify which MDM object to use.",
            },
            {
                name: "Answers",
                type: BasicTypeDefinitions.variant,
                optional: true,
                note: "Optional. *Variant* value of type *Categorical* or *Text*, specifying a set of categories. If omitted, all categoriesfrom the VariableInstance are returned."
            }
        ],
        note: [
            "```ds",
            "(function) DefinedCategories(Val: Categorical, [Answers: Variant]): Categorical",
            "```",
            "-----------------------------------",
            "Returns a set of categories of a categorical variable.",
            "+ `Val`: *Categorical* - *Categorical* value, used only to specify which MDM object to use.",
            "+ `Answers`: *Variant* - Optional. *Variant* value of type *Categorical* or *Text*, specifying a set of categories. If omitted, all categoriesfrom the VariableInstance are returned. ",
            "+ `return`: *Categorical* - Set of category numbers as defined in the VariableInstance.",
            "",
            "### Remarks",
            "`Val` may refer to any type of MDM object that has elements, for example, Field, Array , Grid or VariableInstance, or it may be an Elements list itself.",
            "If `Answers` is of type Text, it is assumed to be a category expression and is resolved to a list of categories. If `Answers` is of type *Categorical* and contains category names, they are converted to category numbers.",
            "This function requires the case data to be opened with an MDM document or for a script to have an open MDM document available to it. Otherwise, an error will occur. ",
            "If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is also an empty *Categorical* value. If `Answers` is *NULL*, the return value is all of the categories defined in the current variable.",
            "",
            "### Examples",
            "This example shows how the `DefinedCategories` function can be used in an SQL query on a multiple response variable to define groups based on the categories.",
            "```sql",
            "SELECT groupby.col[0] AS Museums,",
            "    BASE(museums) AS 'Base'",
            "FROM vdata",
            "WHERE museums IS NOT NULL",
            "GROUP BY museums ON museums.DefinedCategories()",
            "```",
            "",
            "Here is the result set:",
            "",
            "| Museums                               | Base    |",
            "| :------------------------------------ | :------ |",
            "| {national_museum_of_science}          | 333     |",
            "| {museum_of_design}                    | 92      |",
            "| {institute_of_textiles_and_fashion}   | 47      |",
            "| {archeological_museum}                | 26      |",
            "| {national_art_gallery}                | 19      |",
            "| {northern_gallery}                    | 21      |",
            "| {other}                               | 37      |",
            "| {not_answered}                        | 0       |",
        ].join("\n"),
    },
    {
        name: "DefinedElements",
        label: "DefinedElements(Val: Categorical, [Types: Long]): Categorical",
        insertText: "DefinedElements",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "*Categorical* value, used only to specify which MDM object to use.",
            },
            {
                name: "Types",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "*Long* - Optional. Flags specifying which types of `Element` objects to include. The default is (Category + Base)."
            }
        ],
        note: [
            "```ds",
            "(function) DefinedElements(Val: Categorical, [Types: Long]): Categorical",
            "```",
            "-----------------------------------",
            "Returns a set of elements of a categorical variable.",
            "The possible values for Types are shown in the following table.",
            "+ `Val`: *Categorical* - *Categorical* value, used only to specify which MDM object to use.",
            "+ `Types`: *Long* - Optional. Flags specifying which types of `Element` objects to include. The default is (Category + Base).",
            "+ `return`: *Categorical* - Set of category numbers as defined in the VariableInstance.",
            "",
            "| Value       | Description           |",
            "| :---------- | :-------------------- |",
            "| 1           | Category elements     |",
            "| 2           | Base elements         |",
            "| 4           | Subtotal elements     |",
            "| 8           | Summary data elements |",
            "| 16          | Derived elements      |",
            "| 32          | Subheading elements   |",
            "",
            "The flags may be used in any combination, to select elements of more than one type. For example, to select all Category and Base elements, use `1 + 2 = 3`.",
            "",
            "### Remarks",
            "`Val` may refer to any type of MDM object that has elements, for example, Field, Array , Grid or VariableInstance, or it may be an Elements list itself.",
            "If the current value is *NULL*, `Val` is an empty Categorical value ({}) and the return value is also an empty Categorical value. ",
            "This function requires the case data to be opened with an MDM document or for a script to have an open MDM document available to it. Otherwise, an error will occur. ",
            "Like `DefinedCategories`, `DefinedElements` is typically used to define groups in SQL queries. However, whereas `DefinedCategories` defines groups based on categories only, you can use `DefinedElements` to define groups based on any element type that stores case data or a combination of these element types. ",
            "",
            "### Examples",
            "The following query creates groups based on all categories and any base elements in the gender and *gender.Ex* variables in the Museum IBM® SPSS® Quanvert™ sample data base. The *gender.Ex* variable is included in the GROUP BY statement because Quanvert DSC stores special elements in a separate variable that has an *.Ex* suffix.",
            "```sql",
            "SELECT groupby.col[0] AS Gender, ",
            "    SUM(visits) AS 'Sum of visits' ",
            "FROM vdata ",
            "WHERE visits > 0 ",
            "GROUP BY gender.EX + gender ",
            "    ON gender.Ex.Definedelements() + gender.Definedelements() ",
            "```",
            "",
            "Here is the result set:",
            "",
            "| Gender      | Sum of visits |",
            "| :---------- | :------------ |",
            "| {base}      | 2131          |",
            "| {male}      | 1309          |",
            "| {female}    | 822           |",
        ].join("\n"),
    },
    {
        name: "DefinedFactors",
        label: "DefinedFactors(Val: Categorical, [Answers: Variant]): Categorical",
        insertText: "DefinedFactors",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "*Categorical* value, used only to specify which MDM object to use.",
            },
            {
                name: "Answers",
                type: BasicTypeDefinitions.variant,
                optional: true,
                note: "Optional. *Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for. If omitted, all categoriesfrom the object are used.",
            }
        ],
        note: [
            "```ds",
            "(function) DefinedFactors(Val: Categorical, [Answers: Variant]): Categorical",
            "```",
            "-----------------------------------",
            "Returns a set of factor numbers as defined on the categories in a variable.",
            "+ `Val`: *Categorical* - *Categorical* value, used only to specify which MDM object to use.",
            "+ `Answers`: *None* - Optional. *Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for. If omitted, all categoriesfrom the object are used.",
            "+ `return`: *Categorical* - Set of factor numbers as defined in on the categories, matching the order of the categories in *Answers*.",
            "",
            "### Remarks",
            "`Val` may refer to any type of MDM object that has elements, for example, Field, Array , Grid or VariableInstance, or it may be an Elements list itself.",
            "If `Answers` is of type Text, it is assumed to be a category expression and is resolved to a list of categories. If `Answers` is of type Categorical and contains category names, they are converted to category numbers.",
            "This function requires the case data to be opened with an MDM document or for a script to have an open MDM document available to it. Otherwise, an error will occur. ",
            "The function returns a factor of 0 for sublists and for categories with no factor defined. Factors can be long or double values.",
            "To sort the returned values, use *SortAsc* or *SortDesc*.",
        ].join("\n"),
    },
    {
        name: "DefinedListElements",
        label: "DefinedListElements(Val: Variant, Answers: String | Categorical, [Types: Long]): Categorical",
        insertText: "DefinedListElements",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* value, used only to specify which MDM object to use.",
            },
            {
                name: "Answers",
                type: [
                    BasicTypeDefinitions.string,
                    BasicTypeDefinitions.categorical,
                ],
                note: "*Text* or *Categorical* value specifying element lists in `Val`."
            },
            {
                name: "Types",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. Flags specifying which types of `Element` objects to include. Default is (Category + Base).",
            }
        ],
        note: [
            "```ds",
            "(function) DefinedListElements(Val: Variant, Answers: String | Categorical, [Types: Long]): Categorical",
            "```",
            "-----------------------------------",
            "Returns a set of elements of a categorical variable.",
            "+ `Val`: *Variant* - *Variant* value, used only to specify which MDM object to use.",
            "+ `Answers`: *String* | *Categorical* - *Text* or *Categorical* value specifying element lists in `Val`.",
            "+ `Types`: *Long* - Optional. Flags specifying which types of `Element` objects to include. Default is (Category + Base).",
            "+ `return`: *Categorical* - Element numbers from the specified lists.",
            "",
            "The possible values for Types are shown in the following table.",
            "",
            "| Value       | Description           |",
            "| :---------- | :-------------------- |",
            "| 1           | Category elements     |",
            "| 2           | Base elements         |",
            "| 4           | Subtotal elements     |",
            "| 8           | Summary data elements |",
            "| 16          | Derived elements      |",
            "| 32          | Subheading elements   |",
            "",
            "These values may be used in any combination, to select elements of more than one type. For example, to select all Category and Base elements, use `1 + 2 = 3`.",
            "",
            "### Remarks",
            "`Val` may refer to any type of MDM object that has elements, for example, Field, Array, Grid or VariableInstance.",
            "If `Answers` is of type Text, it is assumed to be a category expression, except that it only applies to category lists (Elements objects in MDM), and is resolved to a list of lists. (It may contain both names of Elements objects andtheir numeric values.) If `Answers` is of type Categorical, only lists with the same value as the categories in `Answers` are used. If `Answers` is *NULL*, all lists in Val are used. If `Answers` is of any other type, an error occurs.",
            "This function requires the case data to be opened with an MDM document or for a script to have an open MDM document available to it. Otherwise, an error will occur.",
            "The return value is the union of the elements from the selected lists, including elements from any sublists they contain. Any list name or value that is not found among Val's elements is silently ignored (with no error reported).",
        ].join("\n"),
    },
    {
        name: "Difference",
        label: "Difference(Val: Categorical, Answers: String | Categorical): Categorical",
        insertText: "Difference",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "*Categorical* value."
            },
            {
                name: "Answers",
                type: [
                    BasicTypeDefinitions.string,
                    BasicTypeDefinitions.categorical,
                ],
                note: "*Variant* value of type *Categorical* or *Text*, specifying a set of categories.",
            }
        ],
        note: [
            "```ds",
            "(function) Difference(Val: Categorical, Answers: String | Categorical): Categorical",
            "```",
            "-----------------------------------",
            "Returns the difference of two category lists--that is, it returns the categories that are in the first category list but not in the second. The categories are returned in the order in which they appear in the first category list.",
            "+ `Val`: *Categorical* - *Categorical* value.",
            "+ `Answers`: *String* | *Categorical* - *Variant* value of type *Categorical* or *Text*, specifying a set of categories.",
            "+ `return`: *Categorical* - Set of categories that are in `Val` but not in `Answers`, in the order in which they appear in `Val`.",
            "",
            "### Remarks",
            "If the current value is *NULL*, `Val` is an empty Categorical value ({}) and the return value is also an empty Categorical value. If `Answers` is *NULL*, the return value is `Val`.",
            "This function is equivalent to the `subtract (-) arithmetic operator` for Categorical values, except that `Difference` can operate on named categories and the *NULL* behavior is different.",
            "However, using the `subtract (-) operator` is generally faster than using the `Difference` function.",
            "",
            "### Examples",
            "",
            "| Function call       | Q1            | Q2            | Result     |",
            "| :------------------ | :------------ | :------------ | :--------- |",
            "| Q1.Difference(Q2)   | {1,2,3}       | {4,5,6}       | {1,2,3}    |",
            "| Q1.Difference(Q2)   | {1,2,3,4,5,6} | {4,5,6}       | {1,2,3}    |",
            "| Difference(Q1, Q2)  | {1,2,3,4,5,6} | {3,6,4,1,2,5} | {}         |",
            "",
            "Like `Intersection` and `XUnion`, `Difference` is useful when categorical variables have identical or overlapping category lists. ",
            "For example, the *remember* and *interest* variables are categorical variables that have similar category lists. *remember* is a multiple response variable that records which galleries the respondents *remember* viewing, and interest is a single response variable that records which gallery respondents found most interesting. In the following example, the `Difference` function is used to remove the responses given to the *interest* question from the responses given to the *remember* question. The `>=` operator then tests whether the resulting list of categories includes the *Fossils* category. You could use this expression to create a filter to select respondents who remember the *Fossils* gallery, but who did not find it the most interesting gallery.",
            "```ds",
            "Difference(remember, interest) >= {FOSSILS}",
            "```",
        ].join("\n"),
    },
    {
        name: "Factor",
        label: "Factor(Val: Categorical): Variant",
        insertText: "Factor",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "The element to look up."
            }
        ],
        note: [
            "```ds",
            "(function) Factor(Val: Categorical): Variant",
            "```",
            "-----------------------------------",
            "Returns the factor defined for an element of a categorical variable.",
            "+ `Val`: *Categorical* - The element to look up.",
            "+ `return`: *Variant* - Factor number as defined on the element.",
            "",
            "### Remarks",
            "If `Val` contains more than one element, only the factor for the first element is returned. If Val is {}, the return value is *NULL*. If the current data value is *NULL*, Val is {} and the return value is *NULL*.",
            "If the first \"element\" in `Val` is actually (the MDM value of) an element list, the sublist is expanded until an actual element is found, if any. If the element does not have a factor defined, the return value is *NULL*. Note that the factor can be a *Long* or *Double* value.",
        ].join("\n"),
    },
    {
        name: "GetAnswer",
        label: "GetAnswer(Val: Categorical, Index: Long): Categorical",
        insertText: "GetAnswer",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "*Categorical* value.",
            },
            {
                name: "Index",
                type: BasicTypeDefinitions.long,
                note: "Position of category to retrieve from `Val`, starting from 0.",
            }
        ],
        note: [
            "```ds",
            "(function) GetAnswer(Val: Categorical, Index: Long): Categorical",
            "```",
            "-----------------------------------",
            "Returns a specified category in a category list.",
            "+ `Val`: *Categorical* - *Categorical* value.",
            "+ `Index`: *Long* - Position of category to retrieve from `Val`, starting from 0.",
            "+ `return`: *Categorical* - The category at the requested position in Val, if found, or an empty *Categorical* value if it is not found",
            "",
            "### Remarks",
            "If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is also an empty *Categorical* value.",
            "",
            "### Examples",
            "",
            "| Function call  | Q1        | Index     | Result |",
            "| :------------- | :-------- | --------- | ------ |",
            "| GetAnswer(Q1, Index) | {5,1,6,3,2,4} | 0 | {5} |",
            "| Q1.GetAnswer(Index) | {5,1,6,3,2,4} | 3 | {3} |",
            "",
            "The following example tests whether the Fossils category is in the first position in the list of responses stored for each respondent in the remember multiple response variable: ",
            "```ds",
            "remember.GetAnswer(0) = {FOSSILS}",
            "```",
        ].join("\n"),
    },
    {
        name: "HasAnswer",
        label: "HasAnswer(Val: Categorical, Answer: Long): Boolean",
        insertText: "HasAnswer",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "*Categorical* value.",
            },
            {
                name: "Answer",
                type: BasicTypeDefinitions.long,
                note: "Category to look for in `Val`."
            }
        ],
        note: [
            "```ds",
            "(function) HasAnswer(Val: Categorical, Answer: Long): Boolean",
            "```",
            "-----------------------------------",
            "Identifies whether a specified category is in a category list.",
            "+ `Val`: *Categorical* - *Categorical* value.",
            "+ `Answer`: *Long* - Category to look for in `Val`.",
            "+ `return`: *Boolean* - *True* if `Val` contains the category, *False* otherwise.",
            "",
            "### Remarks",
            "If the current value is *NULL*, Val is an empty *Categorical* value ({}) and the return value is *False*.",
            "The `HasAnswer` function has been superseded by `ContainsAll`, `ContainsAny`, and `ContainsSome`. However, `HasAnswer` has been retained for backwards compatibility.",
            "",
            "### Examples",
            "",
            "| Function call         | Response      | Filter  | Result |",
            "| :-------------------- | :------------ | :------ | :----- |",
            "| Q1.HasAnswer(Filter)  | {4,2,9,6,1,7} | 10      | False  |",
            "| HasAnswer(Q1, Filter) | {4,2,9,6,1,7} | 6       | True   |",
            "",
            "The following example selects respondents who chose the category with the mapped category value of 31 (which is the *Dinosaurs* category) in response to the *remember* question. In a multiple response variable, `HasAnswer` returns *True* regardless of whether any other category was chosen in response to the question. This example therefore selects all respondents who chose the *Dinosaurs* category regardless of whether they also chose any other category.",
            "```ds",
            "remember.HasAnswer(31)",
            "```",
        ].join("\n"),
    },
    {
        name: "Intersection",
        label: "Intersection(Val: Categorical, [Vals: String | Categorical ...]): Categorical",
        insertText: "Intersection",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "*Categorical* value.",
            },
            {
                name: "Vals",
                type: [
                    BasicTypeDefinitions.string,
                    BasicTypeDefinitions.categorical
                ],
                ellipsis: true,
                optional: true,
                note: "One or more variant values of type *Categorical* or *Text*. Each value specifies a set of categories.",
            }
        ],
        note: [
            "```ds",
            "(function) Intersection(Val: Categorical, [Vals: String | Categorical ...]): Categorical",
            "```",
            "-----------------------------------",
            "Returns the intersection of two or more category lists--that is, it returns the categories that appear in all of the category lists. The categories are returned in the order in which they appear in the first category list.",
            "+ `Val`: *Categorical* - *Categorical* value.",
            "+ `Vals`: *String* | *Categorical* - One or more variant values of type *Categorical* or *Text*. Each value specifies a set of categories.",
            "+ `return`: *Categorical* - Set of categories that are in all of `Val` and `Vals`, in the order in which they occur in `Val`.",
            "",
            "### Remarks",
            "If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is also an empty Categorical value. If an item in `Vals` is *NULL*, the item is ignored.",
            "This function is equivalent to the `* arithmetic operator` for *Categorical* values, except that `Intersection` can operate on named categories and the *NULL* behavior is different. However, using the `* operator` is generally **faster** than using the `Intersection` function.",
            "",
            "### Examples",
            "",
            "| Function call        | Q1            | Q2            | Result    |",
            "| :-------------       | :--------     | :------------ | :-------- |",
            "| Q1.Intersection(Q2)  | {4,2,9,6,1,7} | {6,10,3,5,9}  | {9,6}     |",
            "| Intersection(Q1, Q2) | {4,2,9,6,1,7} | {3}           | {}        |",
            "",
            "| Function call            | Q1            | Q2            | Q3           | Result    |",
            "| :-------------------     | :------------ | :------------ | :----------- | :-------- |",
            "| Q1.Intersection(Q2, Q3)  | {5,6,8,2,3}   | {1,3,4,6}     | {2,4,6,7,8}  | {6}       |",
            "| Intersection(Q1, Q2, Q3) | {5,6,8,2,3}   | NULL          | {2,4,6,7,8}  | {6,8,2}   |",
            "",
            "Like `Difference` and `XUnion`, `Intersection` is useful when categorical variables have identical or overlapping response lists. The *biology* and *education* variables are single response categorical variables that have identical category lists (*Yes*, *No*, and *Not answered*). You could use the `Intersection` function to return the categories that are in both of the category lists. In the following example, the `= operator` tests whether the result is the *Yes* category. You could therefore use this example to select respondents who chose the Yes category in response to both questions.",
            "```ds",
            "biology.Intersection(education) = {yes}",
            "```",
        ].join("\n"),
    },
    {
        name: "LBound",
        label: "LBound(List: Categorical | Array, [Dimension: Long = 1]): Long",
        insertText: "LBound",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "List",
                type: [
                    BasicTypeDefinitions.categorical,
                    BasicTypeDefinitions.array
                ],
                note: "*Array* or *Categorical* value."
            },
            {
                name: "Dimension",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 1,
                note: "*Long* - *Array* dimension to use. The default is 1.",
            }
        ],
        note: [
            "```ds",
            "(function) LBound(List: Categorical | Array, [Dimension: Long]): Long",
            "```",
            "-----------------------------------",
            "Returns the smallest available subscript for the indicated dimension of an array. By default, the lower bound is returned for the first dimension of the array.",
            "+ `List`: *Categorical* - *Array* or *Categorical* value.",
            "+ `Dimension`: *Long* - *Array* dimension to use. The default is 1.",
            "+ `return`: *Long* - Lower bound of the list.",
            "",
            "### Remarks",
            "This function returns the numeric index of the first item in (a particular dimension of) an array. If `Dimension` is greater than the number of dimensions in the array, the last dimension is used, and if `Dimension` is less than 1, the first dimension is used. A *Categorical* value is treated as a one-dimensional array. For arrays created in mrScriptBasic and the IBM® SPSS® Data Collection Data Model, the lower bound is always 0.",
            "This function is similar to the LBound function in Visual Basic.",
            "",
            "### Examples",
            "The following mrScriptBasic example defines a two-dimensional array that has 10 rows and an undefined number of columns and assigns a value to the third column in the fourth row. `LBound` is then used to return the lower bound values of the two dimensions. However, because the array was created in mrScriptBasic, the return value for both dimensions is 0.",
            "```ds",
            "Dim MyArray[10][], a, b",
            "",
            "MyArray[3][2] = 28",
            "",
            "a = LBound(MyArray, 1)       ' Returns 0",
            "b = LBound(MyArray, 2)       ' Returns 0",
            "```",
        ].join("\n"),
    },
    {
        name: "Merge",
        label: "Merge([Vals: Variant, ...]): Categorical",
        insertText: "Merge",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Vals",
                type: BasicTypeDefinitions.variant,
                ellipsis: true,
                optional: true,
                note: "One or more values."
            }
        ],
        note: [
            "```ds",
            "(function) Merge([Vals: Variant, ...]): Categorical",
            "```",
            "-----------------------------------",
            "Returns the union of a number of categorical values; that is, returns the categories that are in any of the input categorical values.",
            "+ `Vals`: *Variant* - One or more values.",
            "+ `return`: *Categorical* - The union of categorical values from `Vals`.",
            "",
            "### Remarks",
            "Values in `Vals` are converted to categorical values if necessary, and the return value is their union. *NULL* values are ignored. If a value cannot be converted to a categorical type, an error occurs. If `Vals` is empty (no arguments are supplied), or all the values are *NULL*, the return value is *NULL*. This function differs from using the `+ operator` to get the union of categorical values, by ignoring *NULL* values instead of giving a *NULL* result if any *NULL* values are present. It differs from the `Union` function by not supporting the use of category expressions.",
            "",
            "### Examples",
            "The following mrScriptBasic example combines the results of three categorical variables to produce a merged categorical variable.",
            "```ds",
            "Merge(Q1, Q2, Q3)",
            "```",
        ].join("\n"),
    },
    {
        name: "ReDim",
        label: "ReDim(List: Array, Size: Long, [Preserve: Boolean = True]): Long",
        insertText: "ReDim",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "List",
                type: BasicTypeDefinitions.categorical,
                note: "*Array* or *Categorical* value.",
            },
            {
                name: "Size",
                type: BasicTypeDefinitions.long,
                note: "New size of the array.",
            },
            {
                name: "Preserve",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                defaultValue: true,
                note: "Defines whether to keep the existing contents. The default is *True*.",
            }
        ],
        note: [
            "```ds",
            "(function) ReDim(List: Categorical | Array, Size: Long, [Preserve: Boolean = True]): Long",
            "```",
            "-----------------------------------",
            "Re-sizes an array to a given size. By default, the array contents are preserved, unless `Preserve` is set to *False*.",
            "+ `List`: *Categorical* - *Array* or *Categorical* value.",
            "+ `Size`: *Long* - New size of the array.",
            "+ `Preserve`: *Boolean* - Defines whether to keep the existing contents. The default is *True*.",
            "+ `return`: *Long* - Always zero.",
            "",
            "### Remarks",
            "This function changes the size of the last dimension of an array. If `Preserve` is *False*, all items in all dimensions are cleared. A *Categorical* value is treated as a one-dimensional array.",
            "This function is similar to the `ReDim` function in Visual Basic.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses `ReDim` to redefine a categorical value without clearing it. `UBound` is used to return the upper bound value before and after calling ReDim.",
            "```ds",
            "Dim MyCategorical, x, y",
            "",
            "MyCategorical = {1, 3, 5, 8}",
            "",
            "x = UBound(MyCategorical)   ' Returns 3",
            "",
            "ReDim(MyCategorical, 2)",
            "",
            "y = UBound(MyCategorical)   ' Returns 1",
            "```",
            "",
            "In this next example, the `Size` parameter is set to 4 and the `Preserve` parameter is set to *False*.",
            "```ds",
            "Dim MyCategorical, x, y",
            "",
            "MyCategorical = {1, 3, 5, 8}",
            "",
            "ReDim(MyCategorical, 4, False)",
            "",
            "z = UBound(MyCategorical)   ' Returns 3",
            "```",
        ].join("\n"),
    },
    {
        name: "UBound",
        label: "UBound(List: Array, [Dimension: Long = 1]): Long",
        insertText: "UBound",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "List",
                type: BasicTypeDefinitions.categorical,
                note: "*Array* or *Categorical* value."
            },
            {
                name: "Dimension",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 1,
                note: "Array dimension to use. The default is 1."
            }
        ],
        note: [
            "```ds",
            "(function) UBound(List: Categorical | Array, [Dimension: Long = 1]): Long",
            "```",
            "-----------------------------------",
            "Returns the largest available subscript for the indicated dimension of an array. By default, the upper bound is returned for the first dimension of the array.",
            "+ `List`: *Categorical* - *Array* or *Categorical* value.",
            "+ `Dimension`: *Long* - Array dimension to use. The default is 1.",
            "+ `return`: *Long* - Upper bound of the list.",
            "",
            "### Remarks",
            "This function returns the numeric index of the last item in (a particular dimension of) an array. If `Dimension` is greater than the number of dimensions in the array, the last dimension is used, and if `Dimension` is less than 1, the first dimension is used. A *Categorical* value is treated as a one-dimensional array.",
            "This function is similar to the UBound function in Visual Basic.",
            "",
            "### Examples",
            "The following mrScriptBasic example defines a two-dimensional array that has 10 rows and an undefined number of columns and assigns a value to the third column in the fourth row. `UBound` is then used to return the upper bound values of the two dimensions.",
            "```ds",
            "Dim MyArray[10][], x, y",
            "",
            "MyArray[3][2] = 28",
            "",
            "x = UBound(MyArray, 1)    ' Returns 9 ",
            "y = UBound(MyArray, 2)    ' Returns 2",
            "```",
        ].join("\n"),
    },
    {
        name: "Union",
        label: "Union(Val: Categorical, [Vals: Categorical ...]): Categorical",
        insertText: "Union",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "*Categorical* value."
            },
            {
                name: "Vals",
                type: BasicTypeDefinitions.categorical,
                ellipsis: true,
                optional: true,
                note: "One or more variant values of type *Categorical* or *Text*. Each value specifies a set of categories."
            }
        ],
        note: [
            "```ds",
            "(function) Union(Val: Categorical, [Vals: Categorical | String ...]): Categorical",
            "```",
            "-----------------------------------",
            "Returns the union of two or more category lists--that is, it returns all of the categories that are in any one or more of the category lists.",
            "+ `Val`: *Categorical* - *Categorical* value.",
            "+ `Vals`: *Categorical* | *String* - One or more variant values of type *Categorical* or *Text*. Each value specifies a set of categories.",
            "+ `return`: *Categorical* - All of the categories in `Val` , followed by any other categories that are in `Vals`.",
            "",
            "### Remarks",
            "If an item in `Vals` is *NULL*, the item is ignored. If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is the union of all non-NULL items in `Vals`.",
            "This function is equivalent to the `+ arithmetic operator` for *Categorical* values, except that Union can operate on named categories and the *NULL* behavior is different. However, using the `+ operator` is generally faster than using the `Union` function.",
            "",
            "### Examples",
            "",
            "| Function call       | Q1             | Q2                | Result          |",
            "| :------------------ | :------------- | :---------------- | :------------   |",
            "| Union(Q1, Q2)       | {5,1,6,3,2,4}  | {3,6,7,5}         | {5,1,6,3,2,4,7} |",
            "| Q1.Union(Q2)        | {4,2,9,6,1,7}  | {}                | {4,2,9,6,1,7}   |",
            "",
            "| Function call       | Q1             | Q2                | Q3               | Result          |",
            "| :------------------ | :------------- | :---------------- | :--------------- | :------------   |",
            "| Q1.Union(Q2, Q3)    | {6,8,2,3}      | {3,4,6}           | {1,7,8}          | {6,8,2,3,4,1,7} |",
            "| Union(Q1, Q2, Q3)   | {6,8,2,3}      | {3,4,6}           | NULL             | {6,8,2,3,4}     |",
            "",
            "The following example uses `Union` to combine the results of two single response categorical variables that have similar category lists and tests whether the result includes the *Yes* category. For example, you could use this example to select respondents who chose *Yes* in response to at least one of the questions.",
            "```ds",
            "Union(biology, education) >= {yes}",
            "```",
        ].join("\n"),
    },
    {
        name: "Unique",
        label: "Unique(Val: Categorical): Categorical",
        insertText: "Unique",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "*Categorical* value."
            }
        ],
        note: [
            "```ds",
            "(function) Unique(Val: Categorical): Categorical",
            "```",
            "-----------------------------------",
            "Returns a category list with any duplicate categories removed.",
            "+ `Val`: *Categorical* - *Categorical* value.",
            "+ `return`: *Categorical* - The categories in `Val`, but with any duplicates removed.",
            "",
            "### Remarks",
            "If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is also an empty *Categorical* value.",
            "Note that `Val` cannot consist of a category expression.",
            "",
            "### Examples",
            "",
            "| Function call | Q1                | Result        |",
            "| :------------ | :------------     | :----------   |",
            "| Q1.Unique()   | {5,1,6,4,3,5,2,4} | {5,1,6,4,3,2} |",
            "| Unique(Q1)    | {3,1,2}           | {3,1,2}       |",
            "",
        ].join("\n"),
    },
    {
        name: "XUnion",
        label: "XUnion(Val: Categorical, Answers: Categorical): Categorical",
        insertText: "XUnion",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.categorical,
                note: "*Categorical* value."
            },
            {
                name: "Answers",
                type: BasicTypeDefinitions.categorical,
                note: "*Variant* value of type *Categorical* or *Text*, specifying a set of categories."
            }
        ],
        note: [
            "```ds",
            "(function) XUnion(Val: Categorical, Answers: Categorical | String): Categorical",
            "```",
            "-----------------------------------",
            "Returns the exclusive union of two category lists--that is, it returns all of the categories that are in either one of the category lists, but not in both.",
            "+ `Val`: *Categorical* - *Categorical* value.",
            "+ `Answers`: *Categorical* | *String* - *Variant* value of type *Categorical* or *Text*, specifying a set of categories. ",
            "+ `return`: *Categorical* - Set of categories that are in either `Val` or `Answers` but not in both.",
            "",
            "### Remarks",
            "If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is `Answers`. If `Answers` is *NULL*, the return value is `Val`.",
            "This function is equivalent to the `/ arithmetic operator` for *Categorical* values, except that it can operate on named categories and the *NULL* behavior is different. However, using the `/ operator` is generally faster than using the `XUnion` function.",
            "",
            "### Examples",
            "",
            "| Function call  | Q1                | Q2               | Result          |",
            "| :------------  | :------------     | :------------    | :----------     |",
            "| XUnion(Q1, Q2) | {3,5,9,10,23,5,6} | {5,16,4,10}      | {3,9,23,6,16,4} |",
            "| Q1.XUnion( Q2) | {3,5,9,}          | {5,3,9}          | {}              |",
            "",
            "Like the `Difference` and `Intersection` functions, `XUnion` is useful when categorical variables have identical or overlapping category lists. For example the *biology* and *education* variables have identical response lists. In the following example, `XUnion` is used to return any categories that are in either one of the category lists, but not in both and the `>= operator` tests whether the result contains the *Yes* category. For example, you could use this expression to select respondents who chose the *Yes* category in response to either one of the questions, but not to both.",
            "```ds",
            "XUnion(biology, education) >= {yes}",
            "```",
        ].join("\n"),
    },
    {
        name: "Find",
        label: "Find(Val: String | Categorical | Array, Key: Variant, [Skip: Long = 0], [Reverse: Boolean = False], [IgnoreCase: Boolean = True]): Long",
        insertText: "Find",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.string,
                    BasicTypeDefinitions.categorical,
                    BasicTypeDefinitions.array,
                ],
                note: "*Text* value, *Categorical* value, or *Array* to operate on."
            },
            {
                name: "Key",
                type: BasicTypeDefinitions.variant,
                note: "Value to search for in `Val`."
            },
            {
                name: "Skip",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 0,
                note: "Optional. The number of positions to skip in `Val` before starting the search. If `Reverse` is *True*, `Skip` is the number of positions to skip from the end of `Val`. If `Reverse` is omitted or *False*, Skip is the number of positions to skip from the start of `Val`. Treated as 0 if omitted or is < 0."
            },
            {
                name: "Reverse",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                defaultValue: false,
                note: "Optional. If *True*, `Val` is searched backwards. If `Reverse` is omitted or *False*, `Val` is searched forwards."
            },
            {
                name: "IgnoreCase",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                defaultValue: true,
                note: "Optional. If *False*, the comparison is case-sensitive. If `IgnoreCase` is omitted or *True*, the comparison is case-insensitive."
            }
        ],
        note: [
            "```ds",
           "(function) Find(Val: String | Categorical | Array, Key: Variant, [Skip: Long = 0], [Reverse: Boolean = False], [IgnoreCase: Boolean = True]): Long",
            "```",
            "-----------------------------------",
            "Searches a string, a category list, or an array, for a specified substring, subcategory list, or subarray, and if it is found, returns its start position.",
            "+ `Val`: *String* | *Categorical* | *Array* - *Text* value, *Categorical* value, or *Array* to operate on.",
            "+ `Key`: *Variant* - Value to search for in `Val`.",
            "+ `Skip`: *Long* - Optional. The number of positions to skip in `Val` before starting the search. If `Reverse` is *True*, `Skip` is the number of positions to skip from the end of `Val`. If `Reverse` is omitted or *False*, Skip is the number of positions to skip from the start of `Val`. Treated as 0 if omitted or is < 0.",
            "+ `Reverse`: *Boolean* - Optional. If *True*, `Val` is searched backwards. If `Reverse` is omitted or *False*, `Val` is searched forwards.",
            "+ `IgnoreCase`: *Boolean* - Optional. If *False*, the comparison is case-sensitive. If `IgnoreCase` is omitted or *True*, the comparison is case-insensitive.",
            "+ `return`: *Long* - Position in `Val`, relative to the start of `Val`, of `Key` if found, -1 otherwise. ",
            "",
            "### Remarks",
            "If `Val` is *Text*, `Key` is converted to text if necessary and is searched for as a substring of `Val`. Unless `IgnoreCase` is *False*, the comparison is case-insensitive.",
            "If `Val` is *Categorical* or an *Array* (which can contain values of any type), Key can be a *long*, *double*, *text*, *date*, *boolean*, or *categorical* value, or an *array*. When comparing `Key` (or the items in `Key`) with the items in `Val`, the normal conversion and comparison rules for variant types are used if necessary. Unless IgnoreCase is False, the comparison of text items (or items converted to text) is case-insensitive. If either item is *Null*, they are equal only if both are *Null*. If `Key` is a categorical value or an array, it is found only if its items occur as a sequence of consecutive items in `Val` and in the same order.",
            "If either `Val` or Key is *NULL*, the return value is -1 (not found). If `Val` is not *Text*, *Categorical*, or an *Array*, an error occurs.",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "",
            "### Examples",
            "",
            "| Function call             | Val                            | Key                  |  Result |",
            "| :----------------         | :-----------                   | :-------------       | :-----  |",
            "| Find(Val, Key)            | 24 St John's Road, Barnes      | barnes               | 19      |",
            "| Find(Val, Key, , True)    | 3 Glasgow Hill, Glasgow        | glasgow              | 16      |",
            "| Find(Val, Key)            | {3,7,8,1,9,10,5,4}             | 5                    | 6       |",
            "| Find(Val, Key, 7)         | {3,7,8,1,9,10,5,4}             | 5                    | -1      |",
            "| Find(Val, Key, , , False) | 24 St John's Road, Barnes      | barnes               | -1      |",
            "| Find(Val, Key)            | Split(\"The quick brown fox\") | Split(\"brown fox\") | 2       |",
            "",
            "**Text variables**. These examples use the name and address variables, which are text variables that store respondents' names and addresses, respectively. These examples show how you would use the Find function in mrScriptBasic or mrScriptMetadata. In SQL queries, you should enclose text strings in single quotation marks (' ') instead of double quotation marks (\" \").",
            "The following example selects any respondent whose address contains \"London\" in upper case, lower case, or a mixture of both cases. Find returns -1 when the search string has not been found. In this example the <> operator is used to test that the return value is not -1, which means that \"London\" exists somewhere in the text being searched. ",
            "```ds",
            "address.Find(\"London\") <> -1",
            "```",
            "Find lets you search for a string in a particular position. This is useful when the position of the search string in the text you are searching is important. For example, the following selects respondents whose names begin with the string \"Brian\":",
            "```ds",
            "Find(name, \"Brian\") = 0",
            "```",
            "",
            "**Categorical variables**. These examples use the *remember* multiple response variable.",
            "This example selects all respondents who chose the *Dinosaurs* category regardless of its position in the list of categories chosen:",
            "```ds",
            "remember.Find({dinosaurs}) <> -1",
            "```",
            "The next example selects respondents for whom the *Dinosaurs* category is the first category in the list of their responses: ",
            "```ds",
            "remember.Find({dinosaurs}) = 0",
            "```",
        ].join("\n"),
    },
    {
        name: "Left",
        label: "Left(Val: String | Categorical | Array, Length: Long): Variant",
        insertText: "Left",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.string,
                    BasicTypeDefinitions.categorical,
                    BasicTypeDefinitions.array
                ],
                note: "*Text* value, *categorical* value, or *Array* to operate on."
            },
            {
                name: "Length",
                type: BasicTypeDefinitions.long,
                note: "Number of characters, categories, or elements to return. If `Length` is greater than the number of items available, all of the items are returned."
            }
        ],
        note: [
            "```ds",
            "(function) Left(Val: String | Categorical | Array, Length: Long): Variant",
            "```",
            "-----------------------------------",
            "Returns a string containing the first characters from a string, a category list containing the first categories from a category list, or an array containing the first elements from an array.",
            "+ `Val`: *String* | *Categorical* | *Array* - *Text* value, *categorical* value, or *Array* to operate on.",
            "+ `Length`: *Long* - Number of characters, categories, or elements to return. If `Length` is greater than the number of items available, all of the items are returned.",
            "+ `return`: *Variant* - The required characters, categories, or elements from `Val`.",
            "",
            "### Remarks",
            "For type *Text*, the return value is of type *Text*, and contains `Length` characters from the start of `Val`. For type *Categorical*, the return value is of type *Categorical*, and contains Length categories from the start of `Val`. For an array (which can contain values of any type), the return value is an array, and contains `Length` elements from the start of `Val`. For any other type, an error occurs.",
            "When `Val` is *NULL*, the return value is *NULL*.",
            "",
            "### Examples",
            "",
            "| Function call     | Val                            | Length | Result            |",
            "| :-------------    | :-------------                 | :----- | :---------------- |",
            "| Left(Val, Length) | 24 St John's Road, Barnes      | 10     | 24 St John        |",
            "| Left(Val, Length) | {4,2,9}                        | 1      | {4}               |",
            "| Left(Val, Length) | Split(\"The quick brown fox\") | 2      | {The,quick}       |",
            "",
            "The following example returns the first six characters of the *name* text variable:",
            "```ds",
            "name.Left(6)",
            "```",
            "The following example returns the first three categories stored in the *remember* multiple response variable:",
            "```ds",
            "remember.Left(3)",
            "```",
        ].join("\n"),
    },
    {
        name: "Len",
        label: "Len(Val: String | Categorical | Array): Long",
        insertText: "Len",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.string,
                    BasicTypeDefinitions.categorical,
                    BasicTypeDefinitions.array
                ],
                note: "*Text* value, *Categorical* value, or *Array* to operate on."
            }
        ],
        note: [
            "```ds",
            "(function) Len(Val: String | Categorical | Array): Long",
            "```",
            "-----------------------------------",
            "Returns a *Long* containing the number of characters in a string, the number of categories in a category list, or the number of elements in an array.",
            "+ `Val`: *String* | *Categorical* | *Array* - *Text* value, *Categorical* value, or *Array* to operate on.",
            "+ `return`: *Long* - Numbers of characters, categories, or elements in `Val`.",
            "",
            "### Remarks",
            "For type *Text*, the return value is the number of characters in `Val`. For type *Categorical*, the return value is the number of categories in `Val`. For an *Array* (which can contain values of any type), the return value is the number of elements in `Val`. For any other type, an error occurs.",
            "When `Val` is *NULL*, the return value is zero. ",
            "",
            "### Examples",
            "",
            "| Function call | Val                            | Result |",
            "| :------------ | :---------------               | :----  |",
            "| Len(Val)      | 24 St John's Road, Barnes      | 25 |",
            "| Len(Val)      | {4,2,9}                        | 3 |",
            "| Len(Val)      | Split(\"The quick brown fox\") | 4 |",
            "",
            "The following example returns the number of characters stored in the *address* text variable:",
            "```ds",
            "address.Len()",
            "```",
            "The following example returns the number of categories selected by the respondent in response to the *remember* multiple response question:",
            "```ds",
            "remember.Len()",
            "```",
        ].join("\n"),
    },
    {
        name: "Mid",
        label: "Mid(Val: String | Categorical | Array, Start: Long, [Length: Long]): Variant",
        insertText: "Mid",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.string,
                    BasicTypeDefinitions.categorical,
                    BasicTypeDefinitions.array
                ],
                note: "*Text* value, *categorical* value, or *array* to operate on."
            },
            {
                name: "Start",
                type: BasicTypeDefinitions.long,
                note: "Position in `Val` of the first character, category, or element wanted (counting from 0). If `Start` is greater than the number of items in `Val`, no items are returned. If `Start` is less than 0, items are returned from the start of `Val`."
            },
            {
                name: "Length",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. Number of characters, categories, or elements to return. If `Length` is omitted, or if there are fewer than *Lengthcharacters* (including the `Start` character), all characters from `Start` to the end of the string are returned. If `Start` + `Length` is < 1, no items are returned."
            }
        ],
        note: [
            "```ds",
            "(function) Mid(Val: String | Categorical | Array, Start: Long, [Length: Long]): Variant",
            "```",
            "-----------------------------------",
            "+ `Val`: *String* | *Categorical* | *Array* - *Text* value, *categorical* value, or *array* to operate on.",
            "+ `Start`: *Long* - Position in `Val` of the first character, category, or element wanted (counting from 0). If `Start` is greater than the number of items in `Val`, no items are returned. If `Start` is less than 0, items are returned from the start of `Val`.",
            "+ `Length`: *Long* - Optional. Number of characters, categories, or elements to return. If `Length` is omitted, or if there are fewer than *Lengthcharacters* (including the `Start` character), all characters from `Start` to the end of the string are returned. If `Start` + `Length` is < 1, no items are returned.",
            "+ `return`: *Variant* - The required characters, categories, or elements from `Val`.",
            "",
            "### Remarks",
            "For type *Text*, the return value is of type *Text*, and contains `Length` characters from the position `Start` in `Val`. For type *Categorical*, the value is of type *Categorical*, and contains `Length` categories from the position `Start` in `Val`. For an *array* (which can contain values of any type), the return value is an *array*, and contains `Length` elements from the position `Start` in `Val`. For any other type, an error occurs.",
            "When `Val` is *NULL*, the return value is *NULL*.",
            "",
            "### Examples",
            "",
            "| Function call           | Val                            | Start | Length | Result      |",
            "| :-------------          | :---------------               | :---- | :----- | :---------- |",
            "| Mid(Val, Start, Length) | 24 St John's Road, Barnes      | 10    | 15     | 's Road, Barnes |",
            "| Mid(Val, Start, Length) | {4,2,9}                        | 2     | 1      | {9}             |",
            "| Mid(Val, Start, Length) | {4,2,9}                        | 6     | 3      | {}              |",
            "| Mid(Val, Start, Length) | {4,2,9}                        | 0     | 2      | {4,2}           |",
            "| Mid(Val, Start, Length) | {4,2,9}                        | 0     |        | {4,2,9}         |",
            "| Mid(Val, Start, Length) | Split(\"The quick brown fox\") | 1     | 2      | {quick,brown}   |",
            "",
            "The following example returns characters 8-17 from the *address* text variable:",
            "```ds",
            "address.Mid(7, 10)",
            "```",
            "The following example returns the fourth category from the list of categories stored in the *remember* multiple response variable:",
            "```ds",
            "remember.Mid(3, 1)",
            "```",
            "For respondents who chose less than four categories, this returns an empty category list ({}).",
        ].join("\n"),
    },
    {
        name: "Right",
        label: "Right(Val: String | Categorical | Arrary, Length: Long): Variant",
        insertText: "Right",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.string,
                    BasicTypeDefinitions.categorical,
                    BasicTypeDefinitions.array
                ],
                note: "*Text* value, *categorical* value, or *array* to operate on."
            },
            {
                name: "Long",
                type: BasicTypeDefinitions.long,
                note: "Number of characters, categories, or elements to return. If `Length` is greater than the number of items available, all of the items are returned."
            },
        ],
        note: [
            "```ds",
            "(function) Right(Val: String | Categorical | Arrary, Length: Long): Variant",
            "```",
            "-----------------------------------",
            "Returns a string containing the last characters from a string, a category list containing the last categories from a category list, or an array containing the last elements from an array.",
            "+ `Val`: *String* | *Categorical* | *Array* - *Text* value, *categorical* value, or *array* to operate on.",
            "+ `Length`: *Long* - Number of characters, categories, or elements to return. If `Length` is greater than the number of items available, all of the items are returned.",
            "+ `return`: *Variant* - The required characters, categories, or elements from `Val`.",
            "",
            "### Remarks",
            "For type *Text*, the return value is of type *Text*, and contains Length characters from the end of `Val`. For type *Categorical*, the return value is of type *Categorical*, and contains `Length` categories from the end of `Val`. For an *array* (which can contain values of any type), the return value is an *array*, and contains `Length` elements from the end of `Val`. For any other type, an error occurs.",
            "When `Val` is *NULL*, the return value is *NULL*.",
            "",
            "### Examples",
            "",
            "| Function call      | Val                            | Length | Result       |",
            "| :----------------  | :--------------------          | :----- | :----------- |",
            "| Right(Val, Length) | 24 St John's Road, Barnes      | 6      | Barnes       |",
            "| Right(Val, Length) | {4,2,9,15,6,7}                 | 1      | {7}          |",
            "| Right(Val, Length) | Split(\"The quick brown fox\") | 3      | {quick,brown,fox} |",
            "",
            "The following example returns the 10 rightmost characters stored in the *address* text variable:",
            "```ds",
            "address.Right(10)",
            "```",
            "The following example returns the last two categories in the list of categories stored in the *remember* multiple response variable:",
            "```ds",
            "remember.Right(2)",
            "```",
        ].join("\n"),
    },
    {
        name: "CBoolean",
        label: "CBoolean(Val: Variant): Boolean",
        insertText: "CBoolean",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* value to be converted."
            }
        ],
        note: [
            "```ds",
            "(function) CBoolean(Val: Variant): Boolean",
            "```",
            "-----------------------------------",
            "Converts a value of any data type to a *Boolean* value.",
            "+ `Val`: *Variant* - *Variant* value to be converted.",
            "+ `return`: *Boolean* - *Boolean* value derived from `Val`.",
            "",
            "### Remarks",
            "The result of the conversion depends on the data type of `Val`, as follows:",
            "+ **Boolean**        - `Val` is returned unchanged. ",
            "+ **Long or Double** - If `Val` is zero, the return value is *False*, otherwise it is *True*.",
            "+ **Date**           - If `Val` is *30 December 1899 00:00:00*, the return value is *False*, otherwise it is *True*.",
            "+ **Text**           - The string is parsed according to the locale to extract the value. An error occurs if the string does not contain a recognizable *Boolean* value (numeric, or a string representing *True* or *False*).",
            "+ **Categorical**    - The conversion results in a value of *False* if the categorical value is empty ({}) and a value of *True* for all other categorical values.",
            "+ **Object**         - If the object has a default property, the value of that property is converted. Otherwise an error occurs.",
            "+ **NULL**           - If `Val` is *NULL*, the return value is *False*.",
            "",
            "This function is similar to CBool in Visual Basic.",
            "",
            "### Examples",
            "",
            "| Data Type   | Value                    | Result |",
            "| :---------  | :----------------------- | :----- |",
            "| Long        | 133                      | True  |",
            "| Long        | 0                        | False  |",
            "| Double      | 4.5                      | True  |",
            "| Date        | 30                       | December 1899 00:00:00 False  |",
            "| Date        | 14                       | April 2001 4:14:06 True  |",
            "| Text        | 24                       | St John's Road, Barnes Error  |",
            "| Text        | 0                        | False  |",
            "| Text        | true                     | True  |",
            "| Categorical | {}                       | False  |",
            "| Categorical | {Whales}                 | True  |",
            "",
        ].join("\n"),
    },
    {
        name: "CCategorical",
        label: "CCategorical(Val: Variant): Categorical",
        insertText: "CCategorical",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* value to be converted."
            }
        ],
        note: [
            "```ds",
            "(function) CCategorical(Val: Variant): Categorical",
            "```",
            "-----------------------------------",
            "Converts a value of any data type to a *Categorical* value.",
            "+ `Val`: *Variant* - *Variant* value to be converted. ",
            "+ `return`: *Categorical* - *Categorical* value derived from `Val`.",
            "",
            "### Remarks",
            "The result of the conversion depends on the data type of Val, as follows:",
            "+ **Long** - The return value contains a single category whose value is `Val`.",
            "+ **Text** - The function parses the string as a comma-separated list of either category values or names. Category values must be of the form \"{1,2,0}\", and the return value contains each listed value, in the order given. Category names must be of the form \"{married,single,widowed,other}\", which the function will convert to a list of category values. You can omit the braces if the value to be converted is a single category value or name. Note that Val cannot consist of a category expression.",
            "+ **Categorical** - `Val` is returned unchanged. ",
            "+ **Double, Date, or Boolean** - An error occurs.",
            "+ **Object** - If the object has a default property, the value of that property is converted. Otherwise an error occurs.",
            "+ **NULL** - If `Val` is *NULL*, the return value is an empty *Categorical* value ({}).",
            "",
            "There is no equivalent function in Visual Basic.",
            "",
            "### Examples",
            "",
            "| Data Type   | Value                     | Result |",
            "| :---------  | :-----------------------  | :----- |",
            "| Boolean     | True                      | Error   |",
            "| Categorical | {2,8,9,3,1}               | {2,8,9,3,1}   |",
            "| Long        | 459                       | {459}   |",
            "| Text        | {3,6,8}                   | {3,6,8}   |",
            "| Text        | {dinosaurs,birds,mammals} | {31,35,38}   |",
            "| Text        | 24                        | {24}   |",
            "| Text        | Some text                 | Error   |",
            "",
        ].join("\n"),
    },
    {
        name: "CDate",
        label: "CDate(Val: Variant): Date",
        insertText: "CDate",
        definitionType: "function",
        returnType: BasicTypeDefinitions.date,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* value to be converted."
            }
        ],
        note: [
            "```ds",
            "(function) CDate(Val: Variant): Date",
            "```",
            "-----------------------------------",
            "Converts a value of any data type to a *Date* value.",
            "+ `Val`: *Variant* - *Variant* value to be converted.",
            "+ `return`: *Date* - *Date* value derived from `Val`.",
            "",
            "### Remarks",
            "The converted dates are held in Microsoft variant date standard format. Converting other data types to a date is likely to give meaningless results.",
            "The result of the conversion depends on the data type of `Val`, as follows:",
            "+ **Boolean** - The return value is likely to be meaningless.",
            "+ **Long** - The day is `Val` days after *30 December 1899* (or before, if `Val` is negative) and the time is *00:00:00*.",
            "+ **Double** - The return value is the date and time resulting from using `Val` as the internal representation of the date.",
            "+ **Date** - `Val` is returned unchanged.",
            "+ **Text** - The string is parsed according to the locale to extract the value. An error occurs if the string does not contain a properly formatted date.",
            "+ **Categorical** - An error occurs.",
            "+ **Object** - If the object has a default property, the value of that property is converted. Otherwise an error occurs.",
            "+ **NULL** - If `Val` is *NULL*, the return value is *30 December 1899 00:00:00*.",
            "",
            "This function is similar to `CDate` in Visual Basic.",
            "",
            "### Examples",
            "",
            "| Data Type   | Value                     | Result |",
            "| :---------  | :-----------------------  | :----- |",
            "| Long        | 37430                     | 6/23/2002    |",
            "| Double      | 37429.56                  | 6/22/2002 1:26:24 PM    |",
            "| Text        | 14 April 2001 20:30:02    | 4/14/2001 8:30:02 PM    |",
            "| Text        | Fossils                   | Error    |",
            "| Categorical | {5,3,1,9}                 | Error    |",
            "",
        ].join("\n"),
    },
    {
        name: "CDouble",
        label: "CDouble(Val: Variant): Double",
        insertText: "CDouble",
        definitionType: "function",
        returnType: BasicTypeDefinitions.double ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* value to be converted."
            }
        ],
        note: [
            "```ds",
            "(function) CDouble(Val: Variant): Double",
            "```",
            "-----------------------------------",
            "Converts a value of any data type to a *Double* value.",
            "+ `Val`: *Variant* - *Variant* value to be converted.",
            "+ `return`: *Double* - *Double* value derived from `Val`.",
            "",
            "### Remarks",
            "The result of the conversion depends on the data type of `Val`, as follows:",
            "+ **Boolean** - The return value is 1.0 (*True*) or 0.0 (*False*).",
            "+ **Long** - The return value is equal to `Val`, with a fractional part of zero.",
            "+ **Double** - `Val` is returned unchanged. ",
            "+ **Date** - The return value is the floating-point number used internally to represent the date. ",
            "+ **Text** - The string is parsed according to the locale to extract the value. An error occurs if the string does not contain a properly formatted double.",
            "+ **Categorical** - An error occurs.",
            "+ **Object** - If the object has a default property, the value of that property is converted. Otherwise an error occurs.",
            "+ **NULL** - If `Val` is *NULL*, the return value is 0.0.",
            "",
            "This function is similar to `CDbl` in Visual Basic.",
            "",
            "### Examples",
            "",
            "| Data Type   | Value                     | Result |",
            "| :---------  | :-----------------------  | :----- |",
            "| Boolean     | True                      | 1.0   |",
            "| Long        | 345                       | 345.0   |",
            "| Double      | 56.798                    | 56.798   |",
            "| Text        | 14 April 2001 20:30:02    | 36995.8541898148   |",
            "| Text        | Fossils                   | Error   |",
            "| Categorical | {5,3,1,9}                 | Error   |",
            "",
        ].join("\n"),
    },
    {
        name: "CLong",
        label: "CLong(Val: Variant): Long",
        insertText: "CLong",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* value to be converted."
            }
        ],
        note: [
            "(function) CLong(Val: Variant): Long",
            "-----------------------------------",
            "Converts a value of any data type to a *Long* value.",
            "+ `Val`: *Variant* - *Variant* value to be converted.",
            "+ `return`: *Long* - *Long* value derived from `Val`.",
            "",
            "### Remarks",
            "The result of the conversion depends on the data type of `Val`, as follows:",
            "+ **Boolean** -  The return value is 1 (*True*) or 0 (*False*).",
            "+ **Long** -  `Val` is returned unchanged.",
            "+ **Double** - The return value is `Val` rounded to the nearest whole number except when the decimal places are exactly 5. In these cases, it rounds to the even integer. This means that of the two possible rounded values, the one that has an even number as the last significant digit is returned. For example, 14.5 is rounded to 14 rather than 15.",
            "+ **Date** - The return value is the whole number part of the floating-point number used internally to represent the date. ",
            "+ **Text** - The string is parsed according to the locale to extract the value. An error occurs if the string does not contain a properly formatted integer. ",
            "+ **Categorical** - If the categorical value contains one category, the return value is the category value. Otherwise an error occurs.",
            "+ **Object** - If the object has a default property, the value of that property is converted. Otherwise an error occurs.",
            "+ **NULL** - If `Val` is *NULL*, the return value is 0.",
            "",
            "This function is similar to `CLng` in Visual Basic.",
            "",
            "### Examples",
            "",
            "| Data Type   | Value                     | Result |",
            "| :---------  | :-----------------------  | :----- |",
            "| Boolean     | False                     | 0  |",
            "| Long        | 345                       | 345  |",
            "| Double      | 567.8903                  | 568  |",
            "| Double      | 3.5                       | 4  |",
            "| Double      | -3.5                      | -4  |",
            "| Double      | 2.5                       | 2  |",
            "| Double      | -2.5                      | -2  |",
            "| Double      | 2.50000001                | 3  |",
            "| Double      | 2.49999999                | 2  |",
            "| Date        | 14 April 2001             | 36995  |",
            "| Text        | 100.56                    | 101  |",
            "| Categorical | {4,7}                     | Error  |",
            "| Categorical | {4}                       | 4  |",
            "",
        ].join("\n"),
    },
    {
        name: "CText",
        label: "CText(Val: Variant): String",
        insertText: "CText",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* value to be converted."
            }
        ],
        note: [
            "```ds",
            "(function) CText(Val: Variant): String",
            "```",
            "-----------------------------------",
            "Converts a value of any data type to a *Text* value.",
            "+ `Val`: *Variant* - *Variant* value to be converted.",
            "+ `return`: *Text* - *Text* value derived from `Val`.",
            "",
            "### Remarks",
            "The result of the conversion depends on the data type of `Val`, as follows:",
            "+ **Boolean** - The return value is \"True\" or \"False\" or their locale equivalents.",
            "+ **Long or Double** - The string contains the number formatted according to the locale.",
            "+ **Date** - The string contains the date formatted according to the locale. ",
            "+ **Text** - `Val` is returned unchanged. ",
            "+ **Categorical** - The string is of the form \"{1,2,0}\", where the numbers are the values of the categories in `Val` (formatted using digits only, ignoring the locale).",
            "+ **Object** - If the object has a default property, the value of that property is converted. Otherwise an error occurs.",
            "+ **NULL** - If `Val` is *NULL*, the return value is an empty string (\"\").",
            "",
            "This function is similar to `CStr` in Visual Basic.",
            "",
            "### Examples",
            "",
            "| Data Type   | Value                     | Result |",
            "| :---------  | :-----------------------  | :----- |",
            "| Categorical | {4,7}                     | {4,7}  |",
            "| Boolean     | 6                         | True  |",
            "| Long        | 345                       | 345  |",
            "| Double      | 6004.67                   | 6004.67  |",
            "| Date        | 14 April 2001             | 14/04/2001  |",
            "",
        ].join("\n"),
    },
    {
        name: "AscW",
        label: "AscW(Val: String): Long",
        insertText: "AscW",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.string,
                note: "*Text* value."
            }
        ],
        note: [
            "```ds",
            "(function) AscW(Val: String): Long",
            "```",
            "-----------------------------------",
            "Returns an integer value representing the Unicode character code (sometimes called the code point) for a character",
            "+ `Val`: *String* - *Text* value.",
            "+ `return`: *Long* - Unicode character code for first character of `Val`.",
            "",
            "### Remarks",
            "A Unicode character code is an integer from 0 to 65535.",
            "This function returns 0 if `Val` is empty. If the current data value is *NULL*, `Val` is an empty string and 0 is returned.",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "",
            "### Examples",
            "This mrScriptBasic example uses the `AscW` function to return the character code for a single character:",
            "```ds",
            "AscW(\"a\")",
            "```",
            "The return value is 97.",
            "The next example shows an SQL query that uses the AscW function to return the character code for the first character of the *name* variable (which stores the respondent's name).",
            "```sql",
            "SELECT AscW(name) FROM vdata",
            "```",
        ].join("\n"),
    },
    {
        name: "ChrW",
        label: "ChrW(Val: Long): String",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        insertText: "ChrW",
        note: [
            "```ds",
            "(function) ChrW(Val: Long): String",
            "```",
            "-----------------------------------",
            "Returns the character that corresponds to a Unicode character code (sometimes called the code point).",
            "+ `Val`: *Long* - Unicode character code for a character.",
            "+ `return`: *String* - Character corresponding to `Val`.",
            "",
            "### Remarks",
            "Valid Unicode character codes are integers from 0 to 65535. An error occurs if Val is less than 0 or greater than 65535.",
            "If the current data value is *NULL*, `Val` is 0 and the return value is a string containing a single null character. `ChrW` cannot distinguish between a 0 received for a *NULL* value and an actual 0 passed in.",
            "All values in the range 0-65535 are treated as valid Unicode characters, even though some of these values are not currently assigned as Unicode characters. In addition some values correspond to non-printable characters. Note that the returned character will be displayed correctly only if the font you are using supports that character.",
            "",
            "### Examples",
            "This example uses the `ChrW` function to return the character for a specified character code:",
            "```ds",
            "ChrW(97)",
            "```",
            "The return value is \"a\".",
        ].join("\n"),
    },
    {
        name: "Format",
        label: "Format(Val: Variant, [Style: String], [Width: Long], [Locale: Long]): String",
        insertText: "Format",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "The value to be formatted."
            },
            {
                name: "Style",
                type: BasicTypeDefinitions.string,
                optional: true,
                note: "Optional. One or more formatting codes. Multiple codes must be separated by semicolons."
            },
            {
                name: "Width",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The minimum width of the formatted string."
            },
            {
                name: "Locale",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The output locale to use for regional variations in formatting. If `Locale` is omitted or is negative, the current output locale is used for formatting."
            }
        ],
        note: [
            "```ds",
            "(function) Format(Val: Variant, [Style: String], [Width: Long], [Locale: Long]): String",
            "```",
            "-----------------------------------",
            "Returns a string that is the result of formatting a value according to one or more specified styles.",
            "+ `Val`: *Variant* - The value to be formatted. ",
            "+ `Style`: *String* - Optional. One or more formatting codes. Multiple codes must be separated by semicolons. ",
            "+ `Width`: *Long* - Optional. The minimum width of the formatted string. ",
            "+ `Locale`: *Long* - Optional. The output locale to use for regional variations in formatting. If `Locale` is omitted or is negative, the current output locale is used for formatting. ",
            "+ `return`: *String* - `Val` formatted as a text string. ",
            "",
            "### Remarks",
            "`Val` is formatted according to `Style`, as described below. If `Width` is supplied and the formatted string is shorter than the absolute value of `Width`, the string is padded with space characters to make it up to (the absolute value of) `Width` characters. If `Width` is negative, spaces are added at the end of the string; otherwise, spaces are added at the start.",
            "An error occurs if Val is an array with more than one dimension. Locale, if specified, is used for regional variations in formatting, but not for error messages. Custom formatting is not currently supported.",
            "If the metadata to be used for formatting needs to provided by a separate variable from `Val`, use the `FormatValue` function.",
            "",
            "#### Style Code Syntax",
            "`Style` consists of one or more formatting codes. Multiple codes must be separated by semicolons. Each code is of the form C[p][=t], where:",
            "+ *C* is a letter specifying the type of formatting to do.",
            "+ *p* is an optional integer that modifies the formatting in some way, depending on *C*.",
            "+ *t* is an optional text argument whose meaning depends on *C*.",
            "",
            "If *C* is an unknown code, the formatting described under None in the table below is used (and no error occurs), using the values of p and t, if supplied. The argument p may not have a plus or minus sign, so it can only be a non-negative integer. If *p* or *t* is inappropriate for *C*, it is ignored (and no error occurs).",
            "",
            "#### Applying a Style",
            "Except for the Count style (s, described in the table below), if Val is an array or a categorical value, the result is a comma-separated list of the results of applying the given style code (or codes) to each item or element in turn (in this case, `Val` in the table below refers to each individual item or element, not the whole array). No attempt is made to differentiate the separator character from any occurrences of the same character in the individual formatted values. Note that this gives the same result for a categorical value as for an array of long values. Note also that, if an array contains values of different types, the style code (or codes) may be interpreted differently for different items. If `Width` is specified, it is applied to the whole list, not to individual items.",
            "Except for special cases described in the table below, the value is converted to the expected type, using the input locale where necessary to interpret strings. For an object, the value of the object’s default property is used (in this case, `Val` below refers to the retrieved value). If any error occurs in retrieving an object’s properties, or in converting a value to the expected type, the result for that value is “”, except where noted below.",
            "Where formatting is affected by locale settings, the system settings for the locale are used, ignoring any “user overrides” (changes made to regional settings by the user currently logged in to the server).",
            "Except for the Count style (s, described below), if `Val` is *NULL*, the result is an empty string (\"\").",
            "",
            "#### Applying Multiple Styles",
            "If `Style` consists of more than one formatting code, each code is applied in turn to Val as described in “Applying a Style” above. Because the result of applying the first code will always be a text value, subsequent codes should only be those that are relevant to text values, for example, LowerFirst, Count, or UpperAll (*l*, *s*, or *U*, described below).",
            "Any padding required by `Width` is done after all codes have been applied.",
            "",
            "#### Style Code Definitions",
            "+ **None** - ",
            "    - For an MDMLabeledObject, the same as for *Label* (*b*), using *t* if supplied.",
            "    - For any other object, the same as for *Value* (*v*), using *t* if supplied.",
            "    - For other types, the same as `CText(Val)`, ignoring *p* and *t*.",
            "+ **a**: *Name* - ",
            "    - For an MDMLabeledObject, the Name property. If an error occurs retrieving the name, the result is “”.",
            "    - For any other object, the result of applying the Name format to the object's default property value.",
            "    - For other types, the Name of the MDM Element whose value is `CLong(Val)`. If the MDM Element or its Name cannot be accessed, the Name of the MDM mapped category value whose value is `CLong(Val)`. If the MDM mapped category value does not exist, the result is the same as for *Decimal1* (*d*), using *p* if supplied.",
            "+ **A**: *NameFull* - Same as for *Name* (*a*), but using the FullName instead of the Name for an MDMLabeledObject or MDM Element.",
            "+ **b**: *Label* - ",
            "    - For an MDMLabeledObject, its Label. If an error occurs retrieving the label, the result is “”.",
            "    - For any other object, the result of applying the Label format to the object’s default property value.",
            "    - For other types, the Label of the MDM Element (in the current MDM object) whose value is `CLong(Val)`. If an error occurs retrieving the label, the result is the same as *Decimal1* (*d*), using *p* if supplied.",
            "    - Labels are retrieved using the current Context and Language in the metadata. If t is given, it’s the name of the LabelType to use. If t is omitted, or specifies a nonexistent *LabelType*, the current LabelType is used.",
            "+ **B**: *LabelFull* - Same as for *Label* (*b*), but using the FullLabel instead of the Label for an MDMLabeledObject or MDM Element. The FullLabel can only be retrieved for the MDM document’s current LabelType, so t is ignored.",
            "+ **c**: *Currency* - `Val` converted to double and formatted as a currency, using the currency symbol and format specified by the output locale. The number of decimal places is adjusted to p by rounding Val (away from zero, for borderline cases), or by adding zeros at the end. If `p = 0`, the result has no decimal separator and no fractional part. If *p* is omitted, the default for the output locale is used.",
            "+ **C**: *Currency-Code* - Same as for *Currency* (*c*), but using the three-character international monetary symbol specified by the output locale.",
            "+ **d**: *DateShort,Decimal1* - ",
            "    - For a date value, short date format specified by the output locale (ignoring time of day in `Val`).",
            "    - The string length is increased to *p*, if given, by inserting zeros before the first digit.",
            "+ **D**: *DateLong, Decimal2* - ",
            "    - For a date value, long date format specified by the output locale (ignoring time of day in `Val`).",
            "    - For other types, `Val` converted to long and formatted as follows:",
            "        - A minus sign (-) if `Val` < 0. Followed by...",
            "        - One or more decimal digits (0-9).",
            "    - For other types, same as for Decimal1 (*d*).",
            "+ **e**: *Scientific-Lower* - ",
            "    - `Val` converted to double and formatted as follows:",
            "        - A minus sign (-) if Val < 0. Followed by...",
            "        - One decimal digit (0-9). Followed by...",
            "        - A decimal point (.). Followed by...",
            "        - p decimal digits (0-9). Followed by...",
            "        - Lower-case e. Followed by...",
            "        - A plus or minus sign (+ or -). Followed by...",
            "        - Three decimal digits (0-9).",
            "    - The part before the *e* (the mantissa) is `Val` scaled by a power of 10 so that its absolute value is `>= 1.0` and `< 10.0`, unless `Val` is 0.0. The number of decimal places is adjusted by rounding the mantissa (away from zero, for borderline cases), or by adding zeros at the end. If *p* = 0, the mantissa has no decimal separator and no fractional part. If *p* is omitted, it has 6 decimal places.",
            "    - The part after the *e* (the exponent) is the power of 10 by which the mantissa must be multiplied to give `Val`. The exponent length is increased to 3 digits, if necessary, by adding zeros at the left. If `Val` is 0.0, the mantissa and exponent are both zero. If the absolute value of `Val` is `> 0.0` and `< 1.0`, the exponent is negative, otherwise it is positive.",
            "+ **E**: *Scientific-Upper* - Same as for ScientificLower (*e*), but with an upper-case E.",
            "+ **f,F**: *DateTime,FixedPoint* - ",
            "    - For a date value, long date and time formats specified by the output locale, separated by a space.",
            "    - For other types, `Val` converted to double and formatted as follows:",
            "        - A minus sign (-) if Val < 0. Followed by...",
            "        - One or more decimal digits (0-9). Followed by...",
            "        - *A* decimal separator (specified by the output locale). Followed by...",
            "        - *p* decimal digits.",
            "    - The number of decimal places is adjusted by rounding Val (away from zero, for borderline cases), or by adding zeros at the end. If *p* = 0, the result has no decimal separator and no fractional part. If *p* is omitted, the default for the output locale is used.",
            "+ **l**: *LowerFirst* - `CText(Val)`, with the first alphanumeric character converted to lower case (if it’s an upper-case letter) according to the rules for the output locale.",
            "+ **L**: *LowerAll* - `CText(Val)`, with all alphabetic characters converted to lower case according to the rules for the output locale.",
            "+ **n,N**: *Fixed-Grouped* - `Val` converted to double and formatted as for FixedPoint1 (*f*), but with digits before the decimal separator grouped according to the rules for the output locale.",
            "+ **p,P**: *Percent* - `Val` converted to double and multiplied by 100.0, formatted as for FixedPoint (f), followed by a percent sign (%).",
            "+ **s,S**: *Count* - ",
            "    - For an array or categorical value, the number of items/elements it contains.",
            "    - For text, the number of characters in the string.",
            "    - For NULL, 0.",
            "    - For other types, 1.",
            "    - For all types, the count is formatted as for *Decimal1* (*d*), using p if supplied.",
            "+ **t,T**: *Time* - `Val` converted to date and formatted according to the time format specified by the output locale (ignoring the date part of `Val`).",
            "+ **u**: *UpperFirst* - `CText(Val)`, with the first alphanumeric character converted to upper case (if it’s a lower-case letter) according to the rules for the output locale.",
            "+ **U**: *UpperAll* - `CText(Val)`, with all alphabetic characters converted to upper case according to the rules for the output locale.",
            "+ **v**: *Value* - For an object value, the value of a specified property, converted to text. If t is given, it’s the name of the property to use. If t is omitted, or the value of the specified property can’t be retrieved, the default property of the object is used, if it exists. If no suitable property is found, the result is “”. The first property that returns a value is used, even if the value it returns is “”.",
            "For other types, `Val` converted to long and formatted as for *Decimal1* (*d*), using *p* if supplied.",
            "+ **V**: *ValueNative* - ",
            "    - For an object value, the value of a specified property (same as for *Value* (*v*)).",
            "    - For other types, the native value (for the current DataSource in the metadata) of the MDM ElementInstance whose value is `CLong(Val)`, formatted as for *Decimal1* (*d*), using *p* if supplied. If the native value can’t be retrieved, the result is “”.",
            "+ **w**: *TitleFirst* - `CText(Val)`, with the first alphanumeric character converted to upper case, and the rest of the string converted to lower case according to the rules for the output locale.",
            "+ **W**: *TitleAll* - `CText(Val)`, with the first character of each word (any alphanumeric character that isn’t preceded by an alphanumeric character) converted to upper case, and the rest of the string converted to lower case according to the rules for the output locale.",
            "+ **x**: *HexLower* - ",
            "    - `Val` converted to long and formatted as one or more hexadecimal digits (0-9 and a-f).",
            "    - `Val` is treated as an unsigned value; this means that if `Val` < 0, the value formatted is equivalent to Val + Pow(2, 31). Thus the range of possible non-negative long values (0 to 2147483647) is formatted as “0” to “7fffffff”, and the range of negative values (-2147483648 to -1) is formatted as “80000000” to “ffffffff”. This is consistent with the hexadecimal syntax for expressing integers in mrScript, eg &H80000000 = -2147483648.",
            "    - The string length is increased to *p*, if given, by inserting zeros before the first digit.",
            "+ **X**: *HexUpper* - Same as for HexLower (*x*), but with upper-case A-F for the hexadecimal digits.",
            "",
            "### Examples",
            "#### 1. Using the Format function in mrScriptBasic",
            "Note: Many of the examples in the table below make use of the Household sample metadata document, household.mdd, that is installed with the DDL.",
            "",
            "| Function call                                             | Result             |",
            "| :---------                                                | :-----------------------  |",
            "| Format(CDate(\"2004-12-02 15:49:31\"), \"f\", , 1046)                   | \"quinta-feira, 2 de dezembro de 2004 15:49:31\"                                     |",
            "| Format(CDate(\"2004-12-02 15:49:31\"), \"f\", , 1052)                   | \"2004-12-02 3:49:31.MD \"                                                           |",
            "| Format(MDM.Fields[\"person.trip.purpose\"], \"a\")                      | \"purpose\"                                                                          |",
            "| Format(MDM.Fields[\"person.trip.purpose\"], \"A\")                      | \"person[..].trip[..].purpose\"                                                      |",
            "| Format(MDM.Fields[\"person.trip.purpose\"], \"b\")                      | \"Purpose of trip\"                                                                  |",
            "| Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"a\")  | \"Column\"                                                                           |",
            "| Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"A\")  | \"person[2].tvdays[{Channel_3}].Column\"                                             |",
            "| Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"b\")  | \"Number of days watched last week\"                                                 |",
            "| Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"B\")  | \"2,{Channel_3} : Number of days watched last week\"                                 |",
            "| Format(MDM.Fields[\"person.newspapers\"], \"v=EffectiveMaxValue\")      | \"12\"                                                                               |",
            "| Format(MDM.CategoryMap, \"v=Count\")                                    | \"125\"                                                                              |",
            "| Format(MDM.Variables[\"person[6].occupation\"], \"V=hascasedata\")      | \"True\"                                                                             |",
            "| Format(MDM, \"V=URL\")                                                  | \"[INSTALL_FOLDER]\\IBM\\SPSS\\DataCollection\\6\\DDL\\Data\\Data Collection File\\household.mdd\"    |",
            "| Format(MDM.URL, \"L\")                                                  | \"[INSTALL_FOLDER]\\ibm\\spss\\datacollection\\6\\ddl\\data\\data collection file\\household.mdd\"  |",
            "| Format(MDM.URL, \"U\")                                                  | \"[INSTALL_FOLDER]\\IBM\\SPSSDATACOLLECTION\\6\\DDL\\DATA\\DATA COLLECTION FILE\\HOUSEHOLD.MDD\" |",
            "| MDM.MDMVersion.Split(\".\").Format(\"d4\")                              | \"0002,0010,0000,1664\" |",
            "| Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"b;l\")| \"number of days watched last week\" |",
            "",
            "#### 2. Using the Format function in an SQL query",
            "This example shows the use of the `Format` function in an SQL query that can be run against the IBM® SPSS® Data Collection Data File version of the Household sample data set, *household.ddf*. The function is used to display the value of a decimal variable called Satisfaction as a fixed point decimal and as a percentage figure: ",
            "```sql",
            "SELECT DISTINCT",
            "    satisfaction,",
            "    satisfaction.Format('f2') AS FixedPoint,",
            "    Format(satisfaction / 10.0, 'p0') AS Percentage",
            "FROM hdata.person.trip",
            "```",
            "Here is the result set:",
            "",
            "| satisfaction     | FixedPoint | Percentage     |",
            "| :--------------- | :--------- | :---------     |",
            "| 8.5              | 8.50       | 85%    |",
            "| 9                | 9.00       | 90%    |",
            "| 7.75             | 7.75       | 78%    |",
            "| 8                | 8.00       | 80%    |",
            "| 7.5              | 7.50       | 75%    |",
            "| 9.5              | 9.50       | 95%    |",
            "| 10               | 10.00      | 100%   |",
            "| 5                | 5.00       | 50%    |",
            "| 8.30000019073486 | 8.30       | 83%    |",
            "| 7.90000009536743 | 7.90       | 79%    |",
            "| 8.19999980926514 | 8.20       | 82%    |",
            "| 6.30000019073486 | 6.30       | 63%    |",
            "| 5.5              | 5.50       | 55%    |",
            "",
            "This next example shows another SQL query that can be run against the Household sample data set, *household.ddf*. The Format function is used to display the value of a categorical variable called Country in five alternative formats:",
            "```sql",
            "SELECT DISTINCT",
            "    country, ",
            "    country.Format('v2') AS Value, ",
            "    country.Format('a') AS Name, ",
            "    country.Format('b') AS Label, ",
            "    country.Format('b;U') AS LabelUpperCase, ",
            "    country.Format('s4') AS [Count] ",
            "FROM hdata.person.trip",
            "```",
            "Here is the result set:",
            "",
            "| country         |  Value | Name          | Label         | LabelUpperCase | Count  |",
            "| :-------------- |  :----- | :------------ | :------------ | :------------ |  :----- |",
            "| {united_states} |  85    | United_States | United States | UNITED STATES  | 0001  |",
            "| {switzerland}   |  83    | Switzerland   | Switzerland   | SWITZERLAND    | 0001  |",
            "| {india}         |  68    | India         | India         | INDIA          | 0001  |",
            "| {portugal}      |  78    | Portugal      | Portugal      | PORTUGAL       | 0001  |",
            "| {holland}       |  67    | Holland       | Holland       | HOLLAND        | 0001  |",
            "| {morocco}       |  75    | Morocco       | Morocco       | MOROCCO        | 0001  |",
            "| {australia}     |  57    | Australia     | Australia     | AUSTRALIA      | 0001  |",
            "| {france,spain}  |  64,81 | France,Spain  | France,Spain  | FRANCE,SPAIN   | 0002  |",
            "| {china,japan}   |  61,71 | China,Japan   | China,Japan   | CHINA,JAPAN    | 0002  |",
            "| {germany}       |  65    | Germany       | Germany       | GERMANY        | 0001 |",
            "",
            "The first column shows the categorical variable without any formatting, the second column shows the categorical values, the third and fourth columns show the values of the Name and Label properties respectively, the fifth column shows the result of applying two style codes, and the sixth column shows the number of elements in the categorical variable.",
            "",
            "#### 3. Using the Format function in an interview script",
            "The next example shows the `Format` function being used in an interview script that will run in version 3.0 (or later) of IBM® SPSS® Data Collection Interviewer Server. The Format function is used to display the labels and formatted values of the categories selected in the LikeColors question:",
            "```ds",
            "Metadata(en-US, Question, label)",
            "    LikeColors \"Which colors do you like?\" categorical",
            "    {",
            "        red \"I like Red\",",
            "        blue \"I like Blue\",",
            "        green \"I like Green\",",
            "        yellow \"I like Yellow\",",
            "        pink \"I like Pink\",",
            "        purple \"I like Purple\",",
            "        orange \"I like Orange\"",
            "    };",
            "",
            "    LikeColorsResponse \"{InsertHere}\" info;",
            "End Metadata",
            "",
            "Routing(Web)",
            "    LikeColors.Ask()",
            "",
            "    Dim labels, values, str",
            "    labels = LikeColors.Format(\"b\")    ' labels of responses",
            "    labels = labels.Replace(\",\", mr.CrLf)",
            "    values = LikeColors.Format(\"d3\")   ' response values with leading zeroes",
            "    str = \"You chose these:\" + mr.CrLf + labels + mr.CrLf",
            "    str = str + \"Their numerical values are (\" + values + \").\"",
            "    ",
            "    LikeColorsResponse.Ask(str)",
            "End Routing",
            "```",
        ].join("\n"),
    },
    {
        name: "FormatValue",
        label: "FormatValue(ValFormat: Variant, Val: Variant, [Style: String], [Width: Long], [Locale: Long]): String",
        insertText: "FormatValue",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "ValFormat",
                type: BasicTypeDefinitions.variant,
                note: "A variable that provides the metadata to be used for formatting."
            },
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "The value to be formatted."
            },
            {
                name: "Style",
                type: BasicTypeDefinitions.string,
                optional: true,
                note: "Optional. One or more formatting codes. Multiple codes must be separated by semicolons."
            },
            {
                name: "Width",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The minimum width of the formatted string."
            },
            {
                name: "Locale",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The output locale to use for regional variations in formatting. If `Locale` is omitted or is negative, the current output locale is used for formatting."
            }
        ],
        note: [
            "```ds",
            "FormatValue(ValFormat: Variant, Val: Variant, [Style: String], [Width: Long], [Locale: Long]): String",
            "```",
            "-----------------------------------",
            "Returns a string that is the result of formatting a value according to one or more specified styles. The `FormatValue` function is identical to the `Format` function, except that the metadata to be used for formatting is provided by one variable, while the value to be formatted may come from elsewhere.",
            "+ `ValFormat`: *Variant* - A variable that provides the metadata to be used for formatting.",
            "+ `Val`: *Variant* - The value to be formatted.",
            "+ `Style`: *String* - Optional. One or more formatting codes. Multiple codes must be separated by semicolons.",
            "+ `Width`: *Long* - Optional. The minimum width of the formatted string.",
            "+ `Locale`: *Long* - Optional. The output locale to use for regional variations in formatting. If `Locale` is omitted or is negative, the current output locale is used for formatting.",
            "+ `return`: *String* - `Val` formatted as a text string.",
            "",
            "### Remarks",
            "`Val` is formatted according to Style, as described below. For those formatting codes that can use metadata information, such as Name, Label, and ValueNative (*a*, *b*, and *V*, described in the table below), `Val` is formatted using the metadata information provided by `ValFormat`. That is, `Val` is formatted as if it were the current value of the `ValFormat` variable.",
            "If `Width` is supplied and the formatted string is shorter than the absolute value of `Width`, the string is padded with space characters to make it up to (the absolute value of) `Width` characters. If `Width` is negative, spaces are added at the end of the string; otherwise, spaces are added at the start.",
            "",
            "#### Style Code Syntax",
            "`Style` consists of one or more formatting codes. Multiple codes must be separated by semicolons. Each code is of the form C[p][=t], where:",
            "- *C* is a letter specifying the type of formatting to do.",
            "- *p* is an optional integer that modifies the formatting in some way, depending on *C*.",
            "- *t* is an optional text argument whose meaning depends on *C*.",
            "",
            "If *C* is an unknown code, the formatting described under None in the table below is used (and no error occurs), using the values of *p* and *t*, if supplied. The argument *p* may not have a plus or minus sign, so it can only be a non-negative integer. If *p* or *t* is inappropriate for *C*, it is ignored (and no error occurs).",
            "",
            "#### Applying a Style",
            "Except for the Count style (s, described in the table below), if `Val` is an array or a categorical value, the result is a comma-separated list of the results of applying the given style code (or codes) to each item or element in turn (in this case, “Val” in the table below refers to each individual item or element, not the whole array). No attempt is made to differentiate the separator character from any occurrences of the same character in the individual formatted values. Note that this gives the same result for a categorical value as for an array of long values. Note also that, if an array contains values of different types, the style code (or codes) may be interpreted differently for different items. If Width is specified, it is applied to the whole list, not to individual items.",
            "Except for special cases described in the table below, the value is converted to the expected type, using the input locale where necessary to interpret strings. For an object, the value of the object’s default property is used (in this case, “Val” below refers to the retrieved value). If any error occurs in retrieving an object’s properties, or in converting a value to the expected type, the result for that value is “”, except where noted below.",
            "Where formatting is affected by locale settings, the system settings for the locale are used, ignoring any “user overrides” (changes made to regional settings by the user currently logged in to the server).",
            "Except for the *Count style* (*s*, described below), if Val is NULL, the result is an empty string (\"\").",
            "",
            "#### Applying Multiple Styles",
            "If `Style` consists of more than one formatting code, each code is applied in turn to Val as described in “Applying a Style” above. Because the result of applying the first code will always be a text value, subsequent codes should only be those that are relevant to text values, for example, *LowerFirst*, *Count*, or *UpperAll* (*l*, *s*, or *U*, described below).",
            "Any padding required by `Width` is done after all codes have been applied.",
            "",
            "#### Style Code Definitions",
            "+ **None** - ",
            "    - For an MDMLabeledObject, the same as for *Label* (*b*), using t if supplied.",
            "    - For any other object, the same as for *Value* (*v*), using t if supplied. ",
            "    - For other types, the same as `CText(Val)`, ignoring *p* and *t*.",
            "+ **a**: *Name* - ",
            "    - For an MDMLabeledObject, the *Name* property. If an error occurs retrieving the name, the result is “”.",
            "    - For any other object, the result of applying the *Name* format to the object's default property value.",
            "    - For other types, the Name of the MDM Element whose value is `CLong(Val)`. If the MDM Element or its *Name* cannot be accessed, the *Name* of the MDM mapped category value whose value is `CLong(Val)`. If the MDM mapped category value does not exist, the result is the same as for *Decimal1* (*d*), using *p* if supplied.",
            "+ **A**: *NameFull* - Same as for *Name* (*a*), but using the *FullName* instead of the *Name* for an MDMLabeledObject or MDM Element.",
            "+ **b**: *Label* - ",
            "    - For an MDMLabeledObject, its Label. If an error occurs retrieving the label, the result is “”.",
            "    - For any other object, the result of applying the *Label* format to the object’s default property value.",
            "    - For other types, the Label of the MDM Element (in the current MDM object) whose value is `CLong(Val)`. If an error occurs retrieving the label, the result is the same as *Decimal1* (*d*), using p if supplied.",
            "    - Labels are retrieved using the current *Context* and *Language* in the metadata. If t is given, it’s the name of the *LabelType* to use. If t is omitted, or specifies a nonexistent *LabelType*, the current *LabelType* is used.",
            "+ **B**: *LabelFull* - Same as for *Label* (*b*), but using the *FullLabel* instead of the *Label* for an MDMLabeledObject or MDM Element. The *FullLabel* can only be retrieved for the MDM document’s current LabelType, so *t* is ignored.",
            "+ **c**: *Currency* - `Val` converted to double and formatted as a currency, using the currency symbol and format specified by the output locale. The number of decimal places is adjusted to *p* by rounding Val (away from zero, for borderline cases), or by adding zeros at the end. If `p = 0`, the result has no decimal separator and no fractional part. If *p* is omitted, the default for the output locale is used.",
            "+ **C**: *Currency-Code* - Same as for *Currency* (*c*), but using the three-character international monetary symbol specified by the output locale.",
            "+ **d**: *DateShort,Decimal1* - ",
            "    - For a date value, short date format specified by the output locale (ignoring time of day in Val).",
            "    - For other types, `Val` converted to long and formatted as follows:",
            "        - A minus sign (-) if Val < 0. Followed by...",
            "        - One or more decimal digits (0-9).",
            "    - The string length is increased to *p*, if given, by inserting zeros before the first digit.",
            "+ **D**: *DateLong,Decimal2* - ",
            "    - For a *date* value, long date format specified by the output locale (ignoring time of day in `Val`).",
            "    - For other types, same as for *Decimal1* (*d*).",
            "+ **e**: *Scientific-Lower* - ",
            "    - `Val` converted to double and formatted as follows:",
            "        - A minus sign (-) if Val < 0. Followed by...",
            "        - One decimal digit (0-9). Followed by...",
            "        - A decimal point (.). Followed by...",
            "        - *p* decimal digits (0-9). Followed by...",
            "        - *Lower-case* *e*. Followed by...",
            "        - A plus or minus sign (+ or -). Followed by...",
            "        - Three decimal digits (0-9).",
            "    - The part before the *e* (the mantissa) is `Val` scaled by a power of 10 so that its absolute value is `>= 1.0` and `< 10.0`, unless Val is 0.0. The number of decimal places is adjusted by rounding the mantissa (away from zero, for borderline cases), or by adding zeros at the end. If `p = 0`, the mantissa has no decimal separator and no fractional part. If *p* is omitted, it has 6 decimal places.",
            "    - The part after the *e* (the exponent) is the power of 10 by which the mantissa must be multiplied to give `Val`. The exponent length is increased to 3 digits, if necessary, by adding zeros at the left. If `Val` is 0.0, the mantissa and exponent are both zero. If the absolute value of Val is `> 0.0` and `< 1.0`, the exponent is negative, otherwise it is positive.",
            "+ **E**: *Scientific-Upper* - Same as for *ScientificLower* (*e*), but with an *upper-case* *E*.",
            "+ **f**: *DateTime,FixedPoint* - ",
            "    - For a *date* value, long date and time formats specified by the output locale, separated by a space.",
            "    - For other types, `Val` converted to double and formatted as follows:",
            "        - A minus sign (-) if `Val < 0`. Followed by...",
            "        - One or more decimal digits (0-9). Followed by...",
            "        - A decimal separator (specified by the output locale). Followed by...",
            "        - *p* decimal digits.",
            "    - The number of decimal places is adjusted by rounding Val (away from zero, for borderline cases), or by adding zeros at the end. If `p = 0`, the result has no decimal separator and no fractional part. If *p* is omitted, the default for the output locale is used.",
            "+ **l**: *LowerFirst* - `CText(Val)`, with the first alphanumeric character converted to lower case (if it’s an upper-case letter) according to the rules for the output locale.",
            "+ **L**: *LowerAll* - `CText(Val)`, with all alphabetic characters converted to lower case according to the rules for the output locale.",
            "+ **n,N**: *Fixed-Grouped* - `Val` converted to double and formatted as for *FixedPoint1* (*f*), but with digits before the decimal separator grouped according to the rules for the output locale.",
            "+ **p,P**: *Percent* - `Val` converted to double and multiplied by 100.0, formatted as for *FixedPoint* (*f*), followed by a percent sign (%).",
            "+ **s,S**: *Count* - ",
            "    - For an *array* or *categorical* value, the number of items/elements it contains.",
            "    - For *text*, the number of characters in the string.",
            "    - For *NULL*, 0.",
            "    - For other types, 1.",
            "    - For all types, the count is formatted as for *Decimal1* (*d*), using p if supplied.",
            "+ **t,T**: *Time* - `Val` converted to date and formatted according to the time format specified by the output locale (ignoring the date part of `Val`).",
            "+ **u**: *UpperFirst* - `CText(Val)`, with the first alphanumeric character converted to upper case (if it’s a lower-case letter) according to the rules for the output locale.",
            "+ **U**: *UpperAll* - `CText(Val)`, with all alphabetic characters converted to upper case according to the rules for the output locale.",
            "+ **v**: *Value* - ",
            "    - For an object value, the value of a specified property, converted to text. If *t* is given, it’s the name of the property to use. If *t* is omitted, or the value of the specified property can’t be retrieved, the default property of the object is used, if it exists. If no suitable property is found, the result is “”. The first property that returns a value is used, even if the value it returns is “”.",
            "    - For other types, `Val` converted to long and formatted as for *Decimal1* (*d*), using *p* if supplied.",
            "+ **V**: *ValueNative* - ",
            "    - For an object value, the value of a specified property (same as for *Value* (*v*)).",
            "    - For other types, the native value (for the current DataSource in the metadata) of the MDM ElementInstance whose value is `CLong(Val)`, formatted as for *Decimal1* (*d*), using p if supplied. If the native value can’t be retrieved, the result is “”.",
            "+ **w**: *TitleFirst* - `CText(Val)`, with the first alphanumeric character converted to upper case, and the rest of the string converted to lower case according to the rules for the output locale.",
            "+ **W**: *TitleAll* - `CText(Val)`, with the first character of each word (any alphanumeric character that isn’t preceded by an alphanumeric character) converted to upper case, and the rest of the string converted to lower case according to the rules for the output locale.",
            "+ **x**: *HexLower* - ",
            "    - `Val` converted to long and formatted as one or more hexadecimal digits (0-9 and a-f).",
            "    - `Val` is treated as an unsigned value; this means that if `Val < 0`, the value formatted is equivalent to Val + Pow(2, 31). Thus the range of possible non-negative long values (0 to 2147483647) is formatted as “0” to “7fffffff”, and the range of negative values (-2147483648 to -1) is formatted as “80000000” to “ffffffff”. This is consistent with the hexadecimal syntax for expressing integers in mrScript, eg &H80000000 = -2147483648.",
            "    - The string length is increased to *p*, if given, by inserting zeros before the first digit.",
            "+ **X**: *HexUpper* - Same as for *HexLower* (*x*), but with upper-case A-F for the hexadecimal digits.",
            "",
            "### Examples",
            "#### 1. Using the FormatValue function in an SQL query",
            "This example shows the use of the FormatValue function in an SQL query that can be run against the Museum sample data set provided with the IBM® SPSS® Data Collection Developer Library (DDL). The query lists the categories in the museums variable, and for each category shows the total number of male and female respondents who selected that category:",
            "```sql",
            "SELECT FormatValue(museums, GROUPBY.COL[0], 'b') Museum,",
            "    SUM(gender = {male}) Male,",
            "    SUM(gender = {female}) Female",
            "FROM vdata GROUP BY museums ON DefinedCategories(museums)",
            "```",
            "In the above example, the `FormatValue` function is effectively used to display the label of each category in the set returned by `DefinedCategories(museums)`. Because the result of `DefinedCategories(museums)` is a set of category values with no connection to the metadata for the museums variable, it is not possible to use the Format function to return the label of each category in the set. Instead, the `FormatValue` function is used so that the museums variable can be specified as providing the metadata for the formatting of the category values returned by `DefinedCategories(museums)`.",
            "Here is the result set of running the example query:",
            "",
            "| Museum                            | Male | Female |",
            "| :-------------------------------- | :---- | :----- |",
            "| National Museum of Science        |  209 |    124 |",
            "| Museum of Design                  |   49 |     43 |",
            "| Institute of Textiles and Fashion |   31 |     16 |",
            "| Archeological Museum              |   18 |      8 |",
            "| National Art Gallery              |    7 |     12 |",
            "| Northern Gallery                  |   11 |     10 |",
            "| Other                             |   16 |     21 |",
            "| (null)                            |    0 |      0 |",
            "",
        ].join("\n"),
    },
    {
        name: "Hex",
        label: "Hex(Val: Long): String",
        insertText: "Hex",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.long,
                note: "Numeric value."
            }
        ],
        note: [
            "```ds",
            "(function) Hex(Val: Long): String",
            "```",
            "-----------------------------------",
            "Returns a string representing the hexadecimal value of a number.",
            "+ `Val`: *Long* - Numeric value.",
            "+ `return`: *String* - Hexadecimal representation of `Val`.",
            "",
            "### Remarks",
            "`Val` is treated as an unsigned number, so values of -2147483648 to -1 are represented as \"80000000\" to \"FFFFFFFF\" respectively. If the current data value is *NULL*, `Val` is 0 and the return value is \"0\".",
            "This function is similar to the Hex function in Visual Basic.",
            "",
            "### Examples",
            "This example uses the Hex function to return the hexadecimal value of 99:",
            "```ds",
            "Dim x, y",
            "",
            "x = 99",
            "y = Hex(x)",
            "```",
            "The return value is \"63\".",
        ].join("\n"),
    },
    {
        name: "LCase",
        label: "LCase(Val: String): String",
        insertText: "LCase",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.string,
                note: "*String* value to be converted to lower case."
            }
        ],
        note: [
            "```ds",
            "(function) LCase(Val: String): String",
            "```",
            "-----------------------------------",
            "Returns a string that has been converted to lower case.",
            "+ `Val`: *String* - *String* value to be converted to lower case.",
            "+ `return`: *String* - Lowercase copy of `Val`.",
            "",
            "### Remarks",
            "The input string is converted to lower case, according to the rules of the input locale.",
            "If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "",
            "### Examples",
            "This example uses the `LCase` function to return a copy of the contents of the address variable converted to lower case:",
            "```ds",
            "address.LCase()",
            "```",
        ].join("\n"),
    },
    {
        name: "LTrim",
        label: "LTrim(Val: String): String",
        insertText: "LTrim",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.string,
                note: "*String* value from which you want to remove leading spaces."
            }
        ],
        note: [
            "```ds",
            "(function) LTrim(Val: String): String",
            "```",
            "-----------------------------------",
            "Returns a copy of a string with any leading spaces removed.",
            "+ `Val`: *String* - *String* value from which you want to remove leading spaces. ",
            "+ `return`: *String* - Copy of `Val` with leading spaces removed.",
            "",
            "### Remarks",
            "`LTrim` removes white space (such as space and tab characters) that appears at the beginning of the input string. `LTrim` uses the rules of the input locale when interpreting white space. ",
            "If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "",
            "### Examples",
            "This example uses the `LTrim` function to return a copy of the contents of the address variable with any leading spaces removed:",
            "```ds",
            "address.LTrim()",
            "```",
        ].join("\n"),
    },
    {
        name: "MakeMDMName",
        label: "MakeMDMName(Val: String): String",
        insertText: "MakeMDMName",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.string,
                note: "*String* value to encode."
            }
        ],
        note: [
            "```ds",
            "(function) MakeMDMName(Val: String): String",
            "```",
            "-----------------------------------",
            "This function replaces characters in a text string that are not allowed in the name of an MDM object, to produce a valid name.",
            "+ `Val`: *String* - *String* value to encode.",
            "+ `return`: *String* - Copy of `Val` with changes to make it a valid name for an MDM object.",
            "",
            "### Remarks",
            "The following changes are made:",
            "+ Leading and trailing spaces are removed.",
            "+ *Null*, *blank*, or *empty* names are converted to \"No_name__\".",
            "+ Any occurrence of the character # is replaced by #23 (23 is the hexadecimal representation of the Unicode character code for #).",
            "+ Any character that is not allowed anywhere in an MDM name is replaced by # followed by its two-digit hexadecimal character code.",
            "+ If the resulting text starts with any character that is not allowed at the start of an MDM name, then the string _#00 is inserted at the start of the text.",
            "",
            "These conversions ensure that",
            "+ The resulting text is a valid MDM name.",
            "+ Different input strings always produce distinct output strings.",
            "+ It is possible to \"decode\" the resulting text to get the original (although no library function is provided to do this).",
        ].join("\n"),
    },
    {
        name: "MakeString",
        label: "MakeString([Vals: Variant ...]): String",
        insertText: "MakeString",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Vals",
                type: BasicTypeDefinitions.variant,
                ellipsis: true,
                optional: true,
                note: "A comma-delimited list of values to be concatenated together as a string."
            }
        ],
        note: [
            "```ds",
            "(function) MakeString([Vals: Variant ...]): String",
            "```",
            "-----------------------------------",
            "+ `Vals`: *Variant* - A comma-delimited list of values to be concatenated together as a string. ",
            "+ `return`: *String* - String that is the concatenation of the values specified in `Vals`.",
            "",
            "### Remarks",
            "The string arguments can be of any type--each value is coerced to a text value. If no arguments are specified, an empty string is returned. ",
            "",
            "### Examples",
            "This example shows using the MakeString function to create a text string:",
            "```ds",
            "Dim A, B",
            "B = CDate(\"25 January 2002 12:05\")",
            "A = MakeString(\"On \", B.DatePart(\"d\"), \"/\", B.DatePart(\"m\"))",
            "' A now contains \"On 25/1\"",
            "```",
        ].join("\n"),
    },
    {
        name: "Oct",
        label: "Oct(Val: Long): String",
        insertText: "Oct",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.long,
                note: "Numeric value."
            }
        ],
        note: [
            "```ds",
            "(function) Oct(Val: Long): String",
            "```",
            "-----------------------------------",
            "Returns a string representing the octal value of a number.",
            "+ `Val`: *Long* - Numeric value.",
            "+ `return`: *String* - Octal representation of `Val`.",
            "",
            "### Remarks",
            "`Val` is treated as an unsigned number, so values of -2147483648 to -1 are represented as \"20000000000\" to \"37777777777\" respectively. If the current data value is *NULL*, `Val` is 0 and the return value is \"0\".",
            "This function is similar to the `Oct` function in Visual Basic.",
            "",
            "### Examples",
            "This example uses the `Oct` function to return the octal value of 99:",
            "```ds",
            "Dim x, y",
            "",
            "x = 99",
            "y = Oct(x)",
            "```",
            "The return value is \"143\".",
        ].join("\n"),
    },
    {
        name: "RTrim",
        label: "RTrim(Val: String): String",
        insertText: "RTrim",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.string,
                note: "*String* value from which you want to remove trailing spaces."
            }
        ],
        note: [
            "```ds",
            "(function) RTrim(Val: String): String",
            "```",
            "-----------------------------------",
            "Returns a copy of a string with any trailing spaces removed.",
            "+ `Val`: *String* - *String* value from which you want to remove trailing spaces.",
            "+ `return`: *String* - Copy of `Val` with trailing spaces removed.",
            "",
            "### Remarks",
            "`RTrim` removes white space (such as space and tab characters) that appears at the end of the input string. RTrim uses the rules of the input locale when interpreting white space. ",
            "If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "",
            "### Examples",
            "This example uses the `RTrim` function to return a copy of the contents of the address variable with any trailing spaces removed:",
            "```ds",
            "address.RTrim()",
            "```",
        ].join("\n"),
    },
    {
        name: "Split",
        label: "Split(Val: String, [Delimiter: String], [Count: Long]): Categorical",
        insertText: "Split",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.string,
                note: "*String* value to split."
            },
            {
                name: "Delimiter",
                type: BasicTypeDefinitions.string,
                optional: true,
                defaultValue: "\" \"",
                note: "Optional. `Delimiter` between substrings. The default is a single space (\" \")."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The maximum number of substrings to return. If omitted or less than zero, all substrings are returned."
            }
        ],
        note: [
            "```ds",
            "(function) Split(Val: String, [Delimiter: String = \" \"], [Count: Long]): Categorical",
            "```",
            "-----------------------------------",
            "Returns an array that contains substrings.",
            "+ `Val`: *String* - *String* value to split.",
            "+ `Delimiter`: *String* - Optional. `Delimiter` between substrings. The default is a single space (\" \").",
            "+ `Count`: *Long* - Optional. The maximum number of substrings to return. If omitted or less than zero, all substrings are returned.",
            "+ `return`: *Categorical* - An *array* containing the substrings from `Val`.",
            "",
            "### Remarks",
            "This function is useful when you are parsing text strings that contain a number of substrings separated by a character such as a comma (,). For example, the lines of an address are often separated by a comma.",
            "If `Val` is an empty string, the return value is an empty array. Otherwise, if Delimiter is an empty string or is not found in `Val`, the return value is an array containing one item, a copy of `Val`. If the current data value is *NULL*, `Val` is an empty string and the return value is an empty array.",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or elsewhere, such as in mrScriptBasic or mrScriptMetadata, or when creating filters in IBM® SPSS® Data Collection Survey Tabulation or quotas in IBM® SPSS® Data Collection Interviewer Server. Enclose text strings in single quotation marks (' ') in SQL queries and enclose text strings in double quotation marks (\" \") everywhere else.",
            "",
            "@Note - The `Split` function returns a categorical value, making it impossible to assign elements of the returned array. It should also be noted that the result from the `Split` function is not a real categorical value, because the elements of a categorical must be of type *Long* (int - VT_I4), not text. The parser treats the value as a categorical, but an error is returned when attempting to pass the value into a function that expects a real categorical (ContainsAny for example).",
            "",
            "### Examples",
            "This mrScriptBasic example uses the `Split` function to return the first line and the first two lines of an address that is stored in a single variable with the lines separated by commas. It also shows an example of using the function using the default parameters:",
            "```ds",
            "Dim Address, FirstLine, FirstTwoLines, Defaults",
            "",
            "Address = \"363 Park Road, Ashford, Kent\"",
            "",
            "FirstLine = Address.Split(",", 1)      ' Returns {363 Park Road}",
            "FirstTwoLines = Address.Split(",", 2)  ' Returns {363 Park Road, Ashford}",
            "Defaults = Address.Split()             ' Returns {363,Park,Road,,Ashford,,Kent}",
            "```",
        ].join("\n"),
    },
    {
        name: "Replace",
        label: "Replace(Val: Variant, Key: Variant, Replacement: Variant, [Start: Long], [Count: Long], [IgnoreCase: Boolean]): Variant",
        insertText: "Replace",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "Variant value of type *Text* or *Categorical*."
            },
            {
                name: "Key",
                type: BasicTypeDefinitions.variant,
                note: "Variant value to look for in `Val`, of the same type as `Val`."
            },
            {
                name: "Replacement",
                type: BasicTypeDefinitions.variant,
                note: "Variant value with which to replace `Key`, of the same type as `Val`."
            },
            {
                name: "Start",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. Position in `Val` (starting from 0), from which to start searching for `Key`. If omitted or less than 0, searching starts at the start of `Val`."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. Maximum number of replacements to make. If omitted or less than 0, all possible replacements are made."
            },
            {
                name: "IgnoreCase",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                note: "Optional. Whether to do case-insensitive comparison for `Key`. The default is *False*."
            }
        ],
        note: [
            "```ds",
            "(function) Replace(Val: Variant, Key: Variant, Replacement: Variant, [Start: Long], [Count: Long], [IgnoreCase: Boolean]): Variant",
            "```",
            "-----------------------------------",
            "Replaces part of a text or categorical value with another value of the same type.",
            "+ `Val`: *Variant* - Variant value of type *Text* or *Categorical*.",
            "+ `Key`: *Variant* - Variant value to look for in `Val`, of the same type as `Val`.",
            "+ `Replacement`: *Variant* - Variant value with which to replace `Key`, of the same type as `Val`.",
            "+ `Start`: *Long* - Optional. Position in `Val` (starting from 0), from which to start searching for `Key`. If omitted or less than 0, searching starts at the start of `Val`.",
            "+ `Count`: *Long* - Optional. Maximum number of replacements to make. If omitted or less than 0, all possible replacements are made.",
            "+ `IgnoreCase`: *Boolean* - Optional. Whether to do case-insensitive comparison for `Key`. The default is *False*.",
            "+ `return`: *Variant* - Copy of `Val` with `Key` replaced with `Replacement`.",
            "",
            "### Remarks",
            "If `Val` is of type `Text`, `Key` and `Replacement` are converted to text values, unless they are already text values or *NULL*. If `Val` is of type *Categorical*, `Key` and `Replacement` are converted to categorical values, unless they are already categorical values or *NULL*. An error occurs if `Key` or `Replacement` cannot be converted to the required type.",
            "If `Val` is *NULL*, the return value is *NULL*. If `Key` is *NULL*, no replacements are made. If `Replacement` is *NULL*, occurrences of `Key` are removed instead of being replaced. If `Val` is of any other type, an error occurs.",
            "",
            "### Examples",
            "The following mrScriptBasic example shows the use of the `Replace` function to replace all the hyphens in a text variable with spaces.",
            "```ds",
            "strVal = strVal.Replace(\"-\", \" \")",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "Trim",
        label: "Trim(): String",
        insertText: "Trim",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        note: [
            "```ds",
            "(function) Trim(): String",
            "```",
            "-----------------------------------",
            "Returns a copy of a string with any leading and trailing spaces removed.",
            "+ `return`: *String* - Copy of `Val` with leading and trailing spaces removed.",
            "",
            "### Remarks",
            "`Trim` removes white space (such as space and tab characters) that appears at the beginning and end of the input string. `Trim` uses the rules of the input locale when interpreting white space.",
            "If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "",
            "### Examples",
            "This example uses the `Trim` function to return a copy of the contents of the address variable with any leading and trailing spaces removed:",
            "```ds",
            "address.Trim()",
            "```",
        ].join("\n"),
    },
    {
        name: "Trim",
        label: "Trim(Val: String): String",
        insertText: "Trim",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.string,
                note: "*String* value from which you want to remove leading and trailing spaces."
            }
        ],
        note: [
            "```ds",
            "(function) Trim(Val: String): String",
            "```",
            "-----------------------------------",
            "Returns a copy of a string with any leading and trailing spaces removed.",
            "+ `Val`: *String* - *String* value from which you want to remove leading and trailing spaces.",
            "+ `return`: *String* - Copy of `Val` with leading and trailing spaces removed.",
            "",
            "### Remarks",
            "`Trim` removes white space (such as space and tab characters) that appears at the beginning and end of the input string. `Trim` uses the rules of the input locale when interpreting white space.",
            "If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "",
            "### Examples",
            "This example uses the `Trim` function to return a copy of the contents of the address variable with any leading and trailing spaces removed:",
            "```ds",
            "address.Trim()",
            "```",
        ].join("\n"),
    },
    {
        name: "UCase",
        label: "UCase(Val: String): String",
        insertText: "UCase",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.string,
                note: "*String* value to be converted to upper case."
            }
        ],
        note: [
            "```ds",
            "(function) UCase(Val: String): String",
            "```",
            "-----------------------------------",
            "Returns a string that has been converted to upper case.",
            "+ `Val`: *String* - *String* value to be converted to upper case.",
            "+ `return`: *String* - Uppercase copy of `Val`.",
            "",
            "### Remarks",
            "The input string is converted to upper case, according to the rules of the input locale.",
            "If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "",
            "### Examples",
            "This example returns an uppercase copy of the contents of the *name* variable:",
            "```ds",
            "name.UCase()",
            "```",
            "The next example uses the `Trim` and `Mid` functions in addition to the `UCase` function. The example returns characters 5-10 of the name variable converted to upper case and with any leading or trailing spaces removed:",
            "```ds",
            "Trim(UCase(name.Mid(4, 5)))",
            "```",
        ].join("\n"),
    },
    {
        name: "DateAdd",
        label: "DateAdd(Val: Date, Interval: String, Count: Long): Date",
        insertText: "DateAdd",
        definitionType: "function",
        returnType: BasicTypeDefinitions.date,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.date,
                note: "The date and/or time to which you want to add the interval(s)."
            },
            {
                name: "Interval",
                type: BasicTypeDefinitions.string,
                note: "The type of interval to be added, as specified in the table below."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                note: "Specifies the number of intervals to add. Can be negative to give an earlier date."
            }
        ],
        note: [
            "```ds",
            "(function) DateAdd(Val: Date, Interval: String, Count: Long): Date",
            "```",
            "-----------------------------------",
            "Returns a date to which a specified time interval (year, quarter, month, day, week, hour, minute, or second) has been added. ",
            "+ `Val`: *Date* - The date and/or time to which you want to add the interval(s). ",
            "+ `Interval`: *String* - The type of interval to be added, as specified in the table below. ",
            "+ `Count`: *Long* - Specifies the number of intervals to add. Can be negative to give an earlier date. ",
            "+ `return`: *Date* - `Val` + (`Count` * `Interval`) ",
            "",
            "### Remarks",
            "The following table shows the valid values for Interval.",
            "",
            "| Value of Interval |  Description  |",
            "|  :--------------  |  :----------  |",
            "| \"yyyy\"          |  Year   |",
            "| \"q\"             |  Quarter   |",
            "| \"m\"             |  Month   |",
            "| \"d\"             |  Day   |",
            "| \"y\"             |  Day   |",
            "| \"w\"             |  Day   |",
            "| \"ww\"            |  Week   |",
            "| \"h\"             |  Hour   |",
            "| \"n\"             |  Minute   |",
            "| \"s\"             |  Second   |",
            "",
            "Note that if you are using the function in an SQL query, use single quotation marks (' ') instead of double quotation marks (\" \") when specifying the Interval parameter.",
            "When you add or subtract intervals of years, quarters, or months, when necessary the day is adjusted to fit the expected month. For example, when you add one month to 29 January 2003, the result is 28 February 2003.",
            "",
            "### Examples",
            "This example uses the DateAdd function to return the date and time three months from the date recorded in the *DataCollection.FinishTime*. For example, if the date and time in the variable is *20 May 2002 2:15:43 P.M.*, this example would return *20 August 2002 2:15:43 P.M.*",
            "```ds",
            "DateAdd(DataCollection.FinishTime, \"m\", 3)",
            "```",
        ].join("\n"),
    },
    {
        name: "DateDiff",
        label: "DateDiff(Val1: Date, Val2: Date, Interval: String): Long",
        insertText: "DateDiff",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val1",
                type: BasicTypeDefinitions.date,
                note: "First date value.",
            },
            {
                name: "Val2",
                type: BasicTypeDefinitions.date,
                note: "First date value."
            },
            {
                name: "Interval",
                type: BasicTypeDefinitions.string,
                note: "Type of interval in which the difference between the two dates is to be reported."
            }
        ],
        note: [
            "```ds",
            "(function) DateDiff(Val1: Date, Val2: Date, Interval: String): Long",
            "```",
            "-----------------------------------",
            "Returns the time interval between two dates.",
            "+ `Val1`: *Date* - First date value. ",
            "+ `Val2`: *Date* - Second date value. ",
            "+ `Interval`: *String* - Type of interval in which the difference between the two dates is to be reported.",
            "+ `return`: *Long* - Number of intervals by which `Val2` is later than `Val1`. ",
            "",
            "### Remarks",
            "The return value is negative if `Val2` is earlier than `Val1`. If the current data value is *NULL*, `Val1` is *30 December 1899, 00:00:00*.",
            "The following table shows the valid values for Interval. ",
            "",
            "| Value of Interval | Description |",
            "| :---------------- | :---------- |",
            "| \"yyyy\"            | Calendar years  |",
            "| \"q\"               | Calendar quarters  |",
            "| \"m\"               | Calendar months  |",
            "| \"d\"               | Day  |",
            "| \"y\"               | Day of year (same as \"d\")  |",
            "| \"w\"               | Week (seven-day periods)  |",
            "| \"ww\"              | Calendar weeks (using first-day-of-week setting from input locale)  |",
            "| \"h\"               | Hour  |",
            "| \"n\"               | Minute  |",
            "| \"s\"               | Second  |",
            "",
            "For the calendar intervals, the return value is the number of occurrences of the beginning of the type of interval from `Val1` up to and including `Val2`, but not including `Val1`. For example, from *31 December 2001* to *1 January 2002* is counted as one year, even though the dates are only one day apart. For the \"w\" interval, the return value is the number of occurrences of whichever day of the week `Val1` is, from `Val1` up to and including `Val2`, but not including `Val1`.",
            "",
            "### Examples",
            "This example shows the use of the `DateDiff` function in an SQL query that returns the average time taken, in seconds, to complete a survey:",
            "```sql",
            "SELECT",
            "    AVG(",
            "        DateDiff(DataCollection.StartTime,",
            "                 DataCollection.FinishTime,",
            "                 's')",
            "       ) AS Average",
            "FROM vdata",
            "WHERE DataCollection.Status = {completed}",
            "```",
            "If this query is run against the IBM® SPSS® Data Collection Data File version of the *Museum* sample data set, the result set is:",
            "",
            "| Average |",
            "| ------- |",
            "| 2171400 |",
            "",
        ].join("\n"),
    },
    {
        name: "DateNow",
        label: "DateNow([Val: Long | String], [IgnoreDaylightSaving: Boolean = False]): Date",
        insertText: "DateNow",
        definitionType: "function",
        returnType: BasicTypeDefinitions.date,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.long,
                    BasicTypeDefinitions.string,
                ],
                optional: true,
                note: "Optional. *Long* or *String* value specifying local time zone to use."
            },
            {
                name: "IgnoreDaylightSaving",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                defaultValue: false,
                note: "Optional. Whether to ignore adjustments for daylight-saving time. Default is *False*."
            }
        ],
        note: [
            "```ds",
            "(function) DateNow([Val: Long | String], [IgnoreDaylightSaving: Boolean = False]): Date",
            "```",
            "-----------------------------------",
            "Returns the current local date in a particular time zone.",
            "+ `Val`: *Long* | *String* - Optional. *Long* or *String* value specifying local time zone to use.",
            "+ `IgnoreDaylightSaving`: *Boolean* - Optional. Whether to ignore adjustments for daylight-saving time. Default is *False*.",
            "+ `return`: *Date* - The current local date in the time zone.",
            "",
            "### Remarks",
            "The return value is the current local date in the time zone, with the time of day set to *00:00:00*. If `Val` is a *Long* value, it is the index value of a time zone defined in the registry on the server, or -1 to specify UTC time. If `Val` is a *Text* value, it is the name of a time zone defined in the registry on the server, or \"UTC\" to specify UTC time. If `Val` is omitted, *NULL* or empty, the time zone associated with the program in which the function is called is used. By default, the program's time zone is the local time zone of the server, but this can be changed by calling `SetTimeZone`. If `Val` is any other type, an error occurs. If the time zone specified by `Val` cannot be found in the registry, an error occurs (thus this function can be used to determine whether a specific value represents a valid time zone).",
            "",
            "### Examples",
            "This example returns the current local date for the program's time zone:",
            "```ds",
            "DateNow()",
            "```",
        ].join("\n"),
    },
    {
        name: "DateOnly",
        label: "DateOnly(Val: Date): Date",
        insertText: "DateOnly",
        definitionType: "function",
        returnType: BasicTypeDefinitions.date,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.date,
                note: "*Date* value."
            }
        ],
        note: [
            "```ds",
            "(function) DateOnly(Val: Date): Date",
            "```",
            "-----------------------------------",
            "Returns the date from a date and time value. ",
            "+ `Val`: *Date* - *Date* value.",
            "+ `reture`: *Date* - The date from `Val` (year, month and day).",
            "",
            "### Remarks",
            "The return value is the same as `Val`, but with the time of day set to *00:00:00*.",
        ].join("\n"),
    },
    {
        name: "DatePart",
        label: "DatePart(Val: Date, Interval: String): Long",
        insertText: "DatePart",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.date,
                note: "The date of which you want to return a part.",
            },
            {
                name: "Interval",
                type: BasicTypeDefinitions.string,
                note: "Defines the part of the date that is to be returned, as specified in the table below.",
            }
        ],
        note: [
            "```ds",
            "(function) DatePart(Val: Date, Interval: String): Long",
            "```",
            "-----------------------------------",
            "Returns a specified part of a given date.",
            "+ `Val`: *Date* - The date of which you want to return a part.",
            "+ `Interval`: *String* - Defines the part of the date that is to be returned, as specified in the table below.",
            "+ `return`: *Long* - The specified part of the date, as specified in the table below.",
            "",
            "### Remarks",
            "The following table shows the valid values for `Interval`.",
            "",
            "| Value of Interval  |  Description  |",
            "| :----------------  |  :----------  |",
            "| \"yyyy\"           |  Year   |",
            "| \"q\"              |  Quarter (1 to 4)   |",
            "| \"m\"              |  Month (1 to 12)   |",
            "| \"d\"              |  Day of month (1 to 31)   |",
            "| \"y\"              |  Day of year (1 to 366)   |",
            "| \"w\"              |  Day of week (1 to 7, using the first day of week setting from the input locale)   |",
            "| \"ww\"             |  Week of year (1 to 53, using the first week of year setting from the input locale)   |",
            "| \"h\"              |  Hour (0 to 23)   |",
            "| \"n\"              |  Minute (0 to 59)   |",
            "| \"s\"              |  Second (0 to 59)   |",
            "",
            "Note that if you are using the function in an SQL query, use single quotation marks (' ') instead of double quotation marks (\" \") when specifying the `Interval` parameter.",
            "`Val` is interpreted according to the input locale. ",
            "In some locales, when you use the \"ww\" option to return the week of the year, the week number for the first days of January may be returned as 53 and for the last days of December it may be returned as 1. For example, if the locale defines the first day of the week as Monday and the first week of the year as the first full week, the week number is returned as 53 for the first few days in a year in which the first Monday falls on January 7.",
            "",
            "### Examples",
            "In this example the DatePart function is used to return the year from the current system date (which is in turn returned by the Now function). For example, on 20 May 2002, this example would return 2002.",
            "```ds",
            "DatePart(Now(), \"yyyy\")",
            "```",
        ].join("\n"),
    },
    {
        name: "Day",
        label: "Day(Val: Date): Long",
        insertText: "Day",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.date,
                note: "The date for which you want to return the day."
            }
        ],
        note: [
            "```ds",
            "(function) Day(Val: Date): Long",
            "```",
            "-----------------------------------",
            "Returns a whole number between 1 and 31, inclusive, representing the day of the month.",
            "+ `Val`: *Date* - The date for which you want to return the day. ",
            "+ `return`: *Long* - The day of the month (1 to 31). ",
            "",
            "### Remarks",
            "This is equivalent to `DatePart(\"d\", Val)`.",
            "",
            "### Examples",
            "This example uses the Day function to return the day of the month from the current date (which is in turn returned by the Now function). For example, on *20 May 2002*, this example would return 20. ",
            "```ds",
            "Day(Now())",
            "```",
            "The next example uses the Day function to return the day stored in the *DataCollection.FinishTime*. ",
            "```ds",
            "DataCollection.FinishTime.Day()",
            "```",
        ].join("\n"),
    },
    {
        name: "GetTimeZone",
        label: "GetTimeZone([Val: Long | String]): Long",
        insertText: "GetTimeZone",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.long,
                    BasicTypeDefinitions.string,
                ],
                optional: true,
                note: "Optional. *Long* or *Text* value specifying time zone to use."
            }
        ],
        note: [
            "```ds",
            "(function) GetTimeZone([Val: Long | String]): Long",
            "```",
            "-----------------------------------",
            "Returns the index value of a time zone defined in the registry on the server.",
            "+ `Val`: *Long* | *String* - Optional. *Long* or *Text* value specifying time zone to use.",
            "+ `return`: *Long* - Index of the local time zone.",
            "",
            "### Remarks",
            "If `Val` is a *Long* value, it is the index value of a time zone defined in the registry on the server. If `Val` is a *Text* value, it is the name of a time zone defined in the registry on the server. If `Val` is omitted, *NULL* or empty, the time zone associated with the program in which the function is called is used. By default, the program's time zone is the local time zone of the server, but this can be changed by calling SetTimeZone. If a time zone name is used, it is case-insensitive. The special values of -1 and \"UTC\" can be used for the time zone; these do not correspond to anything in the registry, but instead refer to UTC time, with no offset or daylight saving defined. If `Val` is any other type, an error occurs. If the time zone specified by `Val` cannot be found in the registry, an error occurs (thus this function can be used to determine whether a specific value represents a valid time zone).",
            "",
            "### Examples",
            "The following example returns the index value of the Central Standard Time time zone from the registry.",
            "```ds",
            "GetTimeZone(\"Central Standard Time\")",
            "```",
        ].join("\n"),
    },
    {
        name: "GetTimeZoneDaylightSaving",
        label: "GetTimeZoneDaylightSaving([Val: Long | String], [Time: Date]): Boolean",
        insertText: "GetTimeZoneDaylightSaving",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.long,
                    BasicTypeDefinitions.string,
                ],
                optional: true,
                note: "Optional. *Long* or *String* value specifying time zone to use.",
            },
            {
                name: "Time",
                type: BasicTypeDefinitions.date,
                optional: true,
                note: "Optional. Local date and time to use.",
            }
        ],
        note: [
            "```ds",
            "(function) GetTimeZoneDaylightSaving([Val: Long | String], [Time: Date]): Boolean",
            "```",
            "-----------------------------------",
            "Returns True if daylight saving is currently in effect at the specified time (or now) in the specified time zone (or the program's time zone).",
            "+ `Val`: *Long* | *String* - Optional. *Long* or *String* value specifying time zone to use. ",
            "+ `Time`: *Date* - Optional. Local date and time to use. ",
            "+ `return`: *Boolean* - Whether daylight-saving is in effect at the specified time in the specified time zone.",
            "",
            "### Remarks",
            "If `Val` is a *Long* value, it is the index value of a time zone defined in the registry on the server. If `Val` is a *Text* value, it is the name of a time zone defined in the registry on the server. If `Val` is omitted, *NULL* or empty, the time zone associated with the program in which the function is called is used. By default, the program's time zone is the local time zone of the server, but this can be changed by calling `SetTimeZone`. If a time zone name is used, it is case-insensitive. The special values of -1 and \"UTC\" can be used for the time zone; these do not correspond to anything in the registry, but instead refer to UTC time, with no offset or daylight saving defined. If `Val` is any other type, an error occurs. If the time zone specified by `Val` cannot be found in the registry, an error occurs. ",
            "If Time is omitted, or equal to *30 December 1899, 00:00:00* (the date internally represented by the numeric value 0), then the current local date and time for the time zone are used.",
            "",
            "@Note - For some time zones (for example, 275 \"West Pacific Standard Time\") this function always returns *False*, because the time zone does not use daylight saving.",
            "",
            "### Examples",
            "The following example returns True if daylight-saving is in effect for the current local date and time in the Central Standard Time time zone.",
            "```ds",
            "GetTimeZoneDaylightSaving(\"Central Standard Time\")",
            "```",
        ].join("\n"),
    },
    {
        name: "GetTimeZoneName",
        label: "GetTimeZoneName([Val: Long | String]): String",
        insertText: "GetTimeZoneName",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.long,
                    BasicTypeDefinitions.string,
                ],
                optional: true,
                note: "Optional. *Long* or *String* value specifying time zone to use."
            }
        ],
        note: [
            "```ds",
            "(function) GetTimeZoneName([Val: Long | String]): String",
            "```",
            "-----------------------------------",
            "Returns the name of the local time zone.",
            "+ `Val`: *Long* | *String* - Optional. *Long* or *String* value specifying time zone to use.",
            "+ `return`: *String* - Name of the local time zone.",
            "",
            "### Remarks",
            "If `Val` is a *Long* value, it is the index value of a time zone defined in the registry on the server. If `Val` is a *Text* value, it is the name of a time zone defined in the registry on the server. If `Val` is omitted, *NULL* or empty, the time zone associated with the program in which the function is called is used. By default, the program's time zone is the local time zone of the server, but this can be changed by calling `SetTimeZone`. If a time zone name is used, it is case-insensitive. The special values of -1 and \"UTC\" can be used for the time zone; these do not correspond to anything in the registry, but instead refer to UTC time, with no offset or daylight saving defined. If `Val` is any other type, an error occurs. If the time zone specified by `Val` cannot be found in the registry, an error occurs (thus this function can be used to determine whether a specific value represents a valid time zone).",
            "",
            "### Examples",
            "The following example returns the name of the time zone with index value 235 (Tokyo Standard Time) in the list of time zones defined in the registry.",
            "```ds",
            "GetTimeZoneName(235)",
            "```",
        ].join("\n"),
    },
    {
        name: "GetTimeZoneOffset",
        label: "GetTimeZoneOffset([Val: Long | String], [Time: Date], [IgnoreDaylightSaving: Boolean = False]): Long",
        insertText: "GetTimeZoneOffset",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.long,
                    BasicTypeDefinitions.string,
                ],
                optional: true,
                note: "Optional. *Long* or *String* value specifying time zone to use.",
            },
            {
                name: "Time",
                type: BasicTypeDefinitions.date,
                optional: true,
                note: "Optional. Local date and time to use."
            },
            {
                name: "IgnoreDaylightSaving",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                note: "Optional. Whether to ignore adjustments for daylight-saving time. Default is *False*."
            }
        ],
        note: [
            "```ds",
            "(function) GetTimeZoneOffset([Val: Long | String], [Time: Date], [IgnoreDaylightSaving: Boolean = False]): Long",
            "```",
            "-----------------------------------",
            "Returns the number of minutes to add to or subtract from UTC time to get the local time.",
            "+ `Val`: *Long* | *String* - Optional. *Long* or *String* value specifying time zone to use.",
            "+ `Time`: *Date* - Optional. Local date and time to use.",
            "+ `IgnoreDaylightSaving`: *Boolean* - Optional. Whether to ignore adjustments for daylight-saving time. Default is *False*.",
            "+ `return`: *Long* - Offset from UTC time in minutes.",
            "",
            "### Remarks",
            "If `Val` is a *Long* value, it is the index value of a time zone defined in the registry on the server. If `Val` is a *Text* value, it is the name of a time zone defined in the registry on the server. If `Val` is omitted, *NULL* or empty, the time zone associated with the program in which the function is called is used. By default, the program's time zone is the local time zone of the server, but this can be changed by calling `SetTimeZone`. If a time zone name is used, it is case-insensitive. The special values of -1 and \"UTC\" can be used for the time zone; these do not correspond to anything in the registry, but instead refer to UTC time, with no offset or daylight saving defined. If `Val` is any other type, an error occurs. If the time zone specified by `Val` cannot be found in the registry, an error occurs.",
            "If `Time` is omitted, or equal to *30 December 1899, 00:00:00* (the date internally represented by the numeric value 0), then the current local date and time for the time zone are used. ",
            "The return value is the number of minutes (possibly negative) to add to UTC time to get the local time. This includes an adjustment for daylight saving, if daylight saving is currently in effect in the time zone and `IgnoreDaylightSaving` is *false*.",
        ].join("\n"),
    },
    {
        name: "Hour",
        label: "Hour(Val: Date): Long",
        insertText: "Hour",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.date,
                note: "The date for which you want to return the hour of the day."
            }
        ],
        note: [
            "```ds",
            "(function) Hour(Val: Date): Long",
            "```",
            "-----------------------------------",
            "Returns a whole number between 0 and 23, inclusive, representing the hour of the day.",
            "+ `Val`: *Date* - The date for which you want to return the hour of the day. ",
            "+ `return`: *Long* - The hour of the day (0 to 23).",
            "",
            "### Remarks",
            "This is equivalent to `DatePart(\"h\", Val)`.",
            "",
            "### Examples",
            "This example uses the Hour function to return the hour of the current system date and time, which is returned using the `Now` function.",
            "```ds",
            "Hour(Now())",
            "```",
            "The next example uses the Hour function to return the hour stored in the *DataCollection.FinishTime*.",
            "```ds",
            "DataCollection.FinishTime.Hour()",
            "```",
        ].join("\n"),
    },
    {
        name: "LocalToUTCTime",
        label: "LocalToUTCTime(Val: Date, [Zone: Long | String], [IgnoreDaylightSaving: Boolean = False]): Date",
        insertText: "LocalToUTCTime",
        definitionType: "function",
        returnType: BasicTypeDefinitions.date,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.date,
                note: "Local date/time value."
            },
            {
                name: "Zone",
                type: [
                    BasicTypeDefinitions.long,
                    BasicTypeDefinitions.string,
                ],
                optional: true,
                note: "Optional. *Long* or *String* value specifying local time zone to use."
            },
            {
                name: "IgnoreDaylightSaving",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                defaultValue: false,
                note: "Optional. Whether to ignore adjustments for daylight-saving time. Default is *False*.",
            }
        ],
        note: [
            "```ds",
            "(function) LocalToUTCTime(Val: Date, [Zone: Long | String], [IgnoreDaylightSaving: Boolean = False]): Date",
            "```",
            "-----------------------------------",
            "Returns the UTC time that corresponds to a given local time.",
            "+ `Val`: *Date* - Local date/time value. ",
            "+ `Zone`: *Long* | *String* - Optional. *Long* or *String* value specifying local time zone to use. ",
            "+ `IgnoreDaylightSaving`: *Boolean* - Optional. Whether to ignore adjustments for daylight-saving time. Default is *False*.",
            "+ `return`: *Date* - The corresponding UTC date/time. ",
            "",
            "### Remarks",
            "If `Zone` is a *Long* value, it is the index value of a time zone defined in the registry on the server. If `Zone` is a *Text* value, it is the name of a time zone defined in the registry on the server. If `Zone` is omitted, *NULL* or empty, the time zone associated with the program in which the function is called is used. By default, the program's time zone is the local time zone of the server, but this can be changed by calling `SetTimeZone`. If a time zone name is used, it is case-insensitive. The special values of -1 and \"UTC\" can be used for the time zone; these do not correspond to anything in the registry, but instead refer to UTC time, with no offset or daylight saving defined. If `Zone` is any other type, an error occurs. If the time zone specified by `Zone` can’t be found in the registry, an error occurs. ",
            "Note that if the time zone uses daylight saving (and `IgnoreDaylightSaving` is *False*), there will be certain times of the year that do not correspond to a UTC time; for example, if local time jumps from 0200 to 0300 when daylight saving comes into effect, then there is no local 0215 on that day. In such cases, the supplied local time is taken to be what the local time would have been if daylight saving were not in effect (thus, in the previous example, 0215 would return the same result as 0315). Also, on days when daylight saving ends, certain times of the day occur more than once; for example, if at 0300 (with daylight saving on) the local time is reset to 0200, then 0215 occurs twice on that day. In such cases, the supplied local time is taken to be the first occurrence, when daylight saving was in effect.",
        ].join("\n"),
    },
    {
        name: "Minute",
        label: "Minute(Val: Date): Long",
        insertText: "Minute",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.date,
                note: "The date for which you want to return the minute."
            }
        ],
        note: [
            "```ds",
            "(function) Minute(Val: Date): Long",
            "```",
            "-----------------------------------",
            "Returns a whole number between 0 and 59, inclusive, representing the minute of the hour.",
            "+ `Val`: *Date* - The date for which you want to return the minute.",
            "+ `return`: *Long* - The minute of the hour (0 to 59).",
            "",
            "### Remarks",
            "This is equivalent to `DatePart(\"n\", Val)`.",
            "",
            "### Examples",
            "This example uses the Minute function to return the minute of the current system time, which is returned using the `TimeNow` function.",
            "```ds",
            "Minute(TimeNow())",
            "```",
        ].join("\n"),
    },
    {
        name: "Month",
        label: "Month(Val: Date): Long",
        insertText: "Month",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.date,
                note: "The date for which you want to return the month."
            }
        ],
        note: [
            "```ds",
            "(function) Month(Val: Date): Long",
            "```",
            "-----------------------------------",
            "Returns a whole number between 1 and 12, inclusive, representing the month of the year.",
            "+ `Val`: *Date* - The date for which you want to return the month.",
            "+ `return`: *Long* - The month of the year (1 to 12).",
            "",
            "### Remarks",
            "This is equivalent to `DatePart(\"m\", Val)`.",
            "",
            "### Examples",
            "This example uses the `Month` function to return the month from the current date (which is in turn returned by the `Now` function). For example, on *20 May 2002*, this example would return 5. ",
            "```ds",
            "Month(Now())",
            "```",
        ].join("\n"),
    },
    {
        name: "MonthName",
        label: "MonthName(Val: Long , [Abbreviate: Boolean = False], [Locale: Long]): String",
        insertText: "MonthName",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.long,
                note: "An integer between 1 and 13 representing the month, or a date."
            },
            {
                name: "Abbreviate",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                defaultValue: false,
                note: "Optional. Whether a short form of the month name isto be used. The default is *False*."
            },
            {
                name: "Locale",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The output locale to use for regional variations in month names. If `Locale` is omitted or negative, or does not match a known Locale ID (LCID), the current output locale is used."
            }
        ],
        note: [
            "```ds",
            "(function) MonthName(Val: Long , [Abbreviate: Boolean = False], [Locale: Long]): String",
            "```",
            "-----------------------------------",
            "Returns a string indicating the specified month.",
            "+ `Val`: *Long* - An integer between 1 and 13 representing the month, or a date. ",
            "+ `Abbreviate`: *Boolean* - Optional. Whether a short form of the month name isto be used. The default is *False*. ",
            "+ `Locale`: *Long* - Optional. The output locale to use for regional variations in month names. If `Locale` is omitted or negative, or does not match a known Locale ID (LCID), the current output locale is used. ",
            "+ `return`: *String* - The name of the month, as specified for the output locale.",
            "",
            "### Remarks",
            "For locales that do not have a 13th month (which is most locales), the return value is a zero-length string when `Val` is 13.",
            "If `Locale` is specified, it is not used for error messages.",
            "If `Val` is *NULL*, the return value is a zero-length string. Otherwise, an error occurs if `Val` is not in the range 1 to 13 or is not a valid date.",
            "",
            "### Examples",
            "This example returns the full name of the 12th month. In an English-speaking locale, this would typically be \"December\".",
            "```ds",
            "MonthName(12)",
            "```",
            "To return the abbreviated name of the 12th month, set `Abbreviate` to True. In an English-speaking locale, this would typically return \"Dec\".",
            "```ds",
            "MonthName(12, True)",
            "```",
            "To return the month name for a specific locale, set `Locale` to a Locale ID (LCID) number. In the following example, the Chinese (Traditional) name for the 6th month is returned.",
            "```ds",
            "MonthName(6, , 1028)",
            "```",
            "The next example uses the `MonthName` and `Now` functions to return the name of the current month:",
            "```ds",
            "MonthName(Now())",
            "```",
        ].join("\n"),
    },
    {
        name: "Now",
        label: "Now([Val: Long | String], [IgnoreDaylightSaving: Boolean = False]): Date",
        insertText: "Now",
        definitionType: "function",
        returnType: BasicTypeDefinitions.date,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.long,
                    BasicTypeDefinitions.string,
                ],
                optional: true,
                note: "Optional. *Long* or *String* value specifying local time zone to use.",
            },
            {
                name: "IgnoreDaylightSaving",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                defaultValue: false,
                note: "Optional. Whether to ignore adjustments for daylight-saving time. Default is *False*."
            }
        ],
        note: [
            "```ds",
            "(function) Now([Val: Long | String], [IgnoreDaylightSaving: Boolean = False]): Date",
            "```",
            "-----------------------------------",
            "Returns the current local date and time in a particular time zone.",
            "+ `Val`: *Long* | *String* - Optional. *Long* or *String* value specifying local time zone to use.",
            "+ `IgnoreDaylightSaving`: *Boolean* - Optional. Whether to ignore adjustments for daylight-saving time. Default is *False*.",
            "+ `return`: *Date* - The current local date and time in the time zone.",
            "",
            "### Remarks",
            "If `Val` is a *Long* value, it is the index value of a time zone defined in the registry on the server, or -1 to specify UTC time. If `Val` is a *Text* value, it is the name of a time zone defined in the registry on the server, or \"UTC\" to specify UTC time. If `Val` is omitted, *NULL* or empty, the time zone associated with the program in which the function is called is used. By default, the program's time zone is the local time zone of the server, but this can be changed by calling `SetTimeZone`. If `Val` is any other type, an error occurs. If the time zone specified by `Val` cannot be found in the registry, an error occurs (thus this function can be used to determine whether a specific value represents a valid time zone).",
            "",
            "### Examples",
            "This example returns the current local date and time for the program's time zone:",
            "```ds",
            "Now()",
            "```",
        ].join("\n"),
    },
    {
        name: "Second",
        label: "Second(Val: Date): Long",
        insertText: "Second",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.date,
                note: "The date for which you want to return the second."
            }
        ],
        note: [
            "```ds",
            "(function) Second(Val: Date): Long",
            "```",
            "-----------------------------------",
            "Returns a whole number between 0 and 59, inclusive, representing the second of the minute.",
            "+ `Val`: *Date* - The date for which you want to return the second.",
            "+ `return`: *Long* - The second of the minute (0 to 59).",
            "",
            "### Remarks",
            "This is equivalent to `DatePart(\"s\", Val)`.",
            "",
            "### Examples",
            "This example uses the Second function to return the second of the current system time, which is returned using the `TimeNow` function.",
            "```ds",
            "Second(TimeNow())",
            "```",
        ].join("\n"),
    },
    {
        name: "SetTimeZone",
        label: "SetTimeZone(Val: Long | String): Long",
        insertText: "SetTimeZone",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.long,
                    BasicTypeDefinitions.string,
                ],
                note: "*Long* or *String* value specifying time zone to use."
            }
        ],
        note: [
            "```ds",
            "SetTimeZone(Val: Long | String): Long",
            "```",
            "-----------------------------------",
            "Sets the time zone associated with a program.",
            "+ `Val`: *Long* | **String - *Long* or *String* value specifying time zone to use.",
            "+ `return`: *Long* - Index of the new time zone.",
            "",
            "### Remarks",
            "This function changes the time zone associated with the program in which the function is called, as specified by `Val`. By default, the program's time zone is the local time zone of the server. If `Val` is a *Long* value, it is the index value of a time zone defined in the registry on the server. If `Val` is a *Text* value, it is the name of a time zone defined in the registry on the server. If `Val` is *NULL* or empty, the time zone associated with the program is not changed. If a time zone name is used, it is case-insensitive. The special values of -1 and \"UTC\" can be used for the time zone; these do not correspond to anything in the registry, but instead refer to UTC time, with no offset or daylight saving defined. If `Val` is any other type, an error occurs. If the time zone specified by `Val` cannot be found in the registry, an error occurs.",
        ].join("\n"),
    },
    {
        name: "TimeNow",
        label: "TimeNow([Val: Long | String], [IgnoreDaylightSaving: Boolean = False]): Date",
        insertText: "TimeNow",
        definitionType: "function",
        returnType: BasicTypeDefinitions.date,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.long,
                    BasicTypeDefinitions.string,
                ],
                note: "Optional. *Long* or *String* value specifying local time zone to use."
            },
            {
                name: "IgnoreDaylightSaving",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                defaultValue: false,
                note: "Optional. Whether to ignore adjustments for daylight-saving time. Default is *False*."
            }
        ],
        note: [
            "```ds",
            "(function) TimeNow([Val: Long | String], [IgnoreDaylightSaving: Boolean = False]): Date",
            "```",
            "-----------------------------------",
            "Returns the current local time in a particular time zone.",
            "+ `Val`: *Long* | *String* - Optional. *Long* or *String* value specifying local time zone to use.",
            "+ `IgnoreDaylightSaving`: *Boolean* - Optional. Whether to ignore adjustments for daylight-saving time. Default is *False*.",
            "+ `return`: *Date* - The current local time in the time zone.",
            "",
            "### Remarks",
            "The return value is the current local time in the time zone, with the date set to *30 December 1899*. If `Val` is a *Long* value, it is the index value of a time zone defined in the registry on the server, or -1 to specify UTC time. If `Val` is a *Text* value, it is the name of a time zone defined in the registry on the server, or \"UTC\" to specify UTC time. If `Val` is omitted, *NULL* or empty, the time zone associated with the program in which the function is called is used. By default, the program's time zone is the local time zone of the server, but this can be changed by calling `SetTimeZone`. If `Val` is any other type, an error occurs. If the time zone specified by Val cannot be found in the registry, an error occurs (thus this function can be used to determine whether a specific value represents a valid time zone).",
            "",
            "### Examples",
            "This example returns the current local time for the program's time zone:",
            "```ds",
            "TimeNow()",
            "```",
        ].join("\n"),
    },
    {
        name: "TimeOnly",
        label: "TimeOnly(Val: Date): Date",
        insertText: "TimeOnly",
        definitionType: "function",
        returnType: BasicTypeDefinitions.date,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.date,
                note: "*Date* value."
            }
        ],
        note: [
            "```ds",
            "(function) TimeOnly(Val: Date): Date",
            "```",
            "-----------------------------------",
            "The return value is the same as `Val`, but with the date set to *30 December 1899*.",
            "+ `Val`: *Date* - *Date* value.",
            "+ `return`: *Date* - The time from `Val` (hours, minutes, and seconds).",
            "",
            "### Remarks",
            "The return value is the same as `Val`, but with the date set to *30 December 1899*.",
        ].join("\n"),
    },
    {
        name: "UTCToLocalTime",
        label: "UTCToLocalTime(Val: Date, [Zone: Long | String], [IgnoreDaylightSaving: Boolean = False]): Date",
        insertText: "UTCToLocalTime",
        definitionType: "function",
        returnType: BasicTypeDefinitions.date,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.date,
                note: "UTC date/time value."
            },
            {
                name: "Zone",
                type: [
                    BasicTypeDefinitions.long,
                    BasicTypeDefinitions.string,
                ],
                optional: true,
                note: "Optional. *Long* or *String* value specifying the local time zone to use."
            },
            {
                name: "IgnoreDaylightSaving",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                defaultValue: false,
                note: "Optional. Whether to ignore adjustments for daylight-saving time. Default is *False*.",
            }
        ],
        note: [
            "```ds",
            "(function) UTCToLocalTime(Val: Date, [Zone: Long | String], [IgnoreDaylightSaving: Boolean = False]): Date",
            "```",
            "-----------------------------------",
            "Returns the local time that corresponds to a given UTC time.",
            "+ `Val`: *Date* - UTC date/time value. ",
            "+ `Zone`: *Long* | *String* - Optional. *Long* or *String* value specifying the local time zone to use. ",
            "+ `IgnoreDaylightSaving`: *Boolean* - Optional. Whether to ignore adjustments for daylight-saving time. Default is *False*. ",
            "+ `return`: *Date* - The corresponding date/time in the local time zone.",
            "",
            "### Remarks",
            "If `Zone` is a *Long* value, it is the index value of a time zone defined in the registry on the server. If `Zone` is a *Text* value, it is the name of a time zone defined in the registry on the server. If `Zone` is omitted, *NULL* or empty, the time zone associated with the program in which the function is called is used. By default, the program's time zone is the local time zone of the server, but this can be changed by calling `SetTimeZone`. If a time zone name is used, it is case-insensitive. The special values of -1 and \"UTC\" can be used for the time zone; these do not correspond to anything in the registry, but instead refer to UTC time, with no offset or daylight saving defined. If `Zone` is any other type, an error occurs. If the time zone specified by Zone cannot be found in the registry, an error occurs.",
        ].join("\n"),
    },
    {
        name: "WeekdayName",
        label: "WeekdayName(Val: Long | Date, [Abbreviate: Boolean = False], [Locale: Long]): String",
        insertText: "WeekdayName",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.long,
                    BasicTypeDefinitions.date,
                ],
                note: "A integer between 1 and 7 representing the day of the week, or a date. The input locale defines which days are considered the first and last days of the week.",
            },
            {
                name: "Abbreviate",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                defaultValue: false,
                note: "Optional. Whether a short form of the day name is to be used. The default is *False*."
            },
            {
                name: "Locale",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The output locale to use for regional variations in day names. If Locale is omitted or negative, or does not match a known Locale ID (LCID), the current output locale is used."
            }
        ],
        note: [
            "```ds",
            "(function) WeekdayName(Val: Long | Date, [Abbreviate: Boolean = False], [Locale: Long]): String",
            "```",
            "-----------------------------------",
            "Returns a string indicating the specified day of the week.",
            "+ `Val`: *Long* | *Date* - A integer between 1 and 7 representing the day of the week, or a date. The input locale defines which days are considered the first and last days of the week. ",
            "+ `Abbreviate`: *Boolean* - Optional. Whether a short form of the day name is to be used. The default is *False*. ",
            "+ `Locale`: *Long* - Optional. The output locale to use for regional variations in day names. If Locale is omitted or negative, or does not match a known Locale ID (LCID), the current output locale is used. ",
            "+ `return`: *String* - The name of the day, as specified for the output locale. ",
            "",
            "### Remarks",
            "If `Locale` is specified, it is not used for error messages.",
            "If `Val` is *NULL*, the return value is a zero-length string. Otherwise, an error occurs if Val is not in the range 1 to 7 or is not a valid date.",
            "",
            "### Examples",
            "This example uses the WeekdayName function to return the full name of the third day of the week. If the first day of the week is defined as Sunday, this example would return \"Tuesday\".",
            "```ds",
            "WeekdayName(3)",
            "```",
            "To return the abbreviated weekday name, set `Abbreviate` to *True*. If the first day of the week is defined as Sunday, this example would return \"Tue\".",
            "```ds",
            "WeekdayName(3, True)",
            "```",
            "To return the day name for a specific locale, set `Locale` to a Locale ID (LCID) number. In the following example, the Arabic name for the 4th day is returned.",
            "```ds",
            "WeekdayName(4, , 1025)",
            "```",
            "The following example SQL query uses the `WeekdayName` function to return the name of the day on which interviews were completed: ",
            "```sql",
            "SELECT Respondent.Serial, ",
            "    DataCollection.FinishTime, ",
            "    WeekdayName(DataCollection.FinishTime) AS Day ",
            "FROM vdata ",
            "WHERE DataCollection.Status = {Completed}",
            "```",
            "Here are the results for the first five respondents:",
            "",
            "| Respondent.Serial | DataCollection.FinishTime | Day  |",
            "| :---------------- | :------------------------ | :----------  |",
            "| 6                 | 16/10/2002 13:57:03       | Wednesday  |",
            "| 7                 | 16/10/2002 18:23:12       | Wednesday  |",
            "| 8                 | 16/10/2002 22:23:47       | Wednesday  |",
            "| 9                 | 17/10/2002 02:24:05       | Thursday  |",
            "| 10                | 17/10/2002 06:24:00       | Thursday  |",
            "",
        ].join("\n"),
    },
    {
        name: "Year",
        label: "Year(Val: Date): Long",
        insertText: "Year",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.date,
                note: "The date for which you want to return the year."
            }
        ],
        note: [
            "```ds",
            "(function) Year(Val: Date): Long",
            "```",
            "-----------------------------------",
            "Returns a whole number representing the year.",
            "+ `Val`: *Date* - The date for which you want to return the year.",
            "+ `return`: *Long* - The Year.",
            "",
            "### Remarks",
            "This is equivalent to `DatePart(\"yyyy\", Val)`.",
            "",
            "### Examples",
            "This example uses the Year function to return the year from the date recorded in the *DataCollection.FinishTime*. For example, if the date in the variable is *20 May 2002*, this example would return 2002.",
            "```ds",
            "Year(DataCollection.FinishTime)",
            "```",
        ].join("\n"),
    },
    {
        name: "GetRandomSeed",
        label: "GetRandomSeed(): Long",
        insertText: "GetRandomSeed",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        note: [
            "```ds",
            "(function) GetRandomSeed(): Long",
            "```",
            "-----------------------------------",
            "Returns a value representing the current starting point of the random number generator for the `Rnd`, `RanInt`, and `Ran` functions.",
            "+ `return`: *Long* - Current starting point for random number generation.",
            "",
            "### Remarks",
            "The current starting point for the random number generator is stored by the mrScriptBasic engine and Evaluate component and passed to the `Ran`, `RanInt`, and `Rnd` functions as hidden parameters.",
            "",
            "### Examples",
            "```ds",
            "Dim seed",
            "",
            "seed = GetRandomSeed()",
            "```",
        ].join("\n"),
    },
    {
        name: "RanInt",
        label: "RanInt([Seed: Long = 0]): Long",
        insertText: "RanInt",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Seed",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 0,
                note: "The starting point to be used for generating the random number. The default is 0."
            }
        ],
        note: [
            "```ds",
            "(function) RanInt([Seed: Long = 0]): Long",
            "```",
            "-----------------------------------",
            "This function returns a random integer number. The numbers generated by this function are not true random numbers because they can be reproduced. However, the numbers generated meet general statistical standards of randomness.",
            "+ `Seed`: *Long* - The starting point to be used for generating the random number. The default is 0.",
            "+ `return`: *Long* - Random value >= 0 and <= 2147483647.",
            "",
            "### Remarks",
            "The maximum possible value, 2147483647, is 2^31 – 1, because a *Long* value has 31 bits available (for non-negative numbers).",
            "If `Seed` is supplied, it is used to reset the starting point for the random number generator, as in `SetRandomSeed`, before the random number is generated. If Seed is not supplied or has a value of 0, the function will use the starting point stored for the random number generator by the mrScriptBasic engine or Evaluate component and passed as a hidden parameter. Each time you call one of the randomization functions, the starting point stored for the random number generator is updated. This means that if you call the function repeatedly without specifying the `Seed` parameter, the sequence of results is determined by the changing value passed as a hidden parameter. Specifying the `Seed` parameter is a way of resetting this sequence.",
            "",
            "### Examples",
            "This mrScriptBasic example uses the `RanInt` function to populate an array with random integers.",
            "```ds",
            "Dim i, random[10]",
            "",
            "For i = 0 To 9 ",
            "   random[i] = RanInt()",
            "Next",
            "```",
            "Here are the output values:",
            "",
            "| Value |",
            "| :------ |",
            "| 1045025264 |",
            "| 848909463 |",
            "| 43370521 |",
            "| 73429201 |",
            "| 1057695229 |",
            "| 19335566 |",
            "| 609059656 |",
            "| 695910923 |",
            "| 413457467 |",
            "| 28422312 |",
            "",
        ].join("\n"),
    },
    {
        name: "Rnd",
        label: "Rnd([Seed: Long = 0]): Double",
        insertText: "Rnd",
        definitionType: "function",
        returnType: BasicTypeDefinitions.double ,
        arguments: [
            {
                name: "Seed",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 0,
                note: "The starting point to be used for generating the random number. The default is 0."
            }
        ],
        note: [
            "```ds",
            "(function) Rnd([Seed: Long = 0]): Double",
            "```",
            "-----------------------------------",
            "This function returns a random decimal value. The numbers generated by this function are not true random numbers because they can be reproduced. However, the numbers generated meet general statistical standards of randomness.",
            "+ `Seed`: *Long* - The starting point to be used for generating the random number. The default is 0.",
            "+ `return`: *Double* - Random value >= 0 and < 1.0.",
            "",
            "### Remarks",
            "If `Seed` is supplied, it is used to reset the starting point for the random number generator, as in `SetRandomSeed`, before the random number is generated. If `Seed` is not supplied or has a value of 0, the function will use the starting point stored for the random number generator by the mrScriptBasic engine or Evaluate component and passed as a hidden parameter. Each time you call one of the randomization functions, the starting point stored for the random number generator is updated. This means that if you call the function repeatedly without specifying the `Seed` parameter, the sequence of results is determined by the changing value passed as a hidden parameter. Specifying the `Seed` parameter is a way of resetting this sequence.",
            "",
            "### Examples",
            "This mrScriptBasic example uses the `Rnd` function to populate an array with random decimal values.",
            "```ds",
            "Dim i, random[10]",
            "",
            "For i = 0 To 9 ",
            "   random[i] = Rnd()",
            "Next",
            "```",
            "Here are the output values:",
            "",
            "| Value |",
            "| :------ |",
            "| 0.9732556194067 |",
            "| 0.790608546696603 |",
            "| 4.03919452801347E-02 |",
            "| 6.83862725272775E-02 |",
            "| 0.985055443830788 |",
            "| 1.80076491087675E-02 |",
            "| 0.567231006920338 |",
            "| 0.648117552511394 |",
            "| 0.385062272660434 |",
            "| 2.64703407883644E-02 |",
            "",
        ].join("\n"),
    },
    {
        name: "SetRandomSeed",
        label: "SetRandomSeed([Seed: Long = 0]): Long",
        insertText: "SetRandomSeed",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Seed",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 0,
                note: "Optional. Starting value to use for random number generation. The default is 0."
            }
        ],
        note: [
            "```ds",
            "(function) SetRandomSeed([Seed: Long = 0]): Long",
            "```",
            "-----------------------------------",
            "+ `Seed`: *Long* - Optional. Starting value to use for random number generation. The default is 0. ",
            "+ `return`: *Long* - New starting value for random number generation.",
            "",
            "### Remarks",
            "`Seed` can be any *Long* value, positive, zero, or negative. If `Seed` is omitted, an unpredictable random value is returned. This function can therefore be used for generating true random numbers, unlike `RanInt` and `Rnd`, which return reproducible sequences of values. ",
            "",
            "### Examples",
            "This example SQL query shows using `SetRandomSeed` with and without the `Seed` parameter. ",
            "```ds",
            "SELECT Serial,",
            "    SetRandomSeed() AS Seed1, ",
            "    SetRandomSeed(3) AS Seed2 ",
            "FROM vdata",
            "```",
            "Here is the result set for the first five records. Note that each time you run this query, the results in the Seed1 column will be different because new random values are generated:",
            "",
            "| Serial | Seed1       | Seed2  |",
            "| :----- | :---------- | :----  |",
            "| 1      | -1272667498 | 3  |",
            "| 2      | 1402978284  | 3  |",
            "| 3      | -1930756257 | 3  |",
            "| 4      | -887407040  | 3  |",
            "| 5      | -456506117  | 3  |",
            "",
        ].join("\n"),
    },
    {
        name: "Band",
        label: "Band(Val: Long | Double, Min: Double, Size: Double, [Count: Long]): Categorical",
        insertText: "Band",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        note: [
            "```ds",
            "(function) Band(Val: Long | Double, Min: Double, Size: Double, [Count: Long]): Categorical",
            "```",
            "-----------------------------------",
            "Calculates categories (called bands) for a numeric variable and returns the appropriate category for a specified value in the numeric variable.",
            "+ `Val`: *Long* | *Double* - *Variant* value of type *Long* or *Double*.",
            "+ `Min`: *Double* - *Double* value specifying the (inclusive) lower boundary of the first band.",
            "+ `Size`: *Double* - *Double* value specifying the size of each band. If `Size <= 0.0`, an empty *categorical* value is returned.",
            "+ `Count`: *Long* - Optional. The number of bands to define. If omitted or < 0, the number of bands is unlimited.",
            "+ `return`: *Categorical* - *Categorical* value containing the number of the band into whichthe value falls, if it is in the specified range; an empty *categorical* value otherwise.",
            "",
            "### Remarks",
            "The first band is numbered 1.",
            "The numeric value is considered to fall into band N if",
            "```ds",
            "    Val < (Min + N * Size) and",
            "    Val >= (Min + (N - 1) * Size) and",
            "      N <= Count (if given)",
            "```",
            "If `Val` is *NULL*, the return value is an empty *Categorical* value ({}). ",
            "",
            "### Examples",
            "",
            "| Function call            | Val    | Result   |",
            "| :---------------------   | :----- | :-----  |",
            "| Band(Val, 1.0, 5.0, 10)  | 30     | {6}   |",
            "| Band(Val, 1.0, 5.0, 10)  | 300    | {}   |",
            "| Band(Val, 1.0, 5.0, 100) | 300    | {60}   |",
            "| Band(Val, 1.0, 50, 10)   | 300    | {6}   |",
            "",
            "The following example could be used to create a derived categorical case data variable from the *visits* numeric variable, which records the number of times respondents have previously visited the museum. This example would create categories corresponding to 1-5 visits, 6-10 visits, 11-15 visits, etc. ",
            "```ds",
            "visits.Band(1, 5)",
            "```",
        ].join("\n"),
    },
    {
        name: "BitAnd",
        label: "BitAnd(Val1: Long, [Vals: Variant ...]): Long",
        insertText: "BitAnd",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val1",
                type: BasicTypeDefinitions.long,
                note: "First data value."
            },
            {
                name: "Vals",
                type: BasicTypeDefinitions.variant,
                ellipsis: true,
                optional: true,
                note: "Variable number of other values."
            }
        ],
        note: [
            "```ds",
            "(function) BitAnd(Val1: Long, [Vals: Variant ...]): Long",
            "```",
            "-----------------------------------",
            "Performs a bitwise `AND` on two or more numeric values and returns the result.",
            "+ `Val1`: *Long* - First data value.",
            "+ `Vals`: *Variant* - Variable number of other values.",
            "+ `return`: *Long* - All values AND-ed together.",
            "",
            "### Remarks",
            "`Vals` is a list if variants, which are converted to *Long* before they are used. If one or more of them cannot be converted to a *Long* value, an error occurs.",
            "The return value is a number with only the bits set that are set in `Val1` and in all the other value arguments. If the current data value is *NULL*, `Val1` is 0 and the return value is 0. If no other arguments are supplied, the return value is `Val1`.",
            "This function is similar to using `And` as a bitwise operator in Visual Basic.",
            "",
            "### Examples",
            "`BitAnd` is useful for testing whether certain bits have been set. For example, some properties store a numeric value in which the bits are used to record true or false values that represent whether various flags have been set. A type definition is typically used to define the various flags. For example, the *Element.Flag* property in the MDM is used to record whether a category is one or more of various special category types, such as *Other Specify*, *Don't know*, or *Exclusive* (which means that the category is single-choice when it is used in a multiple response question). The values are defined in the *CategoryFlagConstants* type definition and because the *Flag* is used as a bit field, it can store more than one \"value\". ",
            "The following mrScriptBasic code snippet loops through a variable's categories and uses the `BitAnd` function to test each one to see whether it is defined as exclusive: ",
            "```ds",
            "Dim myCategory",
            "For each myCategory in Field.ElementInstances",
            "   If BitAnd(myCategory.Flag, CategoryFlagConstants.flExclusive) Then",
            "      ' This is an exclusive category...         ",
            "   End If",
            "Next",
            "```",
        ].join("\n"),
    },
    {
        name: "BitNot",
        label: "BitNot(Val: Long): Long",
        insertText: "BitNot",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.long,
                note: "*Data* value."
            }
        ],
        note: [
            "```ds",
            "(function) BitNot(Val: Long): Long",
            "```",
            "-----------------------------------",
            "Performs a bitwise `NOT` on a numeric value and returns the result.",
            "+ `Val`: *Long* - *Data* value.",
            "+ `return`: *Long* - Ones-complement of `Val`.",
            "",
            "### Remarks",
            "The return value is a number with only the bits set that are not set in `Val`. If the current data value is *NULL*, `Val` is 0 and the return value is -1.",
            "This function is similar to using `Not` as a bitwise operator in Visual Basic.",
            "",
            "### Examples",
            "`BitNot` enables you to refer to all of the bits in a bit pattern apart from one specific bit or group of bits. This is particularly useful when you want to clear certain bits without affecting the other bits. Like the other bit functions, `BitNot`, is useful when working with properties that store a numeric value in which the bits are used to record true or false values that represent whether various flags have been set. Typically a type definition is used to define the various flags. ",
            "For example, the *Element.Flag* property in the MDM is used to record whether a category is one or more of various special category types, such as *Other Specify*, *Don't know*, or *Exclusive* (which means that the category is single-choice when it is used in a multiple response question). The values are defined in the *CategoryFlagConstants* type definition and because the *Flag* is used as a bit field, it can store more than one \"value\". ",
            "This mrScriptBasic example uses `BitNot` in combination with BitAnd to get a category's flags, but without the bit pattern that corresponds to the *flExclusive* flag:",
            "```ds",
            "Dim ElemFlags",
            "",
            "ElemFlags = BitAnd(MDM.Fields[\"remember\"].Categories[\"Not_answered\"].Flag, _",
            "   BitNot(CategoryFlagConstants.flExclusive))",
            "```",
        ].join("\n"),
    },
    {
        name: "BitOr",
        label: "BitOr(Val1: Long, [Vals: Variant ...]): Long",
        insertText: "BitOr",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val1",
                type: BasicTypeDefinitions.long,
                note: "First data value.",
            },
            {
                name: "Vals",
                type: BasicTypeDefinitions.variant,
                ellipsis: true,
                optional: true,
                note: "Variable number of other values."
            }
        ],
        note: [
            "```ds",
            "(function) BitOr(Val1: Long, [Vals: Variant ...]): Long",
            "```",
            "-----------------------------------",
            "Performs a bitwise `OR` on two or more numeric values and returns the result.",
            "+ `Val1`: *Long* - First data value.",
            "+ `Vals`: *Variant* - Variable number of other values.",
            "+ `return`: *Long* - All values OR-ed together.",
            "",
            "### Remarks",
            "`Vals` is a list if variants, which are converted to *Long* before they are used. If one or more of them cannot be converted to a *Long* value, an error occurs.",
            "The return value is a number with only the bits set that are set in `Val1` or in at least one of the other value arguments. If the current data value is *NULL*, `Val1` is 0 and the return value is the combination of the other value arguments. If no other arguments are supplied, the return value is `Val1`.",
            "This function is similar to using `Or` as a bitwise operator in Visual Basic.",
            "",
            "### Examples",
            "`BitOr` is used to combine bit patterns and can be used to test more than one bit at the same time. Like the other bit functions, `BitOr`, is useful when working with properties that store a numeric value in which the bits are used to record true or false values that represent whether various flags have been set. Typically a type definition is used to define the various flags. ",
            "This mrScriptBasic example refers to the MDM *ObjectTypeValue* property, which is used to record an object's types. The values are defined in the *ObjectTypesConstants* type definition. The example uses `BitOr` in combination with `BitAnd` to test for two bit patterns that correspond to the *mtArray* and *mtGrid* constants in the *ObjectTypesConstants* type definition:",
            "```ds",
            "Dim MyObject",
            "",
            "For Each MyObject In MDM.Fields ",
            "   If BitAnd(MyObject.ObjectTypeValue, _",
            "         BitOr(ObjectTypesConstants.mtArray, ObjectTypesConstants.mtGrid)) Then",
            "      ' This is an an Array or Grid object ...         ",
            "   End If",
            "Next",
            "```",
            "This is equivalent to:",
            "```ds",
            "For Each MyObject In MDM.Fields ",
            "   If BitAnd(MyObject.ObjectTypeValue, ObjectTypesConstants.mtArray) OR _",
            "         BitAnd(MyObject.ObjectTypeValue, ObjectTypesConstants.mtGrid) Then",
            "      ' This is an an Array or Grid object ...         ",
            "   End If",
            "Next",
            "```",
            "`BitOr` is also useful for making sure that certain bits are set, without affecting the other bits. For example:",
            "```ds",
            "Dim ElemFlags",
            "",
            "ElemFlags = BitOr(MDM.Fields[\"remember\"].Categories[\"Not_answered\"].Flag, _",
            "   CategoryFlagConstants.flExclusive)",
            "```",
        ].join("\n"),
    },
    {
        name: "BitXor",
        label: "BitXor(Val1: Long, [Vals: Variant ...]): Long",
        insertText: "BitXor",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val1",
                type: BasicTypeDefinitions.long,
                note: "First data value.",
            },
            {
                name: "Vals",
                type: BasicTypeDefinitions.variant,
                ellipsis: true,
                optional: true,
                note: "Variable number of other values."
            }
        ],
        note: [
            "```ds",
            "(function) BitXor(Val1: Long, [Vals: Variant ...]): Long",
            "```",
            "-----------------------------------",
            "Performs a bitwise `XOR` (exclusive `OR`) on two or more numeric values and returns the result.",
            "+ `Val1`: *Long* - First data value.",
            "+ `Vals`: *None* - Variable number of other values.",
            "+ `return`: *Long* - All values exclusively OR-ed together.",
            "",
            "### Remarks",
            "`Vals` is a list of variants, which are converted to *Long* before being used. If one or more of them cannot be converted to a long value, an error occurs.",
            "The return value is a number with only the bits set that are set in an odd number of the input values `Val1` and the other value arguments. If the current data value is *NULL*, `Val1` is 0 and the return value is the combination of the other value arguments. If no other arguments are supplied, the return value is `Val1`. If only `Val1` and one other value are supplied, the bits set in the return value are those bits that are set in `Val1` or in the other value, but not in both.",
            "This function is similar to using `Xor` as a bitwise operator in Visual Basic.",
            "",
            "### Examples",
            "`BitXor` can be used for reversing certain bits in a bit pattern. Like the other bit functions, `BitXor`, is useful when working with properties that store a numeric value in which the bits are used to record true or false values that represent whether various flags have been set. Typically a type definition is used to define the various flags. However, be aware that switching bits on and off individually is not generally recommended when using the bit field properties in the IBM® SPSS® Data Collection object models. ",
            "This mrScriptBasic example clears the bit that represents the *vtFilter* usage type constant if it is set and sets it if it is not set:",
            "```ds",
            "MyVariable.UsageType = BitXor(MyVariable.UsageType, VariableUsageConstants.vtFilter)",
            "```",
        ].join("\n"),
    },
    {
        name: "Categorize",
        label: "Categorize(Val: Variant, CategorizedVariable: String): Categorical",
        insertText: "Categorize",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* value of type *Long*, *Double*, *Text*, or *Date*"
            },
            {
                name: "CategorizedVariable",
                type: BasicTypeDefinitions.string,
                note: "The name of the *categorical* variable, which will be used to ensure the generated category name exists."
            }
        ],
        note: [
            "```ds",
            "(function) Categorize(Val: Variant, CategorizedVariable: String): Categorical",
            "```",
            "-----------------------------------",
            "Converts the value of a *Numeric*, *Text*, or *Date* value to a *Categorical* value according to the definition of the specified categorical variable.",
            "",
            "@Note - The categories must be created before the `Categorize` function can be used. The function does not create categories.",
            "+ `Val`: *Long* | *Double* | *String* | *Date* - *Variant* value of type *Long*, *Double*, *Text*, or *Date*",
            "+ `CategorizedVariable`: *Text* - The name of the *categorical* variable, which will be used to ensure the generated category name exists.",
            "+ `return`: *Categorical* - The converted *Categorical* value related to `Val`. ",
            "",
            "### Remarks",
            "The conversion is based on the definition of the categorical variable named in the `CategorizedVariable` parameter. The conversion process starts by generating an MDM name from the value Val. The `MDMName` function is used for this process. When a generated category name does not exist in the specified categorical variable, the ‘Other’ category is returned (if it exists), otherwise the empty *categorical*,*{}*, is returned.",
            "If the value is *Null* or an empty string, ‘NA’ is returned (if it exists) on the specified variable, otherwise *NULL* is returned.",
            "",
            "### Examples",
            "```ds",
            "_Queue \"Sample queue\"",
            "    categorical [1..1]",
            "     {",
            "        FRESH \"Fresh\",",
            "        ACTIVE \"Active\",",
            "        TIMEDOUT \"Timed Out\",",
            "        NA \"No Answer\" na,",
            "        other \"Other\" other",
            "    };",
            "```",
            "The following result is returned:",
            "```ds",
            "Result = Categorize(Val, \"_Queue\")",
            "```",
            "",
            "| Val          | Result |",
            "| :-------     | :------ |",
            "| \"Active\"   | {ACTIVE}  |",
            "| \" \"        | {NA}  |",
            "| \"NoAnswer\" | {other}  |",
            "",
        ].join("\n"),
    },
    {
        name: "CategorizeLoopVariable",
        label: "CategorizeLoopVariable(Val: Variant, CategorizedVariable: String): Categorical",
        insertText: "CategorizeLoopVariable",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* value of type *Long*, *Double*, *Text*, or *Date*"
            },
            {
                name: "CategorizedVariable",
                type: BasicTypeDefinitions.string,
                note: "The name of the *categorical* loop variable, which will be used to ensure the generated category name exists and to check if *Other* and *NA* should be used."
            }
        ],
        note: [
            "```ds",
            "(function) CategorizeLoopVariable(Val: Variant, CategorizedVariable: String): Categorical",
            "```",
            "-----------------------------------",
            "Converts the value of a *Numeric*, *Text*, or *Date* value to a *Categorical* value according to the definition of the specified categorical loop variable.",
            "+ `Val`: *None* - *Variant* value of type *Long*, *Double*, *Text*, or *Date*",
            "+ `CategorizedVariable`: *String* - The name of the *categorical* loop variable, which will be used to ensure the generated category name exists and to check if *Other* and *NA* should be used.",
            "+ `return`: *Categorical* - The converted *Categorical* value related to `Val`. ",
            "",
            "### Remarks",
            "The function looks up in the parent level of the current level for the `CategorizedVariable` and checks to see if the parent supports `IArray` or the parent is the document level. If no parent level exists for the given `CategorizedVariable`, an error is returned. ",
            "The conversion is based on the definition of the *categorical* loop variable named in the `CategorizedVariable` parameter. The conversion process starts by generating an MDM name from the value `Val`. The `MDMName` function is used for this process.",
            "+ When a generated category name does not exist in the specified *categorical* loop variable, the ‘Other’ category is returned (if it exists), otherwise the empty *categorical*, *{}*, is returned.",
            "+ If the value is an empty string and ‘NA’ is not defined, an empty *categorical*, *{}*, is returned.",
            "+ If the value is *Null* and ‘NA’ is not defined, *NULL* is returned.",
            "",
            "### Examples",
            "```ds",
            "Model \"Model\"",
            "loop [1..3] fields -",
            "(",
            "    DBID \"DBID\"",
            "    text [1..20]",
            "    {",
            "        Audi1 \"Audi1\" factor(\"Audi1\"),",
            "        BMW1 \"BMW1\" factor(\"BMW1\"),",
            "        Ferrari1 \"Ferrari1\" factor(\"Ferrari1\")",
            "    };",
            "",
            ") column expand;",
            "```",
            "The following is the metadata script for the derived variable in the “Model” helper fields:",
            "```ds",
            "DBCodes \"q1 label\"",
            "categorical",
            "{",
            "    BMW1 \"BMW1\"",
            "        [",
            "            Value = 6",
            "        ]",
            "    fix keycode(\"Ctrl+1\") factor(\"BMW1\"),",
            "    other(\"Other\" \"Other\"",
            "        [",
            "            IsUserDefined = true,",
            "            IsForeverHidden = true",
            "        ]",
            "    text ) keycode(\"Ctrl+2\")",
            "} expression(\"SUM(Model.(CategorizeLoopVariable(DBID,\"\"Model.DBCodes\"\")))\", NoDeriveElements) usagetype(\"HelperField\");",
            "```",
            "The following result is returned:",
            "```ds",
            "Result = CategorizeLoopVariable(DBID, \"Model.DBCodes\")",
            "```",
            "",
            "| DBID    | Result (NA if defined) | Result (NA is not defined)   |",
            "| :------ | :--------------------  | :------------------------   |",
            "| \"BMW1\"  | {BMW1}                 | {BMW1}    |",
            "| \"Audi1\" | {other}                | {other}    |",
            "| \" \"     | {NA}                   | { }    |",
            "| NULL    | {NA}                   | NULL    |",
            "",
        ].join("\n"),
    },
    {
        name: "DBNull",
        label: "DBNull(): Variant",
        insertText: "DBNull",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        note: [
            "```ds",
            "(function) DBNull(): Variant",
            "```",
            "-----------------------------------",
            "Returns a *NULL* data value for use with ADO.",
            "+ `return`: *Variant* - *Variant* of type *VT_NULL*, containing a *NULL* data value.",
            "",
            "### Remarks",
            "ADO requires nulls to be variants of type VT_NULL. By default, mrScriptBasic uses type *VT_EMPTY* when setting nulls, and therefore this function must be used when setting nulls for use with ADO.",
            "",
            "### Examples",
            "The following mrScriptBasic example sets a variable to a *null* value that can be used with ADO:",
            "```ds",
            "Dim MyADOVariable",
            "",
            "MyADOVariable = DBNull()",
            "```",
        ].join("\n"),
    },
    {
        name: "CreateObject",
        label: "CreateObject(Class: String): Object",
        insertText: "CreateObject",
        definitionType: "function",
        returnType: BasicTypeDefinitions.object,
        arguments: [
            {
                name: "Class",
                type: BasicTypeDefinitions.string,
                note: "The COM class name of the object to be created."
            }
        ],
        note: [
            "```ds",
            "(function) CreateObject(Class: String): Object",
            "```",
            "-----------------------------------",
            "Creates and returns a reference to an Automation object.",
            "+ `Class`: *String* - The COM class name of the object to be created.",
            "+ `return`: *Object* - The created object.",
            "",
            "### Remarks",
            "If the object cannot be created, an error occurs.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the CreateObject function as follows:",
            "+ **Line 5** - The CreateObject function is used to create a IBM SPSS Data Collection OLE DB Provider DataLinkHelper object so that the *DisplayWizard* method can be used to display the Data Link Properties dialog box.",
            "+ **Line 12** - The CreateObject function is used to create an ADO Connection object, which is then used to open a connection to the data source and to return a recordset by executing a query against VDATA.",
            "+ **Line 17** - The CreateObject function is used to create a Word Application object, so that the recordset can be inserted into a Word document.",
            "",
            "```ds",
            "Dim Wizard, ConnectionString, wordApp, wordDoc",
            "",
            "' Use the Display wizard to open the Data Link Properties",
            "' dialog box to get the connection string",
            "Set Wizard = CreateObject(\"mrOleDB.DataLinkHelper\")                 ' Line 5",
            "ConnectionString = Wizard.DisplayWizard()",
            "",
            "If Len(ConnectionString) > 0 Then",
            "   ' Create a connection and use it to create a recordset ",
            "   ' by executing a query against VDATA",
            "   Dim adoConnection, adoRS",
            "   Set adoConnection = CreateObject(\"ADODB.Connection\")             ' Line 12",
            "   adoConnection.Open(ConnectionString)",
            "   Set adoRS = adoConnection.Execute(\"SELECT age, gender FROM VDATA WHERE Serial < 10\")",
            " ",
            "   ' Copy the recordset into Word",
            "   Set wordApp = CreateObject(\"Word.Application\")                   ' Line 17",
            "   wordApp.Visible = true",
            "   Set wordDoc = wordApp.Documents.Add()",
            "   wordDoc.ActiveWindow.Selection.Text = adoRS.GetString()",
            "End if",
            "```",
        ].join("\n"),
    },
    {
        name: "Decode",
        label: "Decode(Expression: Variant, Search: Variant, Result: Variant, [Search1: Variant, Result1: Variant]...[,defaultValue]): Void",
        insertText: "Decode",
        definitionType: "function",
        arguments: [
            {
                name: "Expression",
                type: BasicTypeDefinitions.variant,
                note: "The value to compare."
            },
            {
                name: "Search",
                type: BasicTypeDefinitions.variant,
                note: "The value that is compared against `Expression`."
            },
            {
                name: "Result",
                type: BasicTypeDefinitions.variant,
                note: "The returned value if `Expression` is equal to `Search`."
            },
            {
                name: "Search1",
                type: BasicTypeDefinitions.variant,
                ellipsis: true,
                optional: true,
                note: "The value that is compared against `Expression`."
            },
            {
                name: "Result1",
                type: BasicTypeDefinitions.variant,
                ellipsis: true,
                optional: true,
                note: "The returned value if `Expression` is equal to `Search`."
            },
            {
                name: "defaultValue",
                type: BasicTypeDefinitions.variant,
                optional: true,
                note: "Optional. If no matches are found, it returns the default. If the default is omitted, then the decode statement returns *null*."
            }
        ],
        note: [
            "```ds",
            "(function) Decode(Expression: Variant, Search: Variant, Result: Variant, [Search1: Variant, Result1: Variant]...[,defaultValue]): Void",
            "```",
            "-----------------------------------",
            "Provides the same functionality as an *IF-THEN-ELSE* statement (used for `OnNextCase` events).",
            "+ `Expression`: *Variant* - The value to compare.",
            "+ `Search`: *Variant* - The value that is compared against `Expression`.",
            "+ `Result`: *Variant* - The returned value if `Expression` is equal to `Search`.",
            "+ `defaultValue`: *Variant* - Optional. If no matches are found, it returns the default. If the default is omitted, then the decode statement returns *null*.",
            "@note - There are variable pairs for *Search* and *Result*.",
            "",
            "### Remarks",
            "The function searches `Expression` and returns the related `Result` if `Search` is found. Otherwise, the function returns defaultvalue. If defaultvalue is not set, the function returns *null*.",
            "There are restrictions when using this function:",
            "+ `Expression` can include the following types: *Long*, *Double*, *Text*, *Date*, *Categorical*, *Boolean*.",
            "+ `Expression` and Search should be the same data type; the function will issue an error if they are different.",
            "",
            "### Examples",
            "```ds",
            "Decode(Expression, \"USA\", \"America\", ",
            "		    \"UK\", \"UnitedKindom\", ",
            "		    \"OtherCountries\")",
            "```",
            "The following table shows the Expression and retrieved result values:",
            "",
            "| Expression | Result by Decode() |",
            "| :--------- | :----------------- |",
            "| “USA”	  | “America”          |",
            "| “UK”	      | “UnitedKindom”     |",
            "| “German”   | “OtherCountries”   |",
            "",
            "```ds",
            "Decode(Expression, 1, \"Red\", ",
            "		    2, \"Yellow\")",
            "```",
            "The following table shows the `Expression` and retrieved result values:",
            "",
            "| Expression | Result by Decode() |",
            "| :--------- | :----------------- |",
            "| 1	      | “Red”              |",
            "| 2          | “Yellow”           |",
            "| 3          | null               |",
            "",
        ].join("\n"),
    },
    {
        name: "EngineVersion",
        label: "EngineVersion([Val: Long = 0], [Number: Boolean = False]): Varaint",
        insertText: "EngineVersion",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 0,
                note: "Optional. Which parts of the version number to return, according to the list of options below. Treated as 0 if omitted or not a valid option."
            },
            {
                name: "Number",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                defaultValue: false,
                note: "Optional. If *True*, a number is returned. If Number is omitted or *False*, a string is returned."
            }
        ],
        note: [
            "```ds",
            "(function) EngineVersion([Val: Long = 0], [Number: Boolean = False]): Varaint",
            "```",
            "-----------------------------------",
            "Returns part or all of the engine's version number.",
            "+ `Val`: *Long* - Optional. Which parts of the version number to return, according to the list of options below. Treated as 0 if omitted or not a valid option.",
            "+ `Number`: *Boolean* - Optional. If *True*, a number is returned. If Number is omitted or *False*, a string is returned.",
            "+ `return`: *None* - Part or all of the engine's version number.",
            "",
            "### Remarks",
            "The possible values for `Val` are:",
            "",
            "| Value | Description |",
            "| :---- | :------------------ |",
            "| 0     | The whole version number as a string in the form \"major.minor.revision.build\". |",
            "| 1     | The Major version number. |",
            "| 2     | The Minor version number. |",
            "| 3     | The Revision number. |",
            "| 4     | The Build number. |",
            "| 5     | The Major and Minor version numbers as a string in the form \"major.minor\". |",
            "| 6     | The Major, Minor and Revision numbers as a string in the form \"major.minor.revision\". |",
            "",
            "If `Number` is *True*, a number is returned only when `Val` is set to 1, 2, 3 or 4. In all other cases, a string is returned. If the current data value is *NULL*, `Val` is 0.",
            "",
            "### Examples",
            "The following mrScriptBasic example sets a variable to the Major and Minor version numbers of the mrScriptBasic engine:",
            "```ds",
            "Dim MyVariable",
            "MyVariable = EngineVersion(5)    ' Returns 1.4 (for example)",
            "```",
        ].join("\n"),
    },
    {
        name: "EqualBand",
        label: "EqualBand(Val: Long | Double, Count: Long, Min: Double, Max: Double): Categorical",
        insertText: "EqualBand",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Val",
                type: [
                    BasicTypeDefinitions.long,
                    BasicTypeDefinitions.double,
                ],
                note: "Variant value of type *Long* or *Double*."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                note: "The number of bands to define between `Min` and `Max`. If `Count` < 1, an empty *categorical* value is returned."
            },
            {
                name: "Min",
                type: BasicTypeDefinitions.double,
                note: "*Double* value specifying the (inclusive) lower bound of the first band."
            },
            {
                name: "Max",
                type: BasicTypeDefinitions.double,
                note: "*Double* value specifying the (exclusive) upper bound of the last band."
            }
        ],
        note: [
            "```ds",
            "(function) EqualBand(Val: Long | Double, Count: Long, Min: Double, Max: Double): Categorical",
            "```",
            "-----------------------------------",
            "Calculates a specified number of equal categories (called bands) for a numeric variable and returns the appropriate category for a specified value in the numeric variable.",
            "+ `Val`: *Long* | *Double* - Variant value of type *Long* or *Double*.",
            "+ `Count`: *Long* - The number of bands to define between `Min` and `Max`. If `Count` < 1, an empty *categorical* value is returned.",
            "+ `Min`: *Double* - *Double* value specifying the (inclusive) lower bound of the first band.",
            "+ `Max`: *Double* - *Double* value specifying the (exclusive) upper bound of the last band.",
            "+ `return`: *Categorical* - *Categorical* value containing the number of the band into which the value falls, if it is in the specified range; an empty *categorical* value otherwise.",
            "",
            "### Remarks",
            "The first band is numbered 1.",
            "The numeric value is considered to fall into band N if",
            "```ds",
            "Val < Min + N * (Max - Min) / Count and",
            "Val >= Min + (N - 1) * (Max - Min) / Count ",
            "```",
            "If `Val` is *NULL*, the return value is an empty *Categorical* value ({}).",
            "",
            "### Examples",
            "",
            "| Function call               | Val   | Result |",
            "| :------------               | :---- | :----- |",
            "| EqualBand(Val, 30, 0, 400)  | 300   | {23}   |",
            "| EqualBand(Val, 10, 50, 400) | 300   | {8}    |",
            "",
            "The following example could be used to create a derived categorical case data variable from the *visits* numeric variable, which records the number of times respondents have previously visited the museum. This example would create ten categories. Respondents who have visited between 1 and 10 times would be in the first category, those who have visited between 11 and 20 times would be in the second category, etc.",
            "```ds",
            "visits.EqualBand(10, 1, 100)",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "Eval",
        label: "Eval(Expr: String): Variant",
        insertText: "Eval",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "Expr",
                type: BasicTypeDefinitions.string,
                note: "Expression to evaluate."
            }
        ],
        note: [
            "```ds",
            "(function) Eval(Expr: String): Variant",
            "```",
            "-----------------------------------",
            "Evaluates an expression and returns the result.",
            "+ `Expr`: *String* - Expression to evaluate.",
            "+ `return`: *Variant* - The result of evaluating the expression.",
            "",
            "### Remarks",
            "The input and output locales and the variables in use in the calling program are passed to this function and used to parse and evaluate the expression. When used in an SQL statement, the values of variables that aren't available in the calling program are taken to be *NULL*. However, this does not apply when you use the function in mrScriptBasic.",
            "The state of the calling program is shared with the new expression, so that any calls to other functions such as Rot and Ran have the same effect as they would if they were called directly by the calling program.",
            "The type of the return value depends on the type of the expression. If `Expr` is empty, the return value is *NULL*. In a scripting environment, the return value is the value of the first statement in the script.",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In IBM® SPSS® Data Collection Survey Tabulation, mrScriptBasic, and mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "This function is similar to the Eval function in VBScript.",
            "",
            "### Examples",
            "In mrScriptBasic, you can build up a text string and pass it to the Eval function as if the string were an actual expression. For example, in the following mrScriptBasic code, Eval returns 3:",
            "```ds",
            "Dim Total   ",
            "Total = Eval(\"1 + 2\")",
            "```",
            "If the text string passed to `Eval` contains the name of a function, `Eval` returns the return value of the function. For example, in the following code, `Eval` returns the current date and time returned by the `Now` function:",
            "```ds",
            "Dim Time",
            "Time = Eval(\"Now()\") ",
            "```",
            "The following example returns 97, which is the value returned by the `AscW` function for the \"a\" character:",
            "```ds",
            "Dim MyCheck   ",
            "MyCheck  = Eval(\"AscW(\"\"a\"\")\")",
            "```",
            "If the text string passed to `Eval` in a scripting environment contains more than one statement, Eval executes the statements from left to right but returns the result of the first statement only. For example, the following code includes the mr.CrLf mrScriptBasic constant, which inserts a carriage return/line feed character into a text string. When the code is executed, `Eval` tests whether the initial values of *x* and *y* have the same value and returns *True* or *False* accordingly, and then sets the value of *x* to 5.",
            "```ds",
            "Dim Test",
            "Test = Eval(\"x = y\" + mr.CrLf + \"x = 5\")",
            "```",
            "Notice that this result is different from executing the code outside of the `Eval` function in mrScriptBasic, where first *x* would be set to the value of *y* and then *x* would be set to 5:",
            "```ds",
            "x = y",
            "x = 5",
            "```",
            "This is because when `x = y` is the first statement passed to Eval, it is interpreted as an expression that tests whether *x* and *y* have the same value, whereas `x = y` is generally interpreted in mrScriptBasic as an assignment statement, where the value of *y* is assigned to *x*.",
            "Outside of the `Eval` function, the equivalent code would be:",
            "```ds",
            "If x = y Then",
            "End If",
            "x = 5",
            "```",
            "However, if you passed similar code to the `Eval` function you would get an error:",
            "```ds",
            "Test = Eval(\"If x = y Then\" + mr.CrLf + \"End If\" + mr.CrLf + \"x = 5\") ' Gives an error",
            "```",
            "You should therefore take care to make sure that the string passed to `Eval` is suitable.",
            "",
        ].join("\n"),
    },
    {
        name: "EvaluateDerivedIteration",
        label: "EvaluateDerivedIteration(LevelID: String): Variant",
        insertText: "EvaluateDerivedIteration",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "LevelID",
                type: BasicTypeDefinitions.string,
                note: "The variable that identifies the current iteration in the grid. This is typically the `LevelID` variable."
            }
        ],
        note: [
            "```ds",
            "(function) EvaluateDerivedIteration(LevelID: String): Variant",
            "```",
            "-----------------------------------",
            "Used by the derived grid feature to look up the value for the variable at the parent level with the same name as the supplied `LevelID` variable. The function takes the name of the `LevelID` and returns the value of that variable down-levelled into the grid level.",
            "+ `LevelID`: *String* - The variable that identifies the current iteration in the grid. This is typically the `LevelID` variable.",
            "+ `return`: *Variant* - The value of variable at the parent level that has the same name as the current iteration.",
            "",
            "### Remarks",
            "The `EvaluateDerivedIteration` function is used to obtain the value of the variable at the parent level that has the same name as the current iteration. The function is used when creating derived grids, where each iteration of the grid is a parent level variable.",
            "The function can be useful in the following situations:",
            "- You want to create grids from flat data, and you do not want end users to create these grids on their own.",
            "- You are scripting tables and want grids, but do not want to set them up in the user interface.",
            "When setting up derived grids, keep the following tips in mind:",
            "- The nested variable should have a source type of *sExpression*.",
            "- The category list of the nested variable should contain the union of the categories referenced by the parent level variables, and the *noDeriveElements* property should be set up.",
            "- The grid categories (iterators) must match the actual \"next level up\" question names. This ensures that the `LevelID` can be matched to a question name.",
            "- The *mlExpand* property must be set. You cannot use this function on an unbounded level; the iterator must be *categorical*.",
            "",
            "### Examples",
            "The following example creates a new derived grid variable that is based on three top level variables:",
            "```ds",
            "NEWGRID \"\" loop {",
            "	Rating_BrandA \"BrandA\",",
            "	Rating_BrandB \"BrandB\",",
            "	Rating_BrandC \"BrandC",
            "} fields",
            "(",
            "	Rating \"how do you rate this brand?\" categorical [1]",
            "	{ use \\ratingList -  } expression (\"EvaluateDerivedIteration(LevelID)\");",
            ") expand grid;",
            "```",
            "- The category names (category ID's) for the grid iterator match the question names of the top level questions they look up.",
            "- The expression `EvaluateDerivedIteration(LevelID)` is added to the Rating question inside the grid.",
            "",
        ].join("\n"),
    },
    {
        name: "Execute",
        label: "Execute(Script: String): Long",
        insertText: "Execute",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Script",
                type: BasicTypeDefinitions.string,
                note: "Statements to execute."
            }
        ],
        note: [
            "```ds",
            "(function) Execute(Script: String): Long",
            "```",
            "-----------------------------------",
            "Executes one or more specified statements.",
            "+ `Script`: *String* - Statements to execute.",
            "+ `return`: *Long* - Always zero.",
            "",
            "### Remarks",
            "`Script` is parsed (using the first available parser) and executed. This function can be used from scripts only and you will get an error if you attempt to use it in an expression that is executed by the IBM® SPSS® Data Collection Data Model.",
            "The input and output locales and the variables in use in the calling program are passed to this function and used when parsing and executing the script. The state of the calling program is shared with the new program, so that any calls to other functions such as Rot and Ran have the same effect as they would if they were called directly by the calling program.",
            "This function is similar to the Execute function in VBScript.",
            "",
            "### Examples",
            "In the following mrScriptBasic example, `Execute` assigns the value returned by the `DateNow` function to the *MyDate* variable.",
            "```ds",
            "Dim MyDate",
            "Execute(\"MyDate = DateNow()\")",
            "```",
        ].join("\n"),
    },
    {
        name: "GetInterface",
        label: "GetInterface(Object: Object, InterfaceID: String): Object",
        insertText: "GetInterface",
        definitionType: "function",
        returnType: BasicTypeDefinitions.object,
        arguments: [
            {
                name: "Object",
                type: BasicTypeDefinitions.object,
                note: "The object to query for the alternate interface."
            },
            {
                name: "InterfaceID",
                type: BasicTypeDefinitions.string,
                note: "The identifier of the interface as a string. This is a string representation of the `Interface ID` in the form {xxxxxx-...-xxxx}"
            }
        ],
        note: [
            "```ds",
            "(function) GetInterface(Object: Object, InterfaceID: String): Object",
            "```",
            "-----------------------------------",
            "Returns an alternate interface for an object.",
            "+ `Object`: *Object* - The object to query for the alternate interface.",
            "+ `InterfaceID`: *String* - The identifier of the interface as a string. This is a string representation of the `Interface ID` in the form {xxxxxx-...-xxxx}",
            "+ `return`: *Object* - The alternate interface for the object.",
            "",
            "### Remarks",
            "An error is returned if the object does not support the requested interface.",
            "The results may be unpredictable if the alternate interface does not derive from IDispatch.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the `GetInterface` function to return the *IArray* interface for an MDM Grid object:",
            "```ds",
            "Dim MyDocument, MyObject, MyCategory",
            "Set MyDocument = CreateObject(\"MDM.Document\")",
            "",
            "MyDocument.Open(\"C:\\Program Files\\IBM\\SPSS\\DataCollection\\6\\DDL\\Data\\MDD\\short_drinks.mdd\", , _",
            "    MDMLib.openConstants.oREAD)",
            "",
            "' Get the IArray interface for the Grid object named childhhz...",
            "",
            "Set MyObject = MyDocument.Fields[\"childhhz\"].GetInterface( _",
            "    \"{7A17758A-8D4F-4c5d-A9D8-D4CF574D9B14}\")",
            "",
            "' The Grid object can now be treated as an Array object. For",
            "' example, the IArray.Categories property can be used to",
            "' loop through all the categories of the Grid object...",
            "",
            "For Each MyCategory In MyObject.Categories",
            "    Debug.Log(MyCategory.Name)",
            "Next",
            "```",
            "Here is the output:",
            "```ds",
            "YEARS_0_5",
            "YEARS_6_10",
            "YEARS_11_15",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "IIf",
        label: "IIf(Val: Boolean, TruePart: Varaint, FalsePart: Variant): Variant",
        insertText: "IIf",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.boolean,
                note: "*Boolean* value."
            },
            {
                name: "TruePart",
                type: BasicTypeDefinitions.variant,
                note: "Value of any type, to be returned if `Val` is *True*."
            },
            {
                name: "FalsePart",
                type: BasicTypeDefinitions.variant,
                note: "Value of any type, to be returned if `Val` is *False*."
            }
        ],
        note: [
            "```ds",
            "(function) IIf(Val: Boolean, TruePart: Varaint, FalsePart: Variant): Variant",
            "```",
            "-----------------------------------",
            "Returns the value passed as the `TruePart` parameter if the expression evaluates to *True*, otherwise returns the value passed as the `FalsePart` parameter.",
            "+ `Val`: *Boolean* - *Boolean* value.",
            "+ `TruePart`: *Variant* - Value of any type, to be returned if `Val` is *True*.",
            "+ `FalsePart`: *Variant* - Value of any type, to be returned if `Val` is *False*.",
            "+ `return`: *Variant* - Either `TruePart` or `FalsePart`.",
            "",
            "### Remarks",
            "If `Val` is *True*, the function returns the value of `TruePart`. Otherwise, it returns the value of FalsePart.",
            "If the current data value is *NULL*, `Val` is *False* and the return value is `FalsePart`. `TruePart` or `FalsePart` (or both) may be *NULL*.",
            "",
            "### Examples",
            "This example uses IIf to test the value of the *visits* variable and return the text \"Frequent visitor\" if it has a value greater than 5 and a blank string otherwise:",
            "```ds",
            "IIf(visits > 5, \"Frequent visitor\", \"\")",
            "```",
            "The next example uses `IIf` in a data manipulation statement that is being used to clean \"dirty\" case data. The WHERE clause restricts the data manipulation to cases for which more than one response has been selected for a particular question. The `Rev` function is used to return {0} and {1} in alternating calls. Depending on the result, `SortAsc` and `SortDesc` are called alternately to return the first or last response in the list of responses. Note that the `AnswerCount` function is used to test whether more than one response was selected.",
            "```ds",
            "UPDATE vdata",
            "SET rating_ent[{Fossils}].Column = IIf(Rev({0,1}, 1, 2) = {0},",
            "    rating_ent[{Fossils}].Column.SortAsc(1),",
            "    rating_ent[{Fossils}].Column.SortDesc(1))",
            "WHERE rating_ent[{Fossils}].Column.AnswerCount() > 1",
            "```",
            "",
            "### Usage considerations",
            "The following behavior should be kept in mind when using the `IIF` function:",
            "Both `TruePart` and the `FalsePart` are evaluated, regardless of which one is actually returned. For example:",
            "```ds",
            "value = 10",
            "result = IIf(value = 10, TrueFunction, FalseFunction)",
            "```",
            "Although `TrueFunction` is the function intended to be called, IIf will cause both `TrueFunction` and `FalseFunction` to be run.",
            "```ds",
            "a = 10",
            "b = 0",
            "result = IIf(b <> 0, a / b, 0) ",
            "```",
            "While the above example intends to avoid raising an error by performing a division by zero, whenever b is zero, the error will actually happen. This is due to the fact that the code in the sample will be read as:",
            "```ds",
            "a = 10",
            "b = 0",
            "_temp1 = a / b ' Error if b = 0",
            "_temp2 = 0",
            "_temp3 = b <> 0",
            "result = IIf(_temp3, _temp1 , _temp2) ",
            "```",
            "This issue makes the `IIf()` call less useful than the conditional operator.",
            "",
        ].join("\n"),
    },
    {
        name: "InputBox",
        label: "InputBox(Prompt: String, [Default: String], [Title: String]): String",
        insertText: "InputBox",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Prompt",
                type: BasicTypeDefinitions.string,
                note: "Message to display in the dialog box.",
            },
            {
                name: "Default",
                type: BasicTypeDefinitions.string,
                optional: true,
                note: "Optional. Initial contents of the dialog box."
            },
            {
                name: "Title",
                type: BasicTypeDefinitions.string,
                optional: true,
                note: "Optional. *Text* to display in the title bar.",
            }
        ],
        note: [
            "```ds",
            "(function) InputBox(Prompt: String, [Default: String], [Title: String]): String",
            "```",
            "-----------------------------------",
            "Displays a dialog containing a specified message, a text box for input, an OK button, and a Cancel button.",
            "+ `Prompt`: *String* - Message to display in the dialog box.",
            "+ `Default`: *String* - Optional. Initial contents of the dialog box.",
            "+ `Title`: *String* - Optional. *Text* to display in the title bar.",
            "+ `return`: *String* - Final contents of the text box, or an empty string.",
            "",
            "### Remarks",
            "The user may change the contents of the text box. If the user clicks OK or presses the Enter key, the current contents of the text box are returned. If the user clicks Cancel or presses the Escape key, the return value is \"\". If `Default` is omitted, the text box is initially empty. If `Title` is omitted or is \"\", the dialog's title will be \"IBM® SPSS® Data Collection\".",
            "The dialog's height is adjusted (up to the height of the screen) to include as much as possible of the *Prompt* text. All text entered in the text box is returned. This is different from the Visual Basic InputBox, which displays only 1023 characters of the prompt, allows only 1023 characters of input, and returns only 254 of the input characters.",
            "The dialog is modal, meaning that the `InputBox` function does not return until the user closes it, for example, by clicking OK or Cancel. However, if the dialog is being called from a Windows application, the application is not suspended while the dialog is open.",
            "",
        ].join("\n"),
    },
    {
        name: "IsDBNull",
        label: "IsDBNull(Val: Variant): Boolean",
        insertText: "IsDBNull",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "The value to test."
            }
        ],
        note: [
            "```ds",
            "(function) IsDBNull(Val: Variant): Boolean",
            "```",
            "-----------------------------------",
            "Returns true if a value is a *NULL* data value that can be used by ADO.",
            "+ `Val`: *Variant* - The value to test.",
            "+ `return`: *Boolean* - *True* if `Val` is a *NULL* data value that can be used by ADO, *False* otherwise.",
            "",
            "### Remarks",
            "ADO requires nulls to be variants of type *VT_NULL*. By default, mrScriptBasic uses type *VT_EMPTY* when setting nulls, and therefore this function can be used to test if a *NULL* data value can be used by ADO.",
            "",
            "### Examples",
            "The following mrScriptBasic example tests a variable to see if its value is a *NULL* data value that can be used by ADO:",
            "```ds",
            "If MyVariable.IsDBNull() Then",
            "    ...                        ' Can be used with ADO",
            "End If",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "IsElementInVersions",
        label: "IsElementInVersions(Val: Variant, Elem: String | Categorical, Versions: String): Boolean",
        insertText: "IsElementInVersions",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "Variant value, used only to specify which MDM object to use."
            },
            {
                name: "Elem",
                type: [
                    BasicTypeDefinitions.string,
                    BasicTypeDefinitions.categorical,
                ],
                note: "*String* or *Categorical* value specifying an element or Elements list in `Val`."
            },
            {
                name: "Versions",
                type: BasicTypeDefinitions.string,
                note: "Optional. Names of versions to check."
            }
        ],
        note: [
            "```ds",
            "(function) IsElementInVersions(Val: Variant, Elem: Variant, Versions: String): Boolean",
            "```",
            "-----------------------------------",
            "Tests whether an element or list exists in all specified versions of a variable.",
            "+ `Val`: *String* - Variant value, used only to specify which MDM object to use.",
            "+ `Elem`: *String* | *Categorical* - *String* or *Categorical* value specifying an element or Elements list in `Val`.",
            "+ `Versions`: *String* - Optional. Names of versions to check.",
            "+ `return`: *Boolean* - Whether the element/list exists in all specified versions of `Val`.",
            "",
            "`Val` may refer to any type of MDM object that has elements, for example, *Field*, *Array*, *Grid* or *VariableInstance*, or it may be an Elements list itself.",
            "If `Elem` is of type *Text*, it is assumed to be the full name or numeric value of either a single Element or an Elements list. If `Elem` is of type Long, it is assumed to be the numeric value of an Element or Elements list. If Elem is of type *Categorical*, its first value is used to specify the Element or Elements list. If `Elem` is empty or *NULL*, the return value is *False*. If `Elem` is of any other type, an error occurs. If `Elem` specifies a value that does not correspond to an Element or Elements list in the MDM document, the return value is *False*.",
            "`Versions` is a version expression as used in the Open method of an MDM Document. If `Versions` is omitted or blank, all versions of `Val` that are currently selected in the MDM document are used.",
            "",
        ].join("\n"),
    },
    {
        name: "IsEmpty",
        label: "IsEmpty(Val: Variant): Boolean",
        insertText: "IsEmpty",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "Variant value to be tested."
            }
        ],
        note: [
            "```ds",
            "(function) IsEmpty(Val: Variant): Boolean",
            "```",
            "-----------------------------------",
            "Returns *True* if the value is empty. An empty string is one that contains no characters or just contains white spaces. An empty category list is one that contains no categories. A *NULL* value is deemed to be empty. Unless *NULL*, other data types are always deemed to be not empty.",
            "+ `Val`: *Variant* - Variant value to be tested.",
            "+ `return`: *Boolean* - *True* if `Val` is empty, otherwise *False*.",
            "",
            "### Remarks",
            "If `Val` is *NULL*, the return value is *True*.",
            "",
            "### Examples",
            "",
            "| Function call  | Value of Q1                 |  Result    |",
            "| :------------- | :-------------------------  | :--------- |",
            "| IsEmpty(Q1)    | 24 St John's Road, Barnes   |  False     |",
            "| IsEmpty(Q1)    |                             |  True      |",
            "| Q1.IsEmpty()   | {3}                         |  False     |",
            "| Q1.IsEmpty()   | {}                          |  True      |",
            "| Q1.IsEmpty()   | 17.50                       |  False     |",
            "| Q1.IsEmpty()   | 0.00                        |  False     |",
            "| Q1.IsEmpty()   | NULL                        |  True      |",
            "",
            "The *address* variable is a text variable that stores respondents' addresses. However, for some respondents the address has not been recorded and the variable stores an empty string. You could use the following to exclude those respondents:",
            "```ds",
            "NOT (address.IsEmpty())",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "IsEqualObject",
        label: "IsEqualObject(Val1: Object, Val2: Object): Boolean",
        insertText: "IsEqualObject",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val1",
                type: BasicTypeDefinitions.object,
                note: "The first value to test.",
            },
            {
                name: "Val2",
                type: BasicTypeDefinitions.object,
                note: "The second value to test.",
            },
        ],
        note: [
            "```ds",
            "(function) IsEqualObject(Val1: Object, Val2: Object): Boolean",
            "```",
            "-----------------------------------",
            "Returns *True* if two values refer to the same object.",
            "+ `Val1`: *Object* - The first value to test.",
            "+ `Val2`: *Object* - The second value to test.",
            "+ `return`: *Boolean* - *True* if `Val1` and `Val2` refer to the same object or are both *NULL*, otherwise *False*.",
            "",
            "### Examples",
            "The following mrScriptBasic example tests two variables to see if they refer to the same object:",
            "```ds",
            "If MyVariable1.IsEqualObject(MyVariable2) Then",
            "    ...                          ' The same object, or both NULL",
            "Else",
            "    ...                          ' Not the same object",
            "End If",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "IsNullObject",
        label: "IsNullObject(Val: Variant): Boolean",
        insertText: "IsNullObject",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "The value to test."
            }
        ],
        note: [
            "```ds",
            "(function) IsNullObject(Val: Variant): Boolean",
            "```",
            "-----------------------------------",
            "Returns *true* if an variable is *NULL*, without testing the default property of the object being referenced.",
            "+ `Val`: *Variant* - The value to test.",
            "+ `return`: *Boolean* - *True* if `Val` is *NULL*, *False* otherwise.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the `IsNullObject` function to test if a variable is *NULL*:",
            "```ds",
            "Dim Identifier, Identifiers",
            "Set Identifier = CreateObject(\"mrEvaluate.Identifier\")",
            "Set Identifiers = CreateObject(\"mrEvaluate.Identifiers\")",
            "",
            "Identifier.Name = \"MyID\"",
            "Identifier.Value = NULL",
            "Identifiers.Add(Identifier)",
            "",
            "Set Identifier = Identifiers.FindItem(\"MyID\")",
            "",
            "If Identifier.IsNullObject() Then",
            "    Debug.Log(\"MyID not found\")",
            "Else",
            "    Debug.Log(\"MyID found\")",
            "End If",
            "```",
            "This script will correctly output the message \"MyID found\" because the value of *Identifier* is not *NULL*. However, if *Identifier* was tested using the following line instead, the message \"MyID not found\" would be output:",
            "```ds",
            "If Identifier Is Null Then",
            "```",
            "This is because although *Identifier* is not *NULL*, the value of its default property (*Identifier.Value*) is *NULL*.",
            "",
        ].join("\n"),
    },
    {
        name: "IsOneOf",
        label: "IsOneOf(Val1: Variant, [Vals: Variant ...]): Boolean",
        insertText: "IsOneOf",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val1",
                type: BasicTypeDefinitions.variant,
                note: "The value to test."
            },
            {
                name: "Vals",
                type: BasicTypeDefinitions.variant,
                ellipsis: true,
                optional: true,
                note: "Variable number of other values."
            }
        ],
        note: [
            "```ds",
            "(function) IsOneOf(Val1: Variant, [Vals: Variant ...]): Boolean",
            "```",
            "-----------------------------------",
            "Returns *true* if a value is equal to at least one of the other listed values.",
            "+ `Val1`: *Variant* - The value to test.",
            "+ `Vals`: *Variant* - Variable number of other values.",
            "+ `return`: *Boolean* - *True* if `Val1` is equal to one or more of `Vals`, otherwise *False*.",
            "",
            "### Remarks",
            "If `Val1` is *NULL* and at least one of `Vals` is *NULL*, the return value is *True*. If `Vals` is not supplied, the return value is *False*.",
            "In SQL statements, the `IsOneOf` function can be used in place of the IN operator, which is not supported by the IBM® SPSS® Data Collection Data Model.",
            "",
            "### Examples",
            "",
            "| Function Call       |  Val1     | Vals                                               | Result |",
            "| :--------------     | :-------- | :------------------------------------------------- | :----- |",
            "| IsOneOf(Val1, Vals) |  {4}      | {7}, {3}, {4}, {8}                                 | True   |",
            "| IsOneOf(Val1, Vals) |  \"song\" | \"Cuckoo\", \"song\", \"is\", \"summer\", \"song\" | True   |",
            "| Val1.IsOneOf(Vals)  |  17.9     | 17, 17.4, 17.98                                    | False  |",
            "| Val1.IsOneOf(Vals)  |  NULL     | NULL, 0, 1, -1                                     | True   |",
            "",
            "The following example shows the use of the `IsOneOf` function in an SQL query, which will be executed against the Short Drinks sample data set provided with the IBM® SPSS® Data Collection Developer Library:",
            "```sql",
            "SELECT respondent.serial AS 'Serial', gender, occup",
            "FROM vdata",
            "WHERE occup.IsOneOf('sailor', 'doctor', 'soldier', 'postman')",
            "```",
            "Here is the result set:",
            "",
            "| Serial | gender   | occup     |",
            "| :----- | :------  | :------   |",
            "| 100    | {male}   | postman   |",
            "| 115    | {female} | doctor    |",
            "",
        ].join("\n"),
    },
    {
        name: "IsSet",
        label: "IsSet(Val: Long, Mask: Long): Boolean",
        insertText: "IsSet",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.long,
                note: "Data value to test.",
            },
            {
                name: "Mask",
                type: BasicTypeDefinitions.long,
                note: "Pattern of bits to check."
            }
        ],
        note: [
            "```ds",
            "(function) IsSet(Val: Long, Mask: Long): Boolean",
            "```",
            "-----------------------------------",
            "Returns *True* if an integer value matches a specified mask.",
            "+ `Val`: *Long* - Data value to test.",
            "+ `Mask`: *Long* - Pattern of bits to check.",
            "+ `return`: *Boolean* - Whether all the bits set in `Mask` are set in `Val`.",
            "",
            "### Remarks",
            "If `Mask` is zero (no bits set), the return value is *True*. If the current data value is *NULL*, `Val` is 0 and the return value is *False*.",
            "This function is equivalent to the expression:",
            "```ds",
            "BitAnd(Val, Mask) = Mask",
            "```",
            "",
            "### Examples",
            "The following example selects only records where *Respondent.Serial* is an odd number.",
            "```sql",
            "SELECT * FROM vdata",
            "WHERE Respondent.Serial.IsSet(1)",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "RGB",
        label: "RGB(Red: Long, Green: Long, Blue: Long): Long",
        insertText: "RGB",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Red",
                type: BasicTypeDefinitions.long,
                note: "Red value."
            },
            {
                name: "Green",
                type: BasicTypeDefinitions.long,
                note: "Green value."
            },
            {
                name: "Blue",
                type: BasicTypeDefinitions.long,
                note: "Blue value."
            },
        ],
        note: [
            "```ds",
            "(function) RGB(Red: Long, Green: Long, Blue: Long): Long",
            "```",
            "-----------------------------------",
            "+ `Red`: *Long* - Red value.",
            "+ `Green`: *Long* - Green value.",
            "+ `Blue`: *Long* - Blue value.",
            "+ `return`: *Long* - Color value.",
            "",
            "### Remarks",
            "The return value is an RGB color value using the given intensities of red, green and blue. If any of the input values is less than 0, it is converted to 0. If any of the input values is greater than 255, it is converted to 255.",
            "This function is similar to the `RGB` function in Visual Basic.",
            "",
            "### Examples",
            "This example shows how the RGB function can be used to return a whole number that represents the RGB value for the color yellow:",
            "```ds",
            "Dim Yellow",
            "Yellow = RGB(255, 255, 0)",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "SampleCategorize",
        label: "SampleCategorize(Val: Variant, CategorizedVariable: String): Variant",
        insertText: "SampleCategorize",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "Variant value of type *Long*, *Double*, *Text*, or *Date*"
            },
            {
                name: "CategorizedVariable",
                type: BasicTypeDefinitions.string,
                note: "The name of the *categorical* variable, which will be used to ensure the generated category name exists."
            }
        ],
        note: [
            "```ds",
            "(function) SampleCategorize(Val: Variant, CategorizedVariable: String): Variant",
            "```",
            "-----------------------------------",
            "A simple version of the `Categorize` function that is used with the Sample Reporting MDSC (Phone Reports).",
            "+ `Val`: *Variant* - Variant value of type *Long*, *Double*, *Text*, or *Date*",
            "+ `CategorizedVariable`: *String* - The name of the *categorical* variable, which will be used to ensure the generated category name exists.",
            "+ `return`: *Variant* - If the generated category name exists in the metadata, the category is returned, otherwise *NULL* is returned.",
            "",
            "### Remarks",
            "Similar to `Categorize`, the conversion process starts by generating an MDM name from the value `Val`. The `MDMName` function is used for this process. If the generated category name exists in the metadata, the category is returned, otherwise *NULL* is returned.",
            "Unlike `Categorize`, `SampleCategorize` does not return *NA* or *Other* based on a variable definition.",
            "",
            "### Examples",
            "```ds",
            "_Queue \"Sampe queue\"",
            "    categorical [1..1]",
            "     {",
            "        FRESH \"Fresh\",",
            "        ACTIVE \"Active\",",
            "        TIMEDOUT \"Timed Out\",",
            "        NA \"No Answer\" na,",
            "        other \"Other\" other",
            "    };",
            "```",
            "The following result is returned:",
            "```ds",
            "Result = SampleCategorize(Val, \"_Queue\")",
            "```",
            "",
            "| Val           | Result    |",
            "| :----------   | :-----    |",
            "| \"Active\"    | {ACTIVE}  |",
            "| \" \"         | NULL  |",
            "| \"NoAnswer\"  | NULL  |",
            "",
        ].join("\n"),
    },
    {
        name: "ShellExecute",
        label: "ShellExecute(File: String, [HWnd: Long], [Verb: String], [Parameters: String], [Directory: String], [ShowCmd: Long]): Long",
        insertText: "ShellExecute",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "File",
                type: BasicTypeDefinitions.string,
                note: "File or object on which to execute the specified verb."
            },
            {
                name: "HWnd",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. Handle to a parent window. This window receives any message boxes that the invoked application produces, such as error reporting. If omitted, message boxes will not be tied to a window."
            },
            {
                name: "Verb",
                type: BasicTypeDefinitions.string,
                optional: true,
                note: "Optional. Action to be performed. If omitted, the default verb for the file type is used if it is valid; otherwise, the \"open\" verb is used. For Windows 2000 and later systems, if neither verb is available, the first available verb for the file type is used."
            },
            {
                name: "Paramerters",
                type: BasicTypeDefinitions.string,
                optional: true,
                note: "Optional. If `File` is an executable file, the parameters to be passed to the application. Otherwise, ignored."
            },
            {
                name: "Directory",
                type: BasicTypeDefinitions.string,
                optional: true,
                note: "Optional. Default directory for the application. The default is the current directory."
            },
            {
                name: "ShowCmd",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. A value that specifies how the application is to be displayed. The default is 1. Possible values are shown in the table below."
            }
        ],
        note: [
            "```ds",
            "(function) ShellExecute(File: String, [HWnd: Long], [Verb: String], [Parameters: String], [Directory: String], [ShowCmd: Long]): Long",
            "```",
            "-----------------------------------",
            "Performs an operation on a specified file.",
            "+ `File`: *String* - File or object on which to execute the specified verb.",
            "+ `HWnd`: *Long* - Optional. Handle to a parent window. This window receives any message boxes that the invoked application produces, such as error reporting. If omitted, message boxes will not be tied to a window.",
            "+ `Verb`: *String* - Optional. Action to be performed. If omitted, the default verb for the file type is used if it is valid; otherwise, the \"open\" verb is used. For Windows 2000 and later systems, if neither verb is available, the first available verb for the file type is used.",
            "+ `Parameters`: *String* - Optional. If `File` is an executable file, the parameters to be passed to the application. Otherwise, ignored.",
            "+ `Directory`: *String* - Optional. Default directory for the application. The default is the current directory.",
            "+ `ShowCmd`: *Long* - Optional. A value that specifies how the application is to be displayed. The default is 1. Possible values are shown in the table below.",
            "+ `return`: *Long* - A value greater than 32.",
            "",
            "The following table shows the possible values for the `ShowCmd` parameter.",
            "",
            "+ **0** - Hides the window and activates another window. ",
            "+ **1** - Activates and displays a window. If the window is minimized or maximized, Windows restores it to its original size and position. An application should specify this flag when displaying the window for the first time.",
            "+ **2** - Activates the window and displays it as a minimized window.",
            "+ **3** - Activates the window and displays it as a maximized window.",
            "+ **4** - Displays a window in its most recent size and position. The active window remains active.  ",
            "+ **5** - Activates the window and displays it in its current size and position. ",
            "+ **6** - Minimizes the specified window and activates the next top-level window in the z-order. ",
            "+ **7** - Displays the window as a minimized window. The active window remains active",
            "+ **8** - Displays the window in its current state. The active window remains active.",
            "+ **9** - Activates and displays the window. If the window is minimized or maximized, Windows restores it to its original size and position. An application should specify this flag when restoring a minimized window.  ",
            "+ **10** - Sets the show state based on the SW_ flag specified in the STARTUPINFO structure passed to the CreateProcess function by the program that started the application. An application should call ShowWindow with this flag to set the initial show state of its main window.  ",
            "",
            "### Remarks",
            "If the command cannot be executed, an error occurs.",
            "@note - If you want your script to wait for the program to finish before continuing, use the `WshShell` object that is part of the Microsoft Windows Script Host object model.",
            "",
            "### Examples",
            "The following example opens the Short Drinks example .mdd file in IBM® SPSS® Data Collection Questionnaire Viewer:",
            "```ds",
            "ShellExecute(\"[INSTALL_FOLDER]\\IBM\\SPSS\\DataCollection\\6\\DDL\\Data\\Mdd\\short_drinks.mdd\")",
            "```",
            "The following example opens the IBM® SPSS® Data Collection Metadata Model Version Utility:",
            "```ds",
            "ShellExecute(\"[INSTALL_FOLDER]\\IBM\\SPSS\\DataCollection\\6\\\\Accessories\\MDMVersionUtility.exe\")",
            "```",
            "The following example opens a specified text file in Wordpad, and maximizes the window:",
            "```ds",
            "ShellExecute(\"C:\\Program Files\\Windows NT\\Accessories\\Wordpad.exe\", , , \"C:\\Samples\\funlib.txt\", , 3)",
            "```",
        ].join("\n"),
    },
    {
        name: "Sleep",
        label: "Sleep(Val: Long): Void",
        insertText: "Sleep",
        definitionType: "function",
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.long,
                note: "Number of milliseconds to suspend the thread for."
            }
        ],
        note: [
            "```ds",
            "Sleep(Val)",
            "```",
            "-----------------------------------",
            "Suspends the thread in which it is called.",
            "+ `Val`: *Long* - Number of milliseconds to suspend the thread for.",
            "",
            "### Remarks",
            "This function suspends the thread in which the function is called for at least the time specified by Val. If there are other threads in the process, they will continue to execute. After Val milliseconds have elapsed, the next time the system is ready to resume the thread that was suspended, it will continue execution and this function will return.",
            "The return value is not useful.",
            "",
            "### Examples",
            "The following mrScriptBasic example suspends the thread for at least two seconds:",
            "```ds",
            "Sleep(2000)",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "Validate",
        label: "Validate(Val: Variant, [Min: Double], [Max: Double], [Expr: String], [Describe: Boolean = False]): Boolean",
        insertText: "Validate",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.variant,
                note: "The value to test.",
            },
            {
                name: "Min",
                type: BasicTypeDefinitions.double,
                optional: true,
                note: "Optional. The minimum value allowed. The default is -1.79769313486232e308."
            },
            {
                name: "Max",
                type: BasicTypeDefinitions.double,
                optional: true,
                note: "Optional. The maximum value allowed. The default is 1.79769313486232e308."
            },
            {
                name: "Expr",
                type: BasicTypeDefinitions.string,
                optional: true,
                note: "Optional. Expression for a text, numeric, or date value. For a numeric or date value, the expression can specify one or more valid ranges. For a text value, the expression defines a regular expression that can be used to validate the text."
            },
            {
                name: "Describe",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                defaultValue: false,
                note: "Optional. Whether to generate a description for a failed test. The default is *False*"
            }
        ],
        note: [
            "```ds",
            "(function) Validate(Val: Variant, [Min: Double], [Max: Double], [Expr: String], [Describe: Boolean]): Boolean",
            "```",
            "-----------------------------------",
            "Validates a specified value based on specified minimum and maximum values and optionally a validating expression.",
            "+ `Val`: *Variant* - The value to test.",
            "+ `Min`: *Double* - Optional. The minimum value allowed. The default is -1.79769313486232e308.",
            "+ `Max`: *Double* - Optional. The maximum value allowed. The default is 1.79769313486232e308.",
            "+ `Expr`: *String* - Optional. Expression for a text, numeric, or date value. For a numeric or date value, the expression can specify one or more valid ranges. For a text value, the expression defines a regular expression that can be used to validate the text.",
            "+ `Describe`: *Boolean* - Optional. Whether to generate a description for a failed test. The default is *False*",
            "+ `return`: *Boolean* - *True* if `Val` fits the conditions, *False* otherwise.",
            "",
            "### Remarks",
            "The following table explains the conditions in which `Validate` returns *False*. In all other cases, `Validate` returns *True*. Note that if `Val` is *Null* or a *Boolean* or *Object* value, `Min`, `Max` and `Expr` are ignored, and the return value is always *True*.",
            "When Val is:",
            "- **Text** -",
            "    - `Min` is supplied and `Val` has fewer than `Min` characters.",
            "    - `Max` is supplied and `Val` has more than `Max` characters.",
            "    - `Expr` is supplied and `Val` doesn’t match the regular expression (see below). Note that the whole text value needs to match the expression in order to pass validation.",
            "- **Numeric (Long or Double)** -",
            "    - `Min` is supplied and `Val < Min`",
            "    - `Max` is supplied and `Val > Max`.",
            "    - `Expr` is supplied and `Val` isn’t in any of the defined valid ranges (see below).",
            "- **Categorical** -",
            "    - `Min` is supplied and `Val` has fewer than `Min` responses.",
            "    - `Max` is supplied and `Val` has more than `Max` responses.",
            "- **Date** -",
            "    - `Min` is supplied and `Val` is earlier than the date whose internal representation is `Min`.",
            "    - `Max` is supplied and `Val` is later than the date whose internal representation is `Max`.",
            "    - `Expr` is supplied and `Val` isn't in any of the defined valid ranges (see below).",
            "",
            "Since the `Expr` argument is a string, it must be enclosed in double quotation marks (double quotation marks in a script or filter in IBM® SPSS® Data Collection Survey Tabulation, single quotation marks in an SQL query). If the expression itself contains quotation marks, they should be duplicated within the string. For example, in a script, the function call `Name.Validate(2, 80, \"[^\"\"]*\")` will result in the Expr argument having the value `[^\"]*`.",
            "If *Describe* is *True* and `Validate` returns *False*, it generates an error message describing the failed validation (formatted using the output locale) and stores it on the current thread. This means that any calling code that instantiates the Function Library objects and calls the `Validate` function directly can immediately inspect the thread's error information if the validation fails. Note that the next call to a function will clear the stored error information, so it must be inspected as soon as possible after the call to `Validate`. It is not possible to access the error message when `Validate` is called in SQL or mrScriptBasic.",
            "",
            "#### Range expression syntax",
            "When you use the Expr parameter to define a range expression to be used to validate a numeric or date value, the expression can contain one or more ranges, separated by commas. The syntax for a range is as follows:",
            "+ An optional negation operator, which is the caret symbol (^).",
            "+ An optional lower bound value.",
            "+ An optional upper bound value.",
            "+ If both values are supplied, they must be separated by the range operator, which is two periods with no space in between (..).",
            "+ The range operator can appear when either or both values are missing.",
            "+ A range lower or upper bound value is a sequence of characters that can be interpreted as a floating point number (if Val is Long or Double), or as a date or a floating point number (if `Val` is a *Date*), according to the given input locale.",
            "+ Any value can optionally be enclosed in single or double quotation marks. This is necessary if the value contains either a comma or a pair of periods, in order that they are not interpreted as separators between ranges or between range values.",
            "",
            "The following table provides some examples.",
            "",
            "| Range Expression                     | Description  |",
            "| :------------------------------      | :-------------------------  |",
            "| 5 .. 25                              | `Val` must be >= 5 and <= 25.  |",
            "| ^ 5 .. 25                            | `Val` must not be >= 5 and <= 25 (in other words, it must be < 5 or > 25).  |",
            "| .. 10, 20, 30 .., ^70                | `Val` must be <= 10, or 20, or >= 30, but not 70.  |",
            "| '10,5' .. \"11,5\", ^ '11,0'         | With a Danish (or similar) input locale, `Val` must be >= 10.5 and <= 11.5, but not 11.0.  |",
            "| 'Jan 1, 1960' .. 1980-12-31 23:59:59 | `Val` must be (a date) later than or equal to 00:00:00 on January 1st 1960 and before or equal to 23:59:59 on December 31st 1980.  |",
            "| ..                                   | Any value is allowed.  |",
            "| ^                                    | No value is allowed.  |",
            "",
            "#### Regular expression syntax",
            "Regular expressions are a concise and flexible notation that can be used for defining and validating patterns of text. The Function Library uses the Boost technology for regular expressions.",
            "When a regular expression contains characters, it usually means that the text being searched must match those characters. However, regular expressions use a number of characters that have a special meaning. The following table provides a summary of the most common special characters used in regular expressions. (The special characters are shown in bold and are case sensitive--for example, \\U is not the same as \\u.) Note that the whole text value needs to match the expression in order to pass validation.",
            "",
            "| Regular Expression | Description  |",
            "| :----------------- | :-------------------------------  |",
            "| .                  | Any character (including newline).  |",
            "| [abcn-z]           | Any of the characters a, b, c, n, o, p, ..., z.  |",
            "| \\w                | Any alphanumeric character (including accents) or underscore (_).  |",
            "| \\l                | Any lower-case character (including accents).  |",
            "| \\u                | Any upper-case character (including accents).  |",
            "| \\d                | Any numeric character.  |",
            "| \\s                | A whitespace character.  |",
            "| xxx|yyy            | Either xxx or yyy.  |",
            "| (xxx)              | Grouping (subexpression).  |",
            "| x*                 | Zero or more occurrences of x.  |",
            "| x+                 | One or more occurrences of x.  |",
            "| x?                 | Zero or one occurrences of x.  |",
            "| (xxx){m}           | Exactly m occurrences of xxx.  |",
            "| (xxx){m,n}         | At least m and at most n occurrences of xxx.  |",
            "| \\                 | The escape character that you use to match characters that have a special meaning in regular expressions, such as the following characters , . ? { } [ ] ( ) $ ^ *. For example, to match the { character, you would specify {.  |",
            "",
            "### Examples",
            "",
            "#### 1. Validating a numeric variable",
            "The following SQL example provides a simple example of using the Validate function to test whether the value in a numeric variable is within a given range. In this example, the range has been specified using the `Min` and `Max` parameters.",
            "```sql",
            "SELECT Respondent.Serial, ",
            "    Visits,",
            "    Validate(Visits, 5, 10) AS Valid",
            "FROM vdata",
            "WHERE Visits IS NOT NULL",
            "```",
            "Here are the results for the first five respondents in the result set:",
            "",
            "| Respondent.Serial | Visits | Valid   |",
            "| :---------------  | :----- | :----   |",
            "| 1                 | 1      | False   |",
            "| 4                 | 6      | True    |",
            "| 5                 | 2      | False   |",
            "| 6                 | 1      | False   |",
            "| 7                 | 1      | False   |",
            "",
            "We could achieve exactly the same results by specifying a range expression in the `Expr` parameter instead of using the `Min` and `Max` parameters:",
            "```sql",
            "SELECT Respondent.Serial, ",
            "    Visits,",
            "    Visits.Validate(, , '5..10') AS Valid ",
            "FROM vdata",
            "WHERE Visits IS NOT NULL",
            "```",
            "Notice that this time instead of passing the name of the variable (*Visits*) as a parameter, we have preceded the function call with the variable's name and omitted the variable parameter. This is an alternative way of calling the function.",
            "Using the `Expr` parameter enables you to specify quite complex requirements. When you are filtering data, using the `Validate` function and a range expression can be easier than defining the filter using a complex expression. For example, in the following example, `Validate` has been used in the WHERE clause to select respondents for whom the Visits variable has a value from 5 to 10, with the exception of 7, or a value of 50 or more.",
            "```sql",
            "SELECT Respondent.Serial, Visits",
            "FROM vdata ",
            "WHERE Visits IS NOT NULL",
            "    AND Validate(Visits, , , '5..10, ^7, 50..')",
            "```",
            "Note that `IS NOT NULL` has been used to exclude respondents for whom the *Visits* variable stores *Null*. If we remove this from the `WHERE` clause, all the respondents for whom the *Visits* variable stores *Null* will be included, because `Validate` always returns *True* when the value is *Null*.",
            "#### 2. Validating a text variable",
            "You can use the `Validate` function to check whether a text response meets certain requirements. For example, you can check that it has a specified number of characters, is all uppercase, is a valid product or postal code, etc. The following example, uses `Validate` to test whether an input text is a valid email address. (It doesn't check that the email address actually exists, it just checks that the text is a valid combination of characters--in this case, any combination of alphanumeric, hyphen, and period characters followed by the at sign (@), followed by any combination of alphanumeric, hyphen, and period characters.)",
            "```ds",
            "Dim Valid",
            "Valid = Validate(\"John-Smith@SPSS.com\", , , \"[-.\\w]+\\@[-.\\w]+\")",
            "```",
            "The next example tests that a product code is made up of two uppercase letters followed by a hyphen (-) followed by eight numbers.",
            "```ds",
            "Dim Valid",
            "Valid = Validate(\"ID-86442000\", , , \"\\u{2}-\\d{8}\")",
            "```",
            "The next example is an SQL query that can be run on the *Museum* sample data. This query uses `Validate` to check that the texts stored in the *Name* variable are between one and 45 characters long and are composed of one or more words separated by single spaces, with no punctuation.",
            "```sql",
            "SELECT Respondent.Serial, ",
            "    Name,",
            "    Name.Validate(1, 45, '\\w+(\\s\\w+)+') ",
            "FROM vdata",
            "```",
        ].join("\n"),
    },
    {
        name: "VarType",
        label: "VarType(Val: Long): Long",
        insertText: "VarType",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.long,
                note: "The data value."
            }
        ],
        note: [
            "```ds",
            "(function) VarType(Val: Long): Long",
            "```",
            "-----------------------------------",
            "Returns a numeric value indicating the type of a variable.",
            "+ `Val`: *Long* - The data value.",
            "+ `return`: *Long* - The type of `Val`.",
            "",
            "### Remarks",
            "The return value is a number representing the type of `Val`, as shown in the following table.",
            "",
            "| Value  | Description  |",
            "| :----- | :----------- |",
            "| 0      | None (Val is NULL)   |",
            "| 1      | Long |",
            "| 2      | Text |",
            "| 3      | Categorical  |",
            "| 4      | Object   |",
            "| 5      | Date |",
            "| 6      | Double   |",
            "| 7      | Boolean  |",
            "",
            "An error occurs if `Val` has any other type.",
            "This function is similar to the `VarType` function in Visual Basic.",
            "",
            "### Examples",
            "",
            "The following mrScriptBasic example uses the `VarType` function to determine the type of a variable:",
            "```ds",
            "Dim MyVar, MyTest",
            "",
            "MyVar = 34",
            "MyTest = VarType(MyVar)     ' Returns 1",
            "",
            "MyVar = \"Hullo\"",
            "MyTest = VarType(MyVar)     ' Returns 2",
            "",
            "MyVar = {1, 2, 3, 4}",
            "MyTest = VarType(MyVar)     ' Returns 3",
            "```",
        ].join("\n"),
    },
    {
        name: "VarTypeName",
        label: "VarTypeName(Val: Long): String",
        insertText: "VarTypeName",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.long,
                note: "The data value."
            }
        ],
        note: [
            "```ds",
            "(function) VarTypeName(Val: Long): String",
            "```",
            "-----------------------------------",
            "Returns a string indicating the type of a variable.",
            "+ `Val`: *Long* - The data value.",
            "+ `return`: *Text* - The type of `Val`.",
            "",
            "### Remarks",
            "The return value is a string representing the type of `Val`, as shown in the following table.",
            "",
            "| Value           | Description |",
            "| :-------------- | :-------------  |",
            "| \"None\"        | None (Val is NULL)  |",
            "| \"Long\"        | Long    |",
            "| \"Text\"        | Text    |",
            "| \"Categorical\" | Categorical |",
            "| \"Object\"      | Object  |",
            "| \"Date\"        | Date    |",
            "| \"Double\"      | Double  |",
            "| \"Boolean\"     | Boolean |",
            "",
            "An error occurs if `Val` has any other type.",
            "This function is similar to the `TypeName` function in Visual Basic.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the `VarTypeName` function to determine the type of a variable:",
            "```ds",
            "Dim MyTest, MyVar",
            "",
            "MyVar = 34",
            "MyTest = VarTypeName(MyVar)     ' Returns \"Long\"",
            "",
            "MyVar = \"Hullo\"",
            "MyTest = VarTypeName(MyVar)     ' Returns \"Text\"",
            "",
            "MyVar = {1, 2, 3, 4}",
            "MyTest = VarTypeName(MyVar)     ' Returns \"Categorical\"",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "FindItem",
        label: "FindItem(List: Variant, Key: Varaint): Varaint",
        insertText: "FindItem",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "List",
                type: BasicTypeDefinitions.variant,
                note: "*Array*, *collection* or *Categorical* value to operate on.",
            },
            {
                name: "Key",
                type: BasicTypeDefinitions.variant,
                note: "Index, name, or value of the item to be found."
            }
        ],
        note: [
            "```ds",
            "(function) FindItem(List: Variant, Key: Varaint): Varaint",
            "```",
            "-----------------------------------",
            "This function returns a specified item from a list, or *NULL* if the item isn't found.",
            "+ `List`: *Variant* - *Array*, *collection* or *Categorical* value to operate on.",
            "+ `Key`: *Variant* - Index, name, or value of the item to be found.",
            "+ `return`: *Variant* - A copy of the requested item if found in *List*, or *NULL* if the item is not found.",
            "",
            "### Remarks",
            "This function can be used to look up an item in a list, without generating an error if the item doesn't exist. If `List` or `Key` are *NULL*, the return value is *NULL*.",
            "The way in which `Key` is used to locate an item depends on the type of the list, as follows:",
            "- **1. If List is a Collection** - ",
            "`Key` is passed to the list's \"Evaluate method\", that is, the property or method that is given a COM Dispatch identifier of -5. If the list has no `Evaluate` method, `Key` is passed to the Item property of the list. If the list has neither an `Evaluate` method, nor a property or method called \"Item\" (in English only), or if accessing the `Evaluate` method or the Item property generates an error, the return value is *NULL*. Otherwise, the return value is the value returned by the `Evaluate` method or the Item property, which may be *NULL* if the item isn't found.",
            "- **2. If List is an Array or Categorical Value, and Key is of type Long** - ",
            "    - `Key` is taken as the positional index of an item in the list, starting at 0 for the first item. If `Key` is greater than or equal to zero and less than the number of items in List, the return value is the item at that position. Otherwise, the return value is *NULL*.",
            "    - For example, if *List* is a *Categorical* value that contains three or more categories and `Key` is 2 (*Long*), the return value is the third category in the list.",
            "- **3. If List is an Array or Categorical Value, and Key is not of type Long** - ",
            "    - `Key` is compared with each list item in turn until a match is found. The way that Key is compared with each item depends on the type of the item:",
            "        - For a *string* item, `Key` is converted to a string and compared with the item.",
            "        - For an item that is an object, `Key` is converted to a string and compared with the value of the object's \"Name property\", that is, the property that is given a COM Dispatch identifier of -800. If the object has no \"Name property\", the `Key` is compared with the value of the object's default property, which is converted to a string if necessary. If the object has no Name or default properties, or if accessing the Name or default properties generates an error, the item is considered not to be a match for `Key`.",
            "        - For any other type of item, Key is compared with the item using the normal conversion and comparison rules for variant types.",
            "    - In all string comparisons, differences between upper and lower case are ignored. If a matching item is found, the return value is the matching item. Otherwise the return value is *NULL*.",
            "    - For example, if `List` is a *Categorical* value that contains a category with a value of 2 and `Key` is “2” (*Text*) or 2.0 (*Double*), the return value is 2 (*Long*).",
            "",
            "### Examples",
            "",
            "| Function call       |  List                           |  Key     |  Result    | Notes |",
            "| :-----------------  |  :----------------              |  :-----  |  :------   | :------------- |",
            "| FindItem(List, Key) |  {8,5,7,1,3,4,9}                |  4       |  3         | The item with a positional index of 4 (that is, the fifth item) in the categorical value is returned. |",
            "| FindItem(List, Key) |  {8,5,7,1,3,4,9}                |  10      |  NULL      | There is no item with a positional index of 10, so NULL is returned. |",
            "| FindItem(List, Key) |  {8,5,7,1,3,4,9}                |  \"4.0\" |  4         | To compare with the Long values in the categorical value, Key is converted from a Text to a Long value, and the matching item is returned. |",
            "| FindItem(List, Key) |  {8,5,7,1,3,4,9}                |  4.0     |  4         | To compare with the Long values in the categorical value, Key is converted from a Double to a Long value, and the matching item is returned. |",
            "| FindItem(List, Key) |  split(\"The quick brown fox\") |  1       |  \"quick\" | The item with a positional index of 1 (that is, the second item) in the array is returned. |",
            "| FindItem(List, Key) |  split(\"The quick brown fox\") |  \"THE\" |  \"The\"   | The matching Text item in the array is returned. String comparisons are always case insensitive. |",
            "| FindItem(List, Key) |  split(\"1 2 3 4 5\")           |  4       |  \"5\"     | Key is a Long value, so the item with a positional index of 4 in the array is returned. |",
            "| FindItem(List, Key) |  split(\"1 2 3 4 5\")           |  \"4\"   |  \"4\"     | Key is a Text value, so the matching text item in the array is returned. |",
            "| FindItem(List, Key) |  split(\"1 2 3 4 5\")           |  4.0     |  \"4\"     | Key is converted from a Double to a Text value, and the matching text item in the array is returned. |",
            "",
            "The `Split` function is used in some of the above examples to create an array of substrings that `FindItem` can operate on.",
            "The following mrScriptBasic example uses the `FindItem` function to find an item called \"Country\" in a collection:",
            "```ds",
            "Dim myItem",
            "",
            "myItem = myCollection.FindItem(\"Country\")",
            "",
            "If myItem <> NULL Then",
            "    ...                   ' Item found",
            "Else",
            "    ...                   ' Item not found",
            "End If",
            "```",
        ].join("\n"),
    },
    {
        name: "GetReversalSeed",
        label: "GetReversalSeed(): Long",
        insertText: "GetReversalSeed",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        note: [
            "```ds",
            "(function) GetReversalSeed(): Long",
            "```",
            "-----------------------------------",
            "Returns the current reversal state. This is the value that was used by the most recent call to the `Rev` function to determine whether the list was reversed or not. An odd value means that the list was reversed, an even value means that the list was presented in its normal order.",
            "+ `return`: *Long* - Current reversal state.",
            "",
            "### Remarks",
            "The current reversal state is stored by the mrScriptBasic engine and Evaluate component and passed to the `Rev` function as a hidden parameter.",
            "",
            "### Examples",
            "```ds",
            "Dim seed",
            "",
            "seed = GetReversalSeed()",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "GetRotationSeed",
        label: "GetRotationSeed(): Long",
        insertText: "GetRotationSeed",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        note: [
            "```ds",
            "GetRotationSeed()",
            "```",
            "-----------------------------------",
            "Returns the current rotation state, which is used by the `Rot` function. This represents the offset that was used for the most recent rotation.",
            "+ `return`: *Long* - Current rotation state.",
            "",
            "### Remarks",
            "The current rotation state is stored by the mrScriptBasic engine and Evaluate component and passed to the `Rot` function as a hidden parameter.",
            "The `GetRotationSeed` function is similar to using the rotation keyword in IBM® SPSS® Quancept™.",
            "",
            "### Examples",
            "```ds",
            "Dim seed",
            "",
            "seed = GetRotationSeed()",
            "```",
        ].join("\n"),
    },
    {
        name: "Ran",
        label: "Ran(List: Variant, [Count: Long], [Seed: Long = 0]): Varaint",
        insertText: "Ran",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "List",
                type: BasicTypeDefinitions.variant,
                note: "*Array*, *collection*, or *Categorical* value to operate on."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned"
            },
            {
                name: "Seed",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 0,
                note: "Optional. The starting point to be used for the generation of the random ordering. The default is 0."
            }
        ],
        note: [
            "```ds",
            "(function) Ran(List: Variant, [Count: Long], [Seed: Long = 0]): Varaint",
            "```",
            "-----------------------------------",
            "This function returns a randomized copy of a list. The optional `Count` parameter defines how many items from the input list are included in the returned randomized list.",
            "+ `List`: *Variant* - *Array*, *collection*, or *Categorical* value to operate on.",
            "+ `Count`: *Long* - Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned.",
            "+ `Seed`: *Long* - Optional. The starting point to be used for the generation of the random ordering. The default is 0.",
            "+ `return`: *Variant* - An array consisting of a randomized copy of the input list.",
            "",
            "### Remarks",
            "An error occurs if `List` is a collection that doesn't support the For Each...Next syntax. When List is a collection object, the return value is an array that contains copies of the objects in the collection and the input collection object is unchanged. Because the return value is an array, it does not have a `Count` property.",
            "If `Seed` is supplied, it is used to reset the starting point for the random number generator, as in `SetRandomSeed`, before the randomization. If `Seed` is not supplied or has a value of 0, the function will use the starting point stored for the random number generator by the mrScriptBasic engine or Evaluate component and passed as a hidden parameter. Each time you call one of the randomization functions, the starting point stored for the random number generator is updated. This means that if you call the function repeatedly without specifying the `Seed` parameter, the sequence of results is determined by the changing value passed as a hidden parameter. Specifying the `Seed` parameter is a way of resetting this sequence. It also means that the randomization can be repeated. For example, if you use this function to randomize a category list in an interview, by using the same seed value you could present the category list in the same sequence should the interview be restarted.",
            "The `Ran` function is similar to using the ran keyword in IBM® SPSS® Quancept™.",
            "",
            "### Examples",
            "`Ran` is useful when you are cleaning data. For example, when a respondent has selected more than one category in response to a single response question, you can use Ran to select one of the responses randomly, as shown in the following snippet of mrScriptBasic code:",
            "```ds",
            "If time_spent.AnswerCount() > 1 Then",
            "   time_spent = time_spent.Ran(1)",
            "End If",
            "```",
            "The next example shows using Ran with a multiple response variable called remember (which is in the IBM® SPSS® Data Collection Data File version of the Museum sample data set) in an SQL query. The example uses the `Ran` function twice, both times it is used to return one response from the list of responses stored in the variable. However, the first time the `Seed` parameter is not specified and the second time it is.",
            "```sql",
            "SELECT Respondent.Serial, ",
            "    remember, ",
            "    Ran(remember, 1) AS Remember1, ",
            "    Ran(remember, 1, 1) AS Remember2,",
            "    remember.AnswerCount() AS HowMany",
            "FROM vdata ",
            "WHERE remember IS NOT NULL",
            "```",
            "",
            "",
            "|       | Remember                                       | Remember1           | Remember2           | HowMany |",
            "| :---- | :--------------------------------------------- | :------------------ | :------------------ | :------ |",
            "| 1     | {dinosaurs,fish_and_reptiles,fossils,mammals,m | {fish_and_reptiles} | {dinosaurs}         | 7 |",
            "| 2     | {dinosaurs,fish_and_reptiles,fossils,mammals,m | {origin_of_species} | {fish_and_reptiles} | 8 |",
            "| 3     | {dinosaurs,fossils,birds,insects,whales,mammal | {minerals}          | {other}             | 11 |",
            "| 4     | {dinosaurs,conservation,birds,mammals,minerals | {other}             | {mammals}           | 6 |",
            "| 5     | {dinosaurs,birds,minerals,human_biology,evolut | {birds}             | {minerals}          | 5 |",
            "| 6     | {dinosaurs,birds,whales,mammals,origin_of_spec | {mammals}           | {dinosaurs}         | 7 |",
            "| 7     | {dinosaurs,birds,whales,mammals,minerals,botan | {human_biology}     | {birds}             | 8 |",
            "| 8     | {dinosaurs,insects,human_biology}              | {human_biology}     | {dinosaurs}         | 3 |",
            "",
            "Notice that the results in the Remember2 column are different from those in the Remember1 column, because the Seed parameter was used to specify a different starting point for the randomization. Although the results appear to be different in the Remember2 column for every case, in fact the choice of the category is based on the same random number each time. The reason the results appear to be different is that the cases have different numbers of responses. The HowMany column shows us how many responses have been selected in each row. We can see that:",
            "+ In rows where 3 or 7 responses were chosen, *Remember2* contains the first response.",
            "+ In rows where 4 or 8 responses were chosen, *Remember2* contains the second response.",
            "+ In rows where 5 responses were chosen, *Remember2* contains the third response.",
            "+ In rows where 6 responses were chosen, *Remember2* contains the fourth response.",
            "",
            "This is because if *N* is the random number being used, then:",
            "```ds",
            "N mod 3 = 0",
            "N mod 4 = 1",
            "N mod 5 = 2",
            "N mod 6 = 3",
            "N mod 7 = 0",
            "N mod 8 = 1",
            "```",
            "For example, *N* might be 777.",
            "",
        ].join("\n"),
    },
    {
        name: "RandomPassword",
        label: "RandomPassword([Val: String], [MinLength: Long], [MaxLength: Long]): String",
        insertText: "RandomPassword",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.string,
                note: "Optional. The characters allowed in the password. If `Val` is omitted or empty, “0123456789” is used.",
            },
            {
                name: "MinLength",
                type: BasicTypeDefinitions.long,
                note: "Optional. The minimum length of the password. If `MinLength` is omitted or is less than 1, the minimum length is set to 8."
            },
            {
                name: "MaxLength",
                type: BasicTypeDefinitions.long,
                note: "Optional. The maximum length of the password. If `MaxLength` is omitted or is less than `MinLength`, the maximum length is set to `MinLength`."
            }
        ],
        note: [
            "```ds",
            "(function) RandomPassword([Val: String], [MinLength: Long], [MaxLength: Long]): String",
            "```",
            "-----------------------------------",
            "Returns a string whose content and length are selected randomly within the constraints specified by the parameters. This function is intended to be used to generate unpredictable passwords.",
            "+ `Val`: *String* - Optional. The characters allowed in the password. If `Val` is omitted or empty, “0123456789” is used.",
            "+ `MinLength`: *Long* - Optional. The minimum length of the password. If `MinLength` is omitted or is less than 1, the minimum length is set to 8.",
            "+ `MaxLength`: *Long* - Optional. The maximum length of the password. If `MaxLength` is omitted or is less than `MinLength`, the maximum length is set to `MinLength`.",
            "+ `return`: *String* - A password whose content and length are selected randomly within the constraints specified by the parameters",
            "",
            "### Remarks",
            "If Val begins with \"[\" and ends with \"]\", Val is interpreted as a regular expression, which enables ranges of characters to be specified without listing them all explicitly. For example, \"[0-9a-fA-F]\" is equivalent to \"0123456789abcdefABCDEF\".",
            "The selection is truly random, like `SetRandomSeed(0)`, so the results are not reproducible.",
            "This function has no effect on the randomization state of the calling program.",
            "",
            "### Examples",
            "The following script generates a password that is between 10 and 16 characters long and contains a random selection of digits and lower-case letters:",
            "```ds",
            "Dim MyPassword",
            "MyPassword = RandomPassword(\"[a-z0-9]\", 10, 16)",
            "```",
        ].join("\n"),
    },
    {
        name: "RanSequence",
        label: "RanSequence(Start: Long, End: Long, [Step: Long = 1], [Count: Long], [Seed:Long = 0]): Array",
        insertText: "RanSequence",
        definitionType: "function",
        returnType: BasicTypeDefinitions.array,
        arguments: [
            {
                name: "Start",
                type: BasicTypeDefinitions.long,
                note: "The first possible value."
            },
            {
                name: "End",
                type: BasicTypeDefinitions.long,
                note: "The last possible value."
            },
            {
                name: "Step",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 1,
                note: "Optional. The increment between consecutive possible values. The default is 1."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The number of items to return. If omitted, negative, or greater than the number of possible values, all items are returned."
            },
            {
                name: "Seed",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The starting point to be used for the random number generator. The default is 0."
            }
        ],
        note: [
            "```ds",
            "RanSequence(Start: Long, End: Long, [Step: Long], [Count: Long], [Seed:Long]): Array",
            "```",
            "-----------------------------------",
            "This function returns an array containing values selected randomly from a given series of integers.",
            "+ `Start`: *Long* - The first possible value.",
            "+ `End`: *Long* - The last possible value.",
            "+ `Step`: *Long* - Optional. The increment between consecutive possible values. The default is 1.",
            "+ `Count`: *Long* - Optional. The number of items to return. If omitted, negative, or greater than the number of possible values, all items are returned.",
            "+ `Seed`: *Long* - Optional. The starting point to be used for the random number generator. The default is 0.",
            "+ `return`: *Array* - An array containing a random selection from the set of possible numbers.",
            "",
            "### Remarks",
            "The `RanSequence` function returns an array containing numbers from the sequence `Start`, `Start + Step`, `Start + Step * 2`, ... , `Start + Step * N` (where *N* is the maximum integer such that the sequence doesn't pass `End`), in a random order. `Step` may be positive or negative. If `Step` is 0, `Count` copies of Start are returned, unless `Count` is omitted or negative, in which case an empty array is returned. If `Step` is positive and `Start > End`, or if `Step` is negative and `Start < End`, an empty array is returned.",
            "The `Start`, `End`, and `Step` arguments define the potential set of numbers to return (for example, a setting of (1, 10, 2) produces the set {1, 3, 5, 7, 9}, while (10, 1, -2) produces {10, 8, 6, 4, 2}). Then the Seed and the starting point for random number generation determine in which order those numbers would be returned. Finally, the `Count` argument controls how much of that ordered set is returned. Provided `Step` is not set to 0, the returned numbers are guaranteed to be unique, so no number occurs more than once in the array.",
            "If `Seed` is non-zero, it is used to reset the starting point for the random number generator, as in `SetRandomSeed`, before the randomization. If Seed is not supplied or has a value of 0, the function will use the starting point stored for the random number generator by the mrScriptBasic engine or Evaluate component and passed as a hidden parameter. Each time you call one of the randomization functions, the starting point stored for the random number generator is updated even if no numbers are returned. This means that if you call the function repeatedly without specifying the `Seed` parameter, the sequence of results is determined by the changing value passed as a hidden parameter. Specifying the Seed parameter is a way of resetting this sequence and means that the sequence of returned values can be repeated. For example, if you use this function to assign random responses to a categorical question, by using the same `Seed` value you could reassign the same responses.",
            "",
            "### Examples",
            "You can use `RanSequence` to generate random responses to a categorical question. To illustrate this, let's consider the Remember and Interest variables in the Museum sample IBM SPSS Data Collection Data File. These are categorical variables that have identical category lists that contain categories for the various museum galleries. The categories that represent the various galleries have mapped category values of 31 through 45. The following query uses the IIf function to test whether the value of the *Interest* variable is *Null*. If the value is *Null*, `RanSequence` is used to assign a single response chosen at random from the possible response values. The multiple response *Remember* variable is handled in a similar way, except three responses are assigned at random.",
            "```sq'",
            "SELECT Respondent.Serial, ",
            "    IIf(Interest IS NULL, RanSequence(31, 45, 1, 1), Interest) AS Interest, ",
            "    IIf(Remember IS NULL, RanSequence(31, 45, 1, 3), Remember) AS Remember ",
            "FROM vdata",
            "```",
            "Here are the results for the first five respondents (for whom the *Interest* and *Remember* variables are *Null* in the case data):",
            "",
            "| Respondent.Serial | Interest       | Remember |",
            "| :---------------- | :------------- | :--------------------------------------- |",
            "| 1                 | {insects}      | {insects,minerals,origin_of_species} |",
            "| 2                 | {ecology}      | {insects,dinosaurs,mammals}  |",
            "| 3                 | {conservation} | {dinosaurs,ecology,whales}   |",
            "| 4                 | {insects}      | {fish_and_reptiles,botany,human_biology} |",
            "| 5                 | {conservation} | {conservation,evolution,whales}  |",
            "",
            "The next example is a snippet of mrScriptBasic that uses `RanSequence` in combination with the `CLong` function to assign to a variable a number taken randomly from a series of numbers. The series of numbers from which the random number is chosen is 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100.",
            "```ds",
            "Dim GroupID",
            "GroupID = CLong(RanSequence(0, 100, 10, 1))",
            "```",
            "This example is provided to illustrate using `RanSequence` in mrScriptBasic and is not necessarily something you will want to do in practice and there are in fact other ways you could achieve the same result. For example:",
            "```ds",
            "GroupID = 10 * CLong(11 * Rnd())",
            "",
            "GroupID = 10 * (RanInt() Mod 11)",
            "```",
        ].join("\n"),
    },
    {
        name: "Rev",
        label: "Rev(List: Variant, [Count: Long], [Policy: Long = 1], [Seed: Long = 0]): Array",
        insertText: "Rev",
        definitionType: "function",
        returnType: BasicTypeDefinitions.array,
        arguments: [
            {
                name: "List",
                type: BasicTypeDefinitions.variant,
                note: "*Array*, *collection*, or *Categorical* value to operate on."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned."
            },
            {
                name: "Policy",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 1,
                note: "Optional. Controls the way the list order is chosen. The default is 1."
            },
            {
                name: "Seed",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 0,
                note: "Optional. The state to be used for the reversal. The default is 0."
            }
        ],
        note: [
            "```ds",
            "(function) Rev(List: Variant, [Count: Long], [Policy: Long], [Seed: Long]): Array",
            "```",
            "-----------------------------------",
            "This function returns an array containing copies of items from the input list, either in the normal order or in reverse order. The optional `Count` parameter defines how many items from the input list are included in the returned list.",
            "+ `List`: *Variant* - *Array*, *collection*, or *Categorical* value to operate on.",
            "+ `Count`: *Long* - Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned.",
            "+ `Policy`: *Long* - Optional. Controls the way the list order is chosen. The default is 1.",
            "+ `Seed`: *Long* - Optional. The state to be used for the reversal. The default is 0.",
            "+ `return`: *Array* - An array consisting of a copy of the input list.",
            "",
            "### Remarks",
            "An error occurs if `List` is a collection that doesn’t support the `For Each...Next` syntax. When List is a collection object, the return value is an array that contains copies of the objects in the collection and the input collection object is unchanged. Because the return value is an array, it does not have a `Count` property.",
            "This function uses the reversal state stored by the mrScriptBasic engine or Evaluate component and passed as a hidden parameter. However, when both `Policy` and `Seed` are nonzero, the reversal state is set to `Seed` before the `Policy` is applied. If the resulting reversal state is even, the list is presented in normal order; if odd, the list is reversed.",
            "The possible values for `Policy` are:",
            "- **0** - No reversal and the reversal state is set to 0.",
            "- **1** - The reversal state is used without changing it.",
            "- **2** - The reversal state is incremented by one and used.",
            "- **3** - 	Use the starting point of the random number generator and update both the reversal state and the random number generator starting point.",
            "The `Rev` function is similar to using the rev keyword in IBM® SPSS® Quancept™.",
            "",
            "### Examples",
            "This example shows using `Rev` with *museums* (which is a multiple response variable in the IBM® SPSS® Data Collection Data File version of the Museum sample data set) in an SQL query. The example uses the `Rev` function four times, each time using a different value for the `Policy` parameter.",
            "```sql",
            "SELECT museums AS Museums, ",
            "    Rev(museums, , 0) AS Policy0, ",
            "    Rev(museums, , 1) AS Policy1, ",
            "    Rev(museums, , 2) AS Policy2, ",
            "    Rev(museums, , 3) AS Policy3 ",
            "FROM vdata WHERE museums.AnswerCount() > 2",
            "```",
            "Here are the results for the first five respondents:",
            "",
            "|       | Museums       | Policy0       | Policy1       | Policy2       | Policy3   |",
            "| :---- | :------------ | :-----------  | :------------ | :------------ | :-----------  |",
            "| 1     | {25,28,29}    | {25,28,29}    | {25,28,29}    | {29,28,25}    | {25,28,29}    |",
            "| 2     | {26,28,29,30} | {26,28,29,30} | {26,28,29,30} | {26,28,29,30} | {26,28,29,30} |",
            "| 3     | {25,26,27}    | {25,26,27}    | {25,26,27}    | {27,26,25}    | {27,26,25}    |",
            "| 4     | {25,28,30}    | {25,28,30}    | {25,28,30}    | {25,28,30}    | {30,28,25}    |",
            "| 5     | {25,26,27}    | {25,26,27}    | {25,26,27}    | {27,26,25}    | {25,26,27}    |",
            "",
            "In the first column, *Museums*, the responses are presented as they are stored in the variable, which is the \"normal\" order. Notice that the responses are also presented in the normal order in the next two columns:",
            "- The second column, *Policy0*, presents the responses in the normal order because `Policy` is set to 0 and `Seed` is not specified. This means that the list is presented in the normal order.",
            "- The third column, *Policy1*, presents the responses in the normal order because `Policy` is set to 1 and `Seed` is not specified. This means that whether the list is reversed or not is determined by the current setting of the reversal state. However, because the `Seed` parameter has not been specified, the reversal state defaults to 0, which is an even number, and so the list is presented in the normal order. If we changed the query to specify the `Seed` parameter as 1, the order would be reversed, because 1 is an odd number.",
            "",
            "In the fourth column, *Policy2*, the list is presented in normal and reverse order alternately. This is because `Policy` is set to 2, which means that each time the function is called, one is added to the reversal state, thus causing it to alternate between odd and even values.",
            "In the fourth column, *Policy3*, the list is presented in normal and reverse orders at random because `Policy` is set to 3. This means that the reversal state is set to a random value each time the function is called. This means that the list is presented in normal and reverse order randomly.",
            "",
        ].join("\n"),
    },
    {
        name: "RevSequence",
        label: "RevSequence(Start: Long, End: Long, [Step: Long = 1], [Count: Long], [Policy: Long = 1], [Seed: Long = 0]): Array",
        insertText: "RevSequence",
        definitionType: "function",
        returnType: BasicTypeDefinitions.array,
        arguments: [
            {
                name: "Start",
                type: BasicTypeDefinitions.long,
                note: "The first possible value."
            },
            {
                name: "End",
                type: BasicTypeDefinitions.long,
                note: "The last possible value."
            },
            {
                name: "Step",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 1,
                note: "Optional. The increment between consecutive possible values. The default is 1.",
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The number of items to return. If omitted, negative, or greater than the number of possible values, all items are returned.",
            },
            {
                name: "Policy",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 1,
                note: "Optional. Controls the way the list order is chosen. The default is 1.",
            },
            {
                name: "Seed",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 0,
                note: "Optional. The state to be used for the reversal. The default is 0.",
            },
        ],
        note: [
            "```ds",
            "(function) RevSequence(Start: Long, End: Long, [Step: Long = 1], [Count: Long], [Policy: Long = 1], [Seed: Long = 0]): Array",
            "```",
            "-----------------------------------",
            "This function returns an array containing values selected from a given series of integers, either in the original order or in reverse order.",
            "+ `Start`: *Long* - The first possible value.",
            "+ `End`: *Long* - The last possible value.",
            "+ `Step`: *Long* - Optional. The increment between consecutive possible values. The default is 1.",
            "+ `Count`: *Long* - Optional. The number of items to return. If omitted, negative, or greater than the number of possible values, all items are returned.",
            "+ `Policy`: *Long* - Optional. Controls the way the list order is chosen. The default is 1.",
            "+ `Seed`: *Long* - Optional. The state to be used for the reversal. The default is 0.",
            "+ `return`: *Array* - An array containing a selection from the set of possible numbers.",
            "",
            "### Remarks",
            "The `RevSequence` function returns an array containing numbers from the sequence `Start`, `Start + Step`, `Start + Step * 2`, ... ,` Start + Step * N` (where N is the maximum integer such that the sequence doesn’t pass `End`), either in the normal order or in reverse order. `Step` may be positive or negative. If `Step` is 0, `Count` copies of Start are returned, unless `Count` is omitted or negative, in which case an empty array is returned. If `Step` is positive and `Start > End`, or if `Step` is negative and `Start < End`, an empty array is returned.",
            "Note that the `Start`, `End`, and `Step` arguments define the potential set of numbers to return (for example, a setting of (1, 10, 2) produces the set {1, 3, 5, 7, 9}, while (10, 1, -2) produces {10, 8, 6, 4, 2}). Then the `Policy` and `Seed` parameters and the reversal state determine in which order those numbers are returned. Finally, the `Count` argument controls how much of that ordered set is returned.",
            "This function uses the reversal state stored by the mrScriptBasic engine or Evaluate component and passed as a hidden parameter. However, when both `Policy` and Seed are nonzero, the reversal state is set to `Seed` before the `Policy` is applied. If the resulting reversal state is even, the list is presented in normal order; if odd, the list is reversed.",
            "The possible values for Policy are:",
            "- **0** - No reversal and the reversal state is set to 0.",
            "- **1** - The reversal state is used without changing it.",
            "- **2** - The reversal state is incremented by one and used.",
            "- **3** - Use the starting point of the random number generator and update both the reversal state and the random number generator starting point.",
            "",
            "### Examples",
            "This example shows using `RevSequence` in an SQL query. The example uses `RevSequence` four times to select five values from the values 1 through 10, each time using a different value for the `Policy` parameter, so that sometimes the values are presented in the normal (specified) order and sometimes in reversed order.",
            "```sql",
            "SELECT",
            "    RevSequence(1, 10, 1, 5, 0) AS Policy0,  ",
            "    RevSequence(1, 10, 1, 5, 1) AS Policy1, ",
            "    RevSequence(1, 10, 1, 5, 2) AS Policy2, ",
            "    RevSequence(1, 10, 1, 5, 3) AS Policy3 ",
            "FROM vdata",
            "```",
            "Here are the results for the first five respondents:",
            "",
            "|       | Policy0     | Policy1     | Policy2      | Policy3 |",
            "| :---- | :---------- | :---------- | :----------- | :----------- |",
            "| 1     | {1,2,3,4,5} | {1,2,3,4,5} | {10,9,8,7,6} | {1,2,3,4,5} |",
            "| 2     | {1,2,3,4,5} | {1,2,3,4,5} | {1,2,3,4,5}  | {1,2,3,4,5} |",
            "| 3     | {1,2,3,4,5} | {1,2,3,4,5} | {10,9,8,7,6} | {10,9,8,7,6} |",
            "| 4     | {1,2,3,4,5} | {1,2,3,4,5} | {1,2,3,4,5}  | {10,9,8,7,6} |",
            "| 5     | {1,2,3,4,5} | {1,2,3,4,5} | {10,9,8,7,6} | {1,2,3,4,5} |",
            "",
            "Notice that the function orders the list of values before selecting the required number of values. The following notes explain how the value of the `Policy` parameter affects the ordering:",
            "- In the first column, *Policy0*, the list is in the normal order because `Policy` is set to 0. This means that the list is always presented in the normal order.",
            "- In the second column, *Policy1*, the list is also in the normal order. This time `Policy` is set to 1, which means that whether the list is reversed or not is determined by the current setting of the reversal state. Since the Seed parameter is not specified, the reversal state remains at its initial value of 0, which is an even number, and so the list is always presented in the normal order. If we changed the query to specify the `Seed` parameter as 1, the order would always be reversed, because 1 is an odd number.",
            "- In the third column, *Policy2*, the list is in normal and reverse order alternately. This is because `Policy` is set to 2, which means that each time the function is called, one is added to the reversal state, thus causing it to alternate between odd and even values.",
            "- In the fourth column, *Policy3*, the list is presented in normal and reverse order at random because `Policy` is set to 3. This means that the reversal state is set to a random value each time the function is called, thus causing it to switch randomly between odd and even values.",
            "",
        ].join("\n"),
    },
    {
        name: "Rot",
        label: "Rot(List: Variant, [Count: Long], [Policy: Long = 2], [Seed: Long = 0]): Array",
        insertText: "Rot",
        definitionType: "function",
        returnType: BasicTypeDefinitions.array,
        arguments: [
            {
                name: "List",
                type: BasicTypeDefinitions.variant,
                note: "*Array*, *collection*, or *Categorical* value to operate on."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned."
            },
            {
                name: "Policy",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 2,
                note: "Optional. Controls the way the rotation is chosen. The default is 2."
            },
            {
                name: "Seed",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 0,
                note: "Optional. The state to be used for the rotation. The default is 0."
            }
        ],
        note: [
            "```ds",
            "(function) Rot(List: Variant, [Count: Long], [Policy: Long = 2], [Seed: Long = 0]): Array",
            "```",
            "-----------------------------------",
            "This function returns an array containing copies of items from the input list, in a rotated order. The optional `Count` parameter defines how many items from the input list are included in the returned list.",
            "+ `List`: *Variant* - *Array*, *collection*, or *Categorical* value to operate on.",
            "+ `Count`: *Long* - Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned.",
            "+ `Policy`: *Long* - Optional. Controls the way the rotation is chosen. The default is 2.",
            "+ `Seed`: *Long* - Optional. The state to be used for the rotation. The default is 0.",
            "+ `return`: *Array* - An array consisting of a copy of the input list.",
            "",
            "### Remarks",
            "An error occurs if `List` is a collection that doesn’t support the `For Each...Next` syntax. When `List` is a collection object, the return value is an array that contains copies of the objects in the collection and the input collection object is unchanged. Because the return value is an array, it does not have a `Count` property.",
            "This function uses the rotation state stored by the mrScriptBasic engine or Evaluate component and passed as a hidden parameter. However, when both `Policy` and `Seed` are nonzero, the rotation state is set to `Seed` before the `Policy` is applied. The resulting rotation state determines which item from the original list is to appear first in the rotated list.",
            "The possible values for `Policy` are:",
            "- **0** - No rotation and the rotation state is set to 0.",
            "- **1** - The rotation state is used without changing it.",
            "- **2** - The rotation state is incremented by one and used.",
            "- **3** - Use the starting point of the random number generator and update both the rotation state and the random number generator starting point.",
            "",
            "The rotation state is used to calculate the number of items by which the list should be \"rotated\". This is called the **offset** and is calculated as follows:",
            "```ds",
            "Rotation_state mod Number_of_items_in_list",
            "```",
            "For example, if the rotation state is 9 and there are 7 items in the list, the first item in the rotated list will be the third item, because the offset is 2 (which is 9 mod 7). However, if there were 5 items in the list, the rotated list would start with the fifth item, because the offset is 4 (which is 9 mod 5).",
            "The `Rot` function is similar to using the rot keyword in IBM® SPSS® Quancept™.",
            "",
            "### Examples",
            "This mrScriptBasic example uses a loop to call the `Rot` function repeatedly using a `Categories` collection object as the input. Note that the function returns an array that contains copies of the objects in the `Categories` collection and does not actually change the order of the objects in the `Categories` collection. Because the return value is an array, it does not have a `Count` property.",
            "```ds",
            "Dim MyDocument, MyCategories, MyElement",
            "Dim Rotated, Counter",
            "",
            "Set MyDocument = CreateObject(\"MDM.Document\")",
            "",
            "MyDocument.Open(\"C:\\Program Files\\IBM\\SPSS\\DataCollection\\6\\DDL\\Data\\Data Collection File\\museum.mdd\", , _",
            "    MDMLib.openConstants.oREAD)",
            "",
            "Set MyCategories = MyDocument.Fields[\"museums\"].Categories",
            "",
            "For Each MyElement in MyCategories",
            "    Debug.Log(MyElement.Name)",
            "Next",
            "",
            "For Counter = 0 To 6",
            "    Debug.Log(mr.NewLine)",
            "    Set Rotated = MyCategories.Rot(, 2)",
            "    For Each MyElement in Rotated",
            "        Debug.Log(myElement.Name)",
            "    Next",
            "Next",
            "```",
            "Here is the output:",
            "```ds",
            "National_Museum_of_Science",
            "Museum_of_Design",
            "Institute_of_Textiles_and_Fashion",
            "Archeological_Museum",
            "National_Art_Gallery",
            "Northern_Gallery",
            "Other",
            "Not_answered",
            "",
            "",
            "Museum_of_Design",
            "Institute_of_Textiles_and_Fashion",
            "Archeological_Museum",
            "National_Art_Gallery",
            "Northern_Gallery",
            "Other",
            "Not_answered",
            "National_Museum_of_Science",
            "",
            "",
            "Institute_of_Textiles_and_Fashion",
            "Archeological_Museum",
            "National_Art_Gallery",
            "Northern_Gallery",
            "Other",
            "Not_answered",
            "National_Museum_of_Science",
            "Museum_of_Design",
            "",
            "",
            "Archeological_Museum",
            "National_Art_Gallery",
            "Northern_Gallery",
            "Other",
            "Not_answered",
            "National_Museum_of_Science",
            "Museum_of_Design",
            "Institute_of_Textiles_and_Fashion",
            "",
            "",
            "National_Art_Gallery",
            "Northern_Gallery",
            "Other",
            "Not_answered",
            "National_Museum_of_Science",
            "Museum_of_Design",
            "Institute_of_Textiles_and_Fashion",
            "Archeological_Museum",
            "",
            "",
            "Northern_Gallery",
            "Other",
            "Not_answered",
            "National_Museum_of_Science",
            "Museum_of_Design",
            "Institute_of_Textiles_and_Fashion",
            "Archeological_Museum",
            "National_Art_Gallery",
            "",
            "",
            "Other",
            "Not_answered",
            "National_Museum_of_Science",
            "Museum_of_Design",
            "Institute_of_Textiles_and_Fashion",
            "Archeological_Museum",
            "National_Art_Gallery",
            "Northern_Gallery",
            "",
            "",
            "Not_answered",
            "National_Museum_of_Science",
            "Museum_of_Design",
            "Institute_of_Textiles_and_Fashion",
            "Archeological_Museum",
            "National_Art_Gallery",
            "Northern_Gallery",
            "Other",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "RotSequence",
        label: "RotSequence(Start: Long, End: Long, [Step: Long = 1], [Count: Long], [Policy: Long = 2], [Seed: Long]): Array",
        insertText: "RotSequence",
        definitionType: "function",
        returnType: BasicTypeDefinitions.array,
        arguments: [
            {
                name: "Start",
                type: BasicTypeDefinitions.long,
                note: "The first possible value."
            },
            {
                name: "End",
                type: BasicTypeDefinitions.long,
                note: "The last possible value."
            },
            {
                name: "Step",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 1,
                note: "Optional. The increment between consecutive possible values. The default is 1."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The number of items to return. If omitted, negative, or greater than the number of possible values, all items are returned."
            },
            {
                name: "Policy",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 2,
                note: "Optional. Controls the way the rotation is performed. The default is 2."
            },
            {
                name: "Seed",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The state to be used for the rotation. The default is the value acquired from the `GetRotationSeed()` function."
            }
        ],
        note: [
            "```ds",
            "(function) RotSequence(Start: Long, End: Long, [Step: Long = 1], [Count: Long], [Policy: Long = 2], [Seed: Long]): Array",
            "```",
            "-----------------------------------",
            "This function returns an array containing values selected from a given series of integers in a \"rotated\" order.",
            "+ `Start`: *Long* - The first possible value.",
            "+ `End`: *Long* - The last possible value.",
            "+ `Step`: *Long* - Optional. The increment between consecutive possible values. The default is 1.",
            "+ `Count`: *Long* - Optional. The number of items to return. If omitted, negative, or greater than the number of possible values, all items are returned.",
            "+ `Policy`: *Long* - Optional. Controls the way the rotation is performed. The default is 2.",
            "+ `Seed`: *Long* - Optional. The state to be used for the rotation. The default is the value acquired from the `GetRotationSeed()` function.",
            "+ `return`: *Array* - An array containing a rotated selection from the set of possible numbers.",
            "",
            "### Remarks",
            "The `RotSequence` function returns an array containing numbers from the sequence `Start, Start + Step, Start + Step * 2, ... , Start + Step * N` (where *N* is the maximum integer such that the sequence doesn’t pass `End`) in a \"rotated\" order. `Step` may be positive or negative. If `Step` is 0, `Count` copies of `Start` are returned, unless `Count` is omitted or negative, in which case an empty array is returned. If `Step` is positive and `Start > End`, or if `Step` is negative and `Start < End`, an empty array is returned.",
            "Note that the `Start`, `End`, and `Step` arguments define the potential set of numbers to return (for example, a setting of (1, 10, 2) produces the set {1, 3, 5, 7, 9}, while (10, 1, -2) produces {10, 8, 6, 4, 2}). Then the `Policy` and `Seed` parameters and the rotation state determine in which order those numbers are returned. Finally, the `Count` argument controls how much of that ordered set is returned.",
            "This function uses the rotation state stored by the mrScriptBasic engine or Evaluate component and passed as a hidden parameter. However, when both `Policy` and `Seed` are nonzero, the rotation state is set to `Seed` before the `Policy` is applied. The resulting rotation state determines which item from the original list is to appear first in the rotated list.",
            "The possible values for *Policy* are:",
            "- **0** - No rotation and the rotation state is set to 0.",
            "- **1** - The rotation state is used without changing it.",
            "- **2** - The rotation state is incremented by one and used.",
            "- **3** - Use the starting point of the random number generator and update both the rotation state and the random number generator starting point.",
            "",
            "The rotation state is used to calculate the number of items by which the list should be \"rotated\". This is called the offset and is calculated as follows:",
            "```ds",
            "Rotation_state mod Number_of_items_in_list",
            "```",
            "For example, if the rotation state is 9 and there are 7 items in the list, the rotated list will start with the third item from the original list, because the offset is 2 (which is 9 mod 7). However, if there were 5 items in the list, the rotated list would start with the fifth item from the original list, because the offset is 4 (which is 9 mod 5).",
            "",
            "### Examples",
            "This example shows using `RotSequence` in an SQL query.",
            "```sql",
            "SELECT Respondent.Serial, ",
            "    RotSequence(1, 5, 1, 5, 2) AS RotSequence ",
            "FROM vdata",
            "```",
            "Here are the results for the first seven respondents:",
            "",
            "| Respondent.Serial | RotSequence |",
            "| :---------------- | :---------- |",
            "| 1                 | {2,3,4,5,1} |",
            "| 2                 | {3,4,5,1,2} |",
            "| 3                 | {4,5,1,2,3} |",
            "| 4                 | {5,1,2,3,4} |",
            "| 5                 | {1,2,3,4,5} |",
            "| 6                 | {2,3,4,5,1} |",
            "| 7                 | {3,4,5,1,2} |",
            "",
            "In this example, the `Count` parameter has been set to the same value as the number of input values. This is deliberately simplistic and is designed to make it clear how the function works. In \"real life\", you may want to return fewer values than are input. For example:",
            "```sql",
            "SELECT Respondent.Serial, ",
            "    RotSequence(1, 14, 2, 5, 2) AS RotSequence ",
            "FROM vdata",
            "```",
            "Here are the results for the first seven respondents:",
            "",
            "| Respondent.Serial | RotSequence |",
            "| :---------------- | :------------ |",
            "| 1                 | {3,5,7,9,11} |",
            "| 2                 | {5,7,9,11,13} |",
            "| 3                 | {7,9,11,13,1} |",
            "| 4                 | {9,11,13,1,3} |",
            "| 5                 | {11,13,1,3,5} |",
            "| 6                 | {13,1,3,5,7} |",
            "| 7                 | {1,3,5,7,9} |",
            "",
        ].join("\n"),
    },
    {
        name: "SelectRange",
        label: "SelectRange(List: Variant, [Range: Variant], [Count: Long]): Categorical",
        insertText: "SelectRange",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "List",
                type: BasicTypeDefinitions.variant,
                note: "*Array*, *collection* or *Categorical* value to operate on."
            },
            {
                name: "Range",
                type: BasicTypeDefinitions.variant,
                optional: true,
                note: "*Text*, *Long* or *Categorical* value for selecting list items."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. Number of items to return. If omitted, negative, or greater than the maximum number of items selected by `Range`, all selected items are returned."
            }
        ],
        note: [
            "```ds",
            "(function) SelectRange(List: Variant, [Range: Variant], [Count: Long]): Categorical",
            "```",
            "-----------------------------------",
            "This function returns an array containing copies of selected items from the input list, in the same order as in the list.",
            "+ `List`: *Variant* - *Array*, *collection* or *Categorical* value to operate on.",
            "+ `Range`: *Variant* - *Text*, *Long* or *Categorical* value for selecting list items.",
            "+ `Count`: *Long* - Optional. Number of items to return. If omitted, negative, or greater than the maximum number of items selected by `Range`, all selected items are returned.",
            "+ `return`: *Categorical* - *Array* containing a selection of items from the list.",
            "",
            "### Remarks",
            "If `List` is a collection, an error occurs if it does not support _NewEnum (that is, `for each ... next`). If `List` is *NULL*, an empty array is returned.",
            "If `Range` is of type *Categorical*, the values within it are taken as positional indexes of items in `List`, as described below. If `Range` is of type *Long*, it is taken as a single positional index. If `Range` is of type *Text*, it is assumed to be a range expression, of the same syntax as a category expression. Numbers in the range expression refer to positional indexes of items in `List`; names are used to identify list items as described below. If `Range` is *NULL*, all list items are returned. If `Range` is of any other type, an error occurs.",
            "Positional indexes start at 0 for the first item in `List`. Indexes less than zero or greater than or equal to the number of items in `List` are ignored. For example, in a list of 4 items, a range of \"-1..10\" will select all items, the same as \"0..3\" or \"..\".",
            "The way names in the range expression are used depends on the type of the items in `List`:",
            "- For a **string** item, the name is simply compared with the string.",
            "- For an item that is an **object**, the name is first compared with the value of the object's Name property, if it has one. This property is not necessarily called \"Name\", but it is defined internally as representing a name for the object. In COM, this is done by giving the property a Dispatch identifier of -800. If the object has no Name property, the name is compared with the value of the object's default property. If the object has no Name or default properties, or their values cannot be determined, or the value is not a string, an error occurs.",
            "- For any **other** type of item, an error occurs if `Range` contains item names. In particular, if `List` is a *Categorical* value, only numeric (positional) indexes can be used, not category values or names.",
            "",
            "When comparing names, differences between upper and lower case are ignored. Like out-of-range indexes, any name in Range that does not match an item in `List` is ignored. For example, if an item called \"Good\" exists but no item called \"Bad\", then the range expression \"Good..Bad\" is equivalent to \"Good..\" (selecting all items from \"Good\" to the end of `List`), \"Bad\" will select no items, \"^Bad\" will select all items, and \"^Bad, Good\" will select only \"Good\".",
            "",
            "### Examples",
            "",
            "| Function call            | List                           | Range               | Result |",
            "| :---------------------   | :------------------            | :--------------     | :---------- |",
            "| SelectRange(List, Range) | {8,5,7,1,3,2,9}                | 2                   | {7} |",
            "| SelectRange(List, Range) | {8,5,7,1,3,2,9}                | {2,4}               | {7,3} |",
            "| SelectRange(List, Range) | {8,5,7,1,3,2,9}                | \"2 .. 4\"          | {7,1,3} |",
            "| SelectRange(List, Range) | {8,5,7,1,3,2,9}                | \"2 .., ^4\"        | {7,1,2,9} |",
            "| SelectRange(List, Range) | Split(\"The quick brown fox\") | 3                   | {fox} |",
            "| SelectRange(List, Range) | Split(\"The quick brown fox\") | \"quick .. jumped\" | {quick,brown,fox} |",
            "",
            "| Function call                   | List                           | Range    | Count  | Result |",
            "| :-----------------------        | :-------------------           | :------- | :----- | :-------- |",
            "| SelectRange(List, Range, Count) | {8,5,7,1,3,2,9}                | \"2 ..\" | 4      | {7,1,3,2} |",
            "| SelectRange(List, Range, Count) | {8,5,7,1,3,2,9}                | NULL     | 5      | {8,5,7,1,3} |",
            "| SelectRange(List, Range, Count) | Split(\"The quick brown fox\") | NULL     | 2      | {The,quick} |",
            "",
            "The `Split` function is used in some of these examples to create an array of substrings that SelectRange can operate on.",
        ].join("\n"),
    },
    {
        name: "SetReversalSeed",
        label: "SetReversalSeed([Seed: Long = 0]): Long",
        insertText: "SetReversalSeed",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Seed",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 0,
                note: "Optional. State to use for reversals. The default is 0."
            }
        ],
        note: [
            "```ds",
            "(function) SetReversalSeed([Seed: Long = 0]): Long",
            "```",
            "-----------------------------------",
            "This function sets the reversal state. This is stored by the mrScript engine and Evaluate component and passed to the `Rev` function.",
            "+ `Seed`: *Long* - Optional. State to use for reversals. The default is 0.",
            "+ `return`: *Long* - New state for reversals.",
            "",
            "### Remarks",
            "`Seed` can be any Long value, positive, zero, or negative. If `Seed` is not supplied or has a value of 0, a random number is used.",
            "",
            "### Examples",
            "This example sets the reversal state to 3.",
            "```ds",
            "SetReversalSeed(3)",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "SetRotationSeed",
        label: "SetRotationSeed([Seed: Long = 0]): Long",
        insertText: "SetRotationSeed",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Seed",
                type: BasicTypeDefinitions.long,
                optional: true,
                defaultValue: 0,
                note: "Optional. Rotation state value. The default is 0."
            }
        ],
        note: [
            "```ds",
            "(function) SetRotationSeed([Seed: Long = 0]): Long",
            "```",
            "-----------------------------------",
            "This function sets the rotation state. This is stored by the mrScript engine and Evaluate component and passed to the `Rot` function.",
            "+ `Seed`: *Long* - Optional. Rotation state value. The default is 0.",
            "+ `return`: *Long* - New rotation state value.",
            "",
            "### Remarks",
            "`Seed` can be any Long value, positive, zero, or negative. This function sets the rotation state for the `Rot` function.",
            "",
            "### Examples",
            "This example sets the starting point for rotations to 3.",
            "```ds",
            "SetRotationSeed(3)",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "SortAsc",
        label: "SortAsc(List: Variant, [Count: Long], [IgnoreLocale: Boolean]): Array",
        insertText: "SortAsc",
        definitionType: "function",
        returnType: BasicTypeDefinitions.array,
        arguments: [
            {
                name: "List",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* - *Array*, *collection*, or *Categorical* value to operate on."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                note: "Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned."
            },
            {
                name: "IgnoreLocale",
                type: BasicTypeDefinitions.boolean,
                note: "Optional. When *True*, the rules of the input locale are ignored when sorting text and the text is sorted in a language-neutral way. The default is *False*."
            }
        ],
        note: [
            "```ds",
            "(function) SortAsc(List: Variant, [Count: Long], [IgnoreLocale: Boolean]): Array",
            "```",
            "-----------------------------------",
            "This function returns an array containing copies of items from the input list, sorted in ascending order. The optional `Count` parameter defines how many items from the input list are included in the returned list.",
            "+ `List`: *Variant* - *Array*, *collection*, or *Categorical* value to operate on.",
            "+ `Count`: *Long* - Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned.",
            "+ `IgnoreLocale`: *Boolean* - Optional. When *True*, the rules of the input locale are ignored when sorting text and the text is sorted in a language-neutral way. The default is *False*.",
            "+ `return`: *Array* - An array consisting of a sorted copy of the input list.",
            "",
            "### Remarks",
            "An error occurs if `List` is a collection that doesn’t support the `For Each...Next` syntax. When `List` is a collection object, the return value is an array that contains copies of the objects in the collection and the input collection object is unchanged. Because the return value is an array, it does not have a `Count` property.",
            "The sorting method depends on the type of the items in the list. If they are simple *Long*, *Double*, *Text*, *Date*, or *Boolean* values, they are sorted in ascending order. When sorting *Boolean* values, `SortAsc` considers *False* to be less than *True*.",
            "If the items are objects, they are sorted by the value of their default property. An error occurs if the objects do not have a default property or its value cannot be determined.",
            "The input locale is used to determine the correct ordering for text values, unless IgnoreLocale is True, when the sorting is performed in a locale-independent way. The locale-independent sort is case-sensitive and is likely to give unexpected results. When the input locale is used, the sort is always case-insensitive. Note that items with the same equivalent values may not appear in the same relative order in the sorted list as in the original list.",
            "",
            "### Examples",
            "The following mrScriptBasic example writes the short and long names of each language in the MDM Languages collection to a text file two times. First in the order in which they appear in the collection and then after using `SortAsc` to sort the collection in ascending order. The collection is sorted in ascending order of the three-character language codes stored in the Name property because it is the default property of the `Language` object.",
            "```ds",
            "Dim MyDocument, MyLanguage, Sorted",
            "",
            "Set MyDocument = CreateObject(\"MDM.Document\")",
            "",
            "MyDocument.Open(\"C:\\Program Files\\IBM\\SPSS\\DataCollection\\6\\DDL\\Scripts\\Interview\\Projects\\Museum\\Museum.backup.mdd\", , _",
            "    MDMLib.openConstants.oREAD)",
            "",
            "For Each MyLanguage in MyDocument.Languages",
            "    Debug.Log(MyLanguage.Name + \": \" + MyLanguage.LongName)",
            "Next",
            "",
            "Debug.Log(\" \")",
            "",
            "Set Sorted = SortAsc(MyDocument.Languages)",
            "",
            "For Each MyLanguage in Sorted",
            "    Debug.Log(MyLanguage.Name + \": \" + MyLanguage.LongName)",
            "Next",
            "```",
            "Here is the output:",
            "```ds",
            "CHS: Chinese (China)",
            "ZHH: Chinese (Hong Kong SAR)",
            "ENU: English (United States)",
            "ESN: Spanish (International Sort)",
            "JPN: Japanese",
            "KOR: Korean",
            "THA: Thai",
            " ",
            "CHS: Chinese (China)",
            "ENU: English (United States)",
            "ESN: Spanish (International Sort)",
            "JPN: Japanese",
            "KOR: Korean",
            "THA: Thai",
            "ZHH: Chinese (Hong Kong SAR)",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "SortDesc",
        label: "SortDesc(List: Variant, [Count: Long], [IgnoreLocale: Boolean]): Array",
        insertText: "SortDesc",
        definitionType: "function",
        returnType: BasicTypeDefinitions.array,
        arguments: [
            {
                name: "List",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* - *Array*, *collection*, or *Categorical* value to operate on."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                note: "Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned."
            },
            {
                name: "IgnoreLocale",
                type: BasicTypeDefinitions.boolean,
                note: "Optional. When *True*, the rules of the input locale are ignored when sorting text and the text is sorted in a language-neutral way. The default is *False*."
            }
        ],
        note: [
            "```ds",
            "(function) SortDesc(List: Variant, [Count: Long], [IgnoreLocale: Boolean]): Array",
            "```",
            "-----------------------------------",
            "This function returns an array containing copies of items from the input list, sorted in descending order. The optional `Count` parameter defines how many items from the input list are included in the returned list.",
            "+ `List`: *Variant* - *Array*, *collection*, or *Categorical* value to operate on.",
            "+ `Count`: *Long* - Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned.",
            "+ `IgnoreLocale`: *Boolean* - Optional. When *True*, the rules of the input locale are ignored when sorting text and the text is sorted in a language-neutral way. The default is *False*.",
            "+ `return`: *Array* - An array consisting of a sorted copy of the input list.",
            "",
            "### Remarks",
            "An error occurs if `List` is a collection that doesn’t support the `For Each...Next` syntax. When `List` is a collection object, the return value is an array that contains copies of the objects in the collection and the input collection object is unchanged. Because the return value is an array, it does not have a `Count` property.",
            "The sorting method depends on the type of the items in the list. If they are simple *Long*, *Double*, *Text*, *Date*, or *Boolean* values, they are sorted in descending order. When sorting *Boolean* values, `SortAsc` considers *False* to be less than *True*.",
            "If the items are objects, they are sorted by the value of their default property. An error occurs if the objects do not have a default property or its value cannot be determined.",
            "The input locale is used to determine the correct ordering for text values, unless IgnoreLocale is True, when the sorting is performed in a locale-independent way. The locale-independent sort is case-sensitive and is likely to give unexpected results. When the input locale is used, the sort is always case-insensitive. Note that items with the same equivalent values may not appear in the same relative order in the sorted list as in the original list.",
            "",
            "### Examples",
            "This example shows using `SortDesc` in an SQL query to sort the responses given to a multiple response question.",
            "```sql",
            "SELECT Respondent.Serial, ",
            "    Remember, ",
            "    Remember.SortDesc() AS 'Remember.SortDesc' ",
            "FROM vdata",
            "WHERE Remember IS NOT NULL",
            "```",
            "Here is the result set for the first five respondents:",
            "",
            "| Respondent.Serial | Remember                           | Remember.SortDesc |",
            "| :---------------- | :--------------------------------  | :--------------------------------- |",
            "| 305               | {31,33,34,38,39,44,18}             | {44,39,38,34,33,31,18} |",
            "| 306               | {31,33,34,38,39,40,42,18}          | {42,40,39,38,34,33,31,18} |",
            "| 307               | {31,34,35,36,37,38,39,42,43,44,18} | {44,43,42,39,38,37,36,35,34,31,18} |",
            "| 308               | {31,32,35,38,39,18}                | {39,38,35,32,31,18} |",
            "| 309               | {31,35,39,43,44}                   | {44,43,39,35,31} |",
            "| 310               | {31,35,37,38,42,43,18}             | {43,42,38,37,35,31,18} |",
            "",
        ].join("\n"),
    },
    {
        name: "Abs",
        label: "Abs(Val: Double): Double",
        insertText: "Abs",
        definitionType: "function",
        returnType: BasicTypeDefinitions.double ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.double,
                note: "A numeric value."
            }
        ],
        note: [
            "```ds",
            "(function) Abs(Val: Double): Double",
            "```",
            "-----------------------------------",
            "Returns the absolute value of a number.",
            "+ `Val`: *Double* - A numeric value.",
            "+ `return`: *Double* - `Val` with any negative sign removed.",
            "",
            "### Remarks",
            "If `Val` is negative, the return value is `-Val`, otherwise the return value is `Val`. If the current data value is *NULL*, `Val` is 0.0 and the return value is 0.0.",
            "This function is similar to the `Abs` function in VBScript.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the `Abs` function to get the absolute value of two numbers:",
            "```ds",
            "Dim MyPositiveNumber, MyNegativeNumber",
            "",
            "MyPositiveNumber = Abs(150)       ' Returns 150",
            "MyNegativeNumber = Abs(-150)      ' Returns 150",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "Atn",
        label: "Atn(Val: Double): Double",
        insertText: "Atn",
        definitionType: "function",
        returnType: BasicTypeDefinitions.double ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.double,
                note: "A numeric value that represents the ratio of the two shorter sides of a right-angled triangle. (The ratio is the length of the side opposite a particular angle divided by the length of the side adjacent to the angle.)"
            }
        ],
        note: [
            "```ds",
            "(function) Atn(Val: Double): Double",
            "```",
            "-----------------------------------",
            "Returns the arctangent of a number.",
            "+ `Val`: *Double* - A numeric value that represents the ratio of the two shorter sides of a right-angled triangle. (The ratio is the length of the side opposite a particular angle divided by the length of the side adjacent to the angle.)",
            "+ `return`: *Double* - Arctangent of `Val`.",
            "",
            "### Remarks",
            "The return value is the angle in radians whose tangent is `Val` and which is in the range -pi/2 to pi/2. If the current data value is *NULL*, `Val` is 0.0 and the return value is 0.0.",
            "This function is similar to the `Atn` function in VBScript.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the Atn function to get the arctangent of a number that represents the ratio of two sides of a right-angled triangle:",
            "```ds",
            "Dim MyArcTangent",
            "",
            "MyArcTangent = Atn(12.0/5.0)   ' Returns 1.17600520709514",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "Cos",
        label: "Cos(Val: Double): Double",
        insertText: "Cos",
        definitionType: "function",
        returnType: BasicTypeDefinitions.double ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.double,
                note: "A numeric value that represents an angle in radians."
            }
        ],
        note: [
            "```ds",
            "(function) Cos(Val: Double): Double",
            "```",
            "-----------------------------------",
            "Returns the cosine of an angle.",
            "+ `Val`: *Double* - A numeric value that represents an angle in radians.",
            "+ `return`: *Double* - Cosine of `Val`.",
            "",
            "### Remarks",
            "The `Cos` function takes an angle in a right-angled triangle and returns a value that corresponds to the length of the side adjacent to the angle divided by the length of the hypotenuse.",
            "If the current data value is *NULL*, `Val` is 0.0 and the return value is 1.0.",
            "This function is similar to the `Cos` function in VBScript.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the `Cos` function to get the cosine of an angle:",
            "```ds",
            "Dim MyCosine",
            "",
            "MyCosine = Cos(2.7)     ' Returns -0.904072142017061",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "Exp",
        label: "Exp(Val: Double): Double",
        insertText: "Exp",
        definitionType: "function",
        returnType: BasicTypeDefinitions.double ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.double,
                note: "A numeric value."
            }
        ],
        note: [
            "```ds",
            "(function) Exp(Val: Double): Double",
            "```",
            "-----------------------------------",
            "Returns e (the base of natural logarithms) raised to a power.",
            "+ `Val`: *Double* - A numeric value.",
            "+ `return`: *Double* - *e* to the power of `Val`.",
            "",
            "### Remarks",
            "The return value is *e* (the base of natural logarithms) raised to the power of `Val`. If the current data value is *NULL*, `Val` is 0.0 and the return value is 1.0.",
            "When `Val` is a large number, the return value can have more digits than can be accurately represented by the *Double* data type. However, the function does not check for this and does not issue an error when this happens. This function is therefore unsuitable for use with positive values greater than about 709 or negative values less than about -745.",
            "This function is similar to the `Exp` function in VBScript.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the `Exp` function to return e raised to a power:",
            "```ds",
            "Dim MyNumber, MyBigNumber1, MyBigNumber2, MyBigNegativeNumber1, MyBigNegativeNumber2",
            "",
            "MyNumber = Exp(1.32581766366803)         ' Returns 3.76526281526936",
            "MyBigNumber1 = Exp(709.782712893)        ' Returns 1.79769313417214E+308",
            "MyBigNumber2 = Exp(709.782712894)        ' Returns 1.#INF, which indicates \"overflow\"",
            "MyBigNegativeNumber1 = Exp(-744.44007)   ' Returns 4.94065645841247E-324",
            "MyBigNegativeNumber2 = Exp(-745.2)       ' Returns 0, which indicates \"underflow\"",
            "```",
            "The next example demonstrates using the `Exp` and `Log` functions to return *x* to the power of *y* (when *x* is greater than zero):",
            "```ds",
            "Dim x, y, XToThePowerOfY",
            "",
            "XToThePowerOfY = Exp(Log(x) * y)",
            "```",
            "Note that this example is not suitable when *x* is negative because the parameter to the `Log` function must be a positive number.",
            "The next example demonstrates using the `Exp` and `Log` functions to return the cube root of *x*:",
            "```ds",
            "Dim x, CubeRootOfX",
            "",
            "If x > 0 Then",
            "   CubeRootOfX = Exp(Log(x) / 3)",
            "ElseIf x < 0 Then",
            "   CubeRootOfX = - Exp(Log(-x) / 3)",
            "Else ",
            "   CubeRootOfX = 0",
            "End If",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "Int",
        label: "Int(Val: Double): Long",
        insertText: "Int",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.double,
                note: "A numeric value."
            }
        ],
        note: [
            "```ds",
            "(function) Int(Val: Double): Long",
            "```",
            "-----------------------------------",
            "Returns the integer portion of a number.",
            "+ `Val`: *Double* - A numeric value.",
            "+ `return`: *Long* - The greatest integer that is less than or equal to `Val`.",
            "",
            "### Remarks",
            "An error occurs if `Val` is outside the range of integer values that can be stored in the Long data type (-2,147,483,648 to 2,147,483,647). If the current data value is *NULL*, `Val` is 0.0 and the return value is 0.",
            "This function is similar to the `Int` function in VBScript.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the `Int` function to return the integer portion of a number:",
            "```ds",
            "Dim MyInteger1, MyInteger2, MyInteger3",
            "",
            "MyInteger1 = Int(9.88)              ' Returns 9",
            "MyInteger2 = Int(-9.88)             ' Returns -10",
            "MyInteger3 = Int(12345678901234.89) ' Error",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "Log",
        label: "Log(Val: Double, [Base: Double]): Double",
        insertText: "Log",
        definitionType: "function",
        returnType: BasicTypeDefinitions.double ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.double,
                note: "A numeric value."
            },
            {
                name: "Base",
                type: BasicTypeDefinitions.double,
                optional: true,
                note: "Optional. The base for the logarithm. If omitted or <= 0.0, e is used."
            }
        ],
        note: [
            "```ds",
            "(function) Log(Val: Double, [Base: Double]): Double",
            "```",
            "-----------------------------------",
            "Returns the logarithm of a number.",
            "+ `Val`: *Double* - A numeric value.",
            "+ `Base`: *Double* - Optional. The base for the logarithm. If omitted or <= 0.0, e is used.",
            "+ `return`: *Double* - Logarithm of `Val`.",
            "",
            "### Remarks",
            "The logarithm is the power to which `Base` must be raised to get `Val`. If `Base` is not specified, base e is used to return the natural logarithm of `Val`. `Base` e is approximately 2.718282.",
            "An error occurs if `Val` is negative or if `Base` is 1.0 (as 1.0 raised to any power is always 1.0). If `Val` is 0.0, the return value is 0.0. If the current data value is *NULL*, `Val` is 0.0 and the return value is 0.0.",
            "This function is similar to the `Log` function in VBScript.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the Log function to return the natural logarithm of 15, and the logarithm of 15 to the base of 10:",
            "```ds",
            "Dim MyNaturalLogarithm, MyLog10",
            "",
            "MyNaturalLogarithm = Log(15)    ' Returns 2.70805020110221",
            "",
            "MyLog10 = Log(15, 10)",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "MaxOf",
        label: "MaxOf(Val1: Variant, [Vals: Variant ...]): Variant",
        insertText: "MaxOf",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "Val1",
                type: BasicTypeDefinitions.variant,
                note: "First data value."
            },
            {
                name: "Vals",
                type: BasicTypeDefinitions.variant,
                ellipsis: true,
                optional: true,
                note: "Variable number of other values."
            }
        ],
        note: [
            "```ds",
            "(function) MaxOf(Val1: Variant, [Vals: Variant ...]): Variant",
            "```",
            "-----------------------------------",
            "Returns the highest value from a list of values.",
            "+ `Val1`: *Variant* - First data value.",
            "+ `Vals`: *Variant* - Variable number of other values.",
            "+ `return`: *Variant* - The maximum of all values.",
            "",
            "### Remarks",
            "The `MaxOf` function compares non-null values and returns the highest value. If all values are null, the return value is null. If no other values are supplied, the return value is `Val1`. For values of type *Object*, the value of the object's default property is used.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the `MaxOf` function to get the highest of a number of values:",
            "```ds",
            "MaxOf(8, 9.2, 24, 1.75)",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "MinOf",
        label: "MinOf(Val1: Variant, [Vals: Variant ...]): Variant",
        insertText: "MinOf",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "Val1",
                type: BasicTypeDefinitions.variant,
                note: "First data value."
            },
            {
                name: "Vals",
                type: BasicTypeDefinitions.variant,
                ellipsis: true,
                optional: true,
                note: "Variable number of other values."
            }
        ],
        note: [
            "```ds",
            "(function) MinOf(Val1: Variant, [Vals: Variant ...]): Variant",
            "```",
            "-----------------------------------",
            "Returns the lowest value from a list of values.",
            "+ `Val1`: *Variant* - First data value.",
            "+ `Vals`: *Variant* - Variable number of other values.",
            "+ `return`: *Variant* - The minimum of all values.",
            "",
            "### Remarks",
            "The `MinOf` function compares non-null values and returns the lowest value. If all values are null, the return value is null. If no other values are supplied, the return value is `Val1`. For values of type *Object*, the value of the object's default property is used.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the `MinOf` function to get the lowest of a number of values:",
            "```ds",
            "MinOf(8, 9.2, 24, 1.75)",
            "```",
        ].join("\n"),
    },
    {
        name: "Round",
        label: "Round(Val: Double, [Digits: Long], [Policy: Long]): Double",
        insertText: "Round",
        definitionType: "function",
        returnType: BasicTypeDefinitions.double ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.double,
                note: "The value to be rounded.",
            },
            {
                name: "Digits",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The number of decimal places or significant digits in the result. Treated as 0 if omitted or is < 0.",
            },
            {
                name: "Policy",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The type of rounding to use as described in the table below. Treated as 0 if omitted or is < 0."
            }
        ],
        note: [
            "```ds",
            "(function) Round(Val: Double, [Digits: Long], [Policy: Long]): Double",
            "```",
            "-----------------------------------",
            "Returns a number rounded to a specified number of decimal places or significant digits.",
            "+ `Val`: *Double* - The value to be rounded.",
            "+ `Digits`: *Long* - Optional. The number of decimal places or significant digits in the result. Treated as 0 if omitted or is < 0.",
            "+ `Policy`: *Long* - Optional. The type of rounding to use as described in the table below. Treated as 0 if omitted or is < 0.",
            "+ `return`: *Double* - `Val` rounded as specified.",
            "",
            "### Remarks",
            "The return value is the number nearest to `Val` with either the required number of digits after the decimal point or the required number of significant digits, depending on `Policy`. If `Policy` is 0, `Val` is rounded to the number of decimal places specified by `Digit`. If `Policy` is 0 and `Val` is exactly halfway between two possible rounded values (a \"borderline\" case) then this function performs **round to even**. This means that of the two possible rounded values, the one that has an even number as the last significant digit is returned. For example, 15.25 is rounded to 15.2 rather than 15.3.",
            "`Policy` can also be set to any combination of the values in the following table. To combine values, add them together:",
            "- **1** - Round `Val` to a number of significant digits rather than to a number of decimal places.",
            "- **2** - If `Val` is exactly halfway between the two nearest values of the required precision, round to the higher value rather than rounding to even. However, if value 4 below is also set, round to the lower value of the two nearest values.",
            "- **4** - If `Val` is exactly halfway between the two nearest values of the required precision, round to odd rather than rounding to even. However, if value 2 above is also set, round to the lower of the two nearest values.",
            "- **8** - If `Val` is negative and exactly halfway between the two nearest values of the required precision, round the absolute value and make its sign negative. If this value is set, \"higher\" and \"lower\" in values 2 and 4 above means \"having a larger absolute value\" and \"having a smaller absolute value\" respectively. This value has no effect if value 2 is not set.",
            "",
            "If `Val` is 0.0, the return value is 0.0. If the current data value is *NULL*, `Val` is 0.0 and the return value is 0.0.",
            "If `Digits` is 0 and `Policy` is 0 or an even number, Val is rounded to an integer. If `Digits` is 0 and `Policy` is an odd number, `Val` is rounded to one significant digit.",
            "",
            "### Examples",
            "",
            "| Function call      | Val       | Digits  | Result  | Notes |",
            "| :----------------  | :-------  | :------ | :------ | :------------- |",
            "| Round(Val, Digits) | 1234.5678 | 2       | 1234.57 | Rounded to 2 decimal places |",
            "| Round(Val, Digits) | 28.613    | 1       | 28.6    | Rounded to 1 decimal place |",
            "| Round(Val, Digits) | 62.75     | 1       | 62.8    | Borderline case, rounded to even |",
            "| Round(Val, Digits) | 62.85     | 1       | 62.8    | Borderline case, rounded to even |",
            "| Round(Val, Digits) | 1234.5678 | NULL    | 1235    | Rounded to an integer |",
            "",
            "| Function call              | Val       | Digits | Policy | Result   | Notes |",
            "| :-------------------       | :-------- | :----- | :----- | :------  | :------------- |",
            "| Round(Val, Digits, Policy) | 1234.5678 | 3      | 0      | 1234.568 | Rounded to 3 decimal places |",
            "| Round(Val, Digits, Policy) | 1234.5678 | 3      | 1      | 1230     | Rounded to 3 significant digits |",
            "| Round(Val, Digits, Policy) | 1234.5678 | 6      | 1      | 1234.57  | Rounded to 6 significant digits |",
            "| Round(Val, Digits, Policy) | 1234.5678 | 0      | 1      | 1000     | Rounded to 1 significant digit |",
            "| Round(Val, Digits, Policy) | 62.85     | 1      | 0      | 62.8     | Borderline case, rounded to even |",
            "| Round(Val, Digits, Policy) | 62.85     | 1      | 2      | 62.9     | Borderline case, rounded to higher value |",
            "| Round(Val, Digits, Policy) | -62.85    | 1      | 2      | -62.8    | Borderline case, rounded to higher value |",
            "| Round(Val, Digits, Policy) | -62.85    | 1      | 6      | -62.9    | Borderline case, rounded to lower value |",
            "| Round(Val, Digits, Policy) | 135       | 2      | 1      | 140      | Borderline case, rounded to even |",
            "| Round(Val, Digits, Policy) | 135       | 2      | 5      | 130      | Borderline case, rounded to odd |",
            "| Round(Val, Digits, Policy) | -107.135  | 2      | 2      | -107.13  | Borderline case, rounded to higher value |",
            "| Round(Val, Digits, Policy) | -107.135  | 2      | 10     | -107.14  | Borderline case, rounded to absolute higher value and made negative |",
            "",
            "The following mrScriptBasic example sets variable myResult to the value of myVariable rounded to two decimal places:",
            "```ds",
            "Dim myVariable, myResult",
            "",
            "myVariable = 255.2914",
            "",
            "myResult = myVariable.Round(2)    ' Returns 255.29",
            "```",
        ].join("\n"),
    },
    {
        name: "Pow",
        label: "Pow(Val1: Double, Val2: Double): Double",
        insertText: "Pow",
        definitionType: "function",
        returnType: BasicTypeDefinitions.double ,
        arguments: [
            {
                name: "Val1",
                type: BasicTypeDefinitions.double,
                note: "The base value."
            },
            {
                name: "Val2",
                type: BasicTypeDefinitions.double,
                note: "The exponent value."
            }
        ],
        note: [
            "```ds",
            "(function) Pow(Val1: Double, Val2: Double): Double",
            "```",
            "-----------------------------------",
            "Returns the value of a number raised to a power.",
            "+ `Val1`: *Double* - The base value.",
            "+ `Val2`: *Double* - The exponent value.",
            "+ `return`: *Double* - `Val1` to the power of `Val2`.",
            "",
            "### Remarks",
            "The return value is `Val1` raised to the power of `Val2`. If `Val1` is 0.0, the return value is 0.0. If the current data value is *NULL*, `Val1` is 0.0 and the return value is 0.0. If `Val1` is < 0, an error occurs if `Val2` is not an integer value.",
            "When `Val1` or `Val2` are large numbers, the return value can have more digits than can be accurately represented by the *Double* data type. However, the function does not check for this and does not issue an error when this happens.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the `Pow` function to return the result of 10 raised to the power of 3:",
            "```ds",
            "Dim MyVariable",
            "",
            "MyVariable = Pow(10, 3)    ' Returns 1000",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "Sgn",
        label: "Sgn(Val: Double): Long",
        insertText: "Sgn",
        definitionType: "function",
        returnType: BasicTypeDefinitions.long ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.double,
                note: "A numeric value."
            }
        ],
        note: [
            "```ds",
            "(function) Sgn(Val: Double): Long",
            "```",
            "-----------------------------------",
            "Returns an integer that indicates the sign of a number. The function returns 1 if the number is greater than 0, 0 if it is equal to 0, and -1 if it is less than zero.",
            "+ `Val`: *Double* - A numeric value.",
            "+ `return`: *Long* - 1, 0, or -1, depending on whether `Val` is positive, 0, or negative.",
            "",
            "### Remarks",
            "If the current data value is *NULL*, `Val` is 0.0 and the return value is 0.",
            "This function is similar to the `Sgn` function in VBScript.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the `Sgn` function to determine the sign of a number:",
            "```ds",
            "Dim Positive, Zero, Negative",
            "",
            "Positive = Sgn(50.05)        ' Returns 1",
            "Zero = Sgn(0)                ' Returns 0",
            "Negative = Sgn(-10)          ' Returns -1",
            "```",
        ].join("\n"),
    },
    {
        name: "Sin",
        label: "Sin(Val: Double): Double",
        insertText: "Sin",
        definitionType: "function",
        returnType: BasicTypeDefinitions.double ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.double,
                note: "A numeric value that represents an angle in radians."
            }
        ],
        note: [
            "```ds",
            "(function) Sin(Val: Double): Double",
            "```",
            "-----------------------------------",
            "Returns the sine of an angle.",
            "+ `Val`: *Double* - A numeric value that represents an angle in radians.",
            "+ `return`: *Double* - `Sine` of `Val`.",
            "",
            "### Remarks",
            "The `Sin` function takes an angle and returns the ratio of two sides of a right-angled triangle. The ratio is the length of the side opposite the angle divided by the length of the hypotenuse.",
            "If the current data value is *NULL*, `Val` is 0.0 and the return value is 0.0.",
            "This function is similar to the `Sin` function in VBScript.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the Sin function to get the sine of an angle:",
            "```ds",
            "Dim MySine",
            "MySine = Sin(2.7)       ' Returns 0.42737988023383",
            "```",
        ].join("\n"),
    },
    {
        name: "Sqrt",
        label: "Sqrt(Val: Double): Double",
        insertText: "Sqrt",
        definitionType: "function",
        returnType: BasicTypeDefinitions.double ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.double,
                note: "A numeric value that represents an angle in radians."
            }
        ],
        note: [
            "```ds",
            "(function) Sqrt(Val: Double): Double",
            "```",
            "-----------------------------------",
            "Returns the square root of a number.",
            "+ `Val`: *Double* - A numeric value that represents an angle in radians.",
            "+ `return`: *Double* - `Square` root of `Val`.",
            "",
            "### Remarks",
            "The square root is the number that when multiplied by itself gives `Val`.",
            "An error occurs if `Val` is negative. If the current data value is *NULL*, `Val` is 0.0 and the return value is 0.0.",
            "This function is similar to the `Sqr` function in VBScript.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the `Sqrt` function to return the square root of a number:",
            "```ds",
            "Dim MyValue1, MyValue2, MyValue3",
            "",
            "MyValue1 = Sqrt(9)    ' Returns 3",
            "MyValue2 = Sqrt(3)    ' Returns 1.73205080756888",
            "MyValue3 = Sqrt(-3)   ' Error",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "Tan",
        label: "Tan(Val: Double): Double",
        insertText: "Tan",
        definitionType: "function",
        returnType: BasicTypeDefinitions.double ,
        arguments: [
            {
                name: "Val",
                type: BasicTypeDefinitions.double,
                note: "A numeric value that represents an angle in radians."
            }
        ],
        note: [
            "```ds",
            "(function) Tan(Val: Double): Double",
            "```",
            "-----------------------------------",
            "Returns the tangent of an angle.",
            "+ `Val`: *Double* - A numeric value that represents an angle in radians.",
            "+ `return`: *Double* - `Tangent` of `Val`.",
            "",
            "### Remarks",
            "`Tan` is used to return the ratio of two sides of a right-angled triangle, relative to one of the smaller angles. The ratio is the length of the side opposite the angle divided by the length of the side adjacent to the angle.",
            "An error occurs if `Val` is an odd multiple of pi/2 (for example, -pi/2, pi/2, 3pi/2, etc.). If the current data value is *NULL*, `Val` is 0.0 and the return value is 0.0.",
            "This function is similar to the `Tan` function in VBScript.",
            "",
            "### Examples",
            "The following mrScriptBasic example uses the Tan function to get the tangent of an angle:",
            "```ds",
            "Dim MyTangent",
            "",
            "MyTangent = Tan(1.37340076694502)  ' Returns 5.0000000000001",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "CombineIterations",
        definitionType: "function",
        label: "CombineIterations(CombineQuestion: Object, CombineIterationName: String, CombineList: Categorical): Boolean",
        insertText: "CombineIterations",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "CombineQuestion",
                type: BasicTypeDefinitions.object,
                note: "Grid question"
            },
            {
                name: "CombineIterationName",
                type: BasicTypeDefinitions.string,
                note: "The iteration category that stores the combination results."
            },
            {
                name: "CombineList",
                type: BasicTypeDefinitions.categorical,
                note: "The iteration category items that determine the result."
            }
        ],
        note: [
            "```ds",
            "(function) CombineIterations(CombineQuestion: Object, CombineIterationName: String, CombineList: Categorical): Boolean",
            "```",
            "-----------------------------------",
            "Combines the response value for nested grid question iterations (used for `OnNextCase` events).",
            "+ `CombineQuestion`: *Object* - Grid question.",
            "+ `CombineIterationName`: *String* - The iteration category that stores the combination results.",
            "+ `CombineList`: *Categorical* - The iteration category items that determine the result.",
            "+ `return`: *Double* - *True* if the function is successful.",
            "",
            "### Remarks",
            "Used to combine the value of sub-question(s) related to two iterations (by union operation). The results are saved in the sub-question related to another iteration named `CombineIterationName`.",
            "There are restrictions when using this function:",
            "+ `CombineQuestion` is categorical loop.",
            "+ The loop can contain more than one type of sub-question. This function only process categorical questions.",
            "+ Iteration `CombineIterationName` should exist in question `CombineQuestion` before the `OnNextCase` event. The iteration can be added via the *.dms* script metadata.",
            "",
            "### Example",
            "```ds",
            "CombineIterations(MyLoopCatQuestion, \"NetAorB\", {A,B})",
            "```",
            "NetAorB is one iteration category for *MyLoopCatQuestion*, and can be added as follows:",
            "```ds",
            "MetaData (ENU, Analysis, Label, myInputDataSource)",
            "  ",
            "    MyLoopCatQuestion - loop",
            "	{",
            "	    NetAorB \"Respondent chose either A or B\"",
            "	} fields -",
            "	(",
            "	    rating    categorical [1..1]",
            "	    {",
            "	        LikeABit \"LikeABit\" Factor(3),",
            "	        Like \"Like\" Factor(2),",
            "	        Dislike \"Dislike\" Factor(1)",
            "	    };",
            "	) expand grid;",
            "	",
            "End MetaData",
            "```",
            "After running the function, the results are as follows:",
            "",
            "| Iteration Name | Case 1              | Case 2      |",
            "| :------------- | :------------------ | :---------- |",
            "| A              | { ABitLike }        | { Dislike } |",
            "| B              | { Like }            | { Dislike } |",
            "| NetAorB        | { ABitLike , Like } | { Dislike } |",
            "",
            "",
        ].join("\n"),
    },
    {
        name: "CopyGrid",
        label: "CopyGrid(SourceGrid: Object, DestinationGrid: Object, IterationFilter: Categorical): Boolean",
        insertText: "CopyGrid",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "SourceGrid",
                type: BasicTypeDefinitions.object,
                note: "Grid question"
            },
            {
                name: "DestinationGrid",
                type: BasicTypeDefinitions.object,
                note: "Grid question"
            },
            {
                name: "IterationFilter",
                type: BasicTypeDefinitions.categorical,
                note: "Categorical for iteration filter"
            },
        ],
        note: [
            "```ds",
            "(function) CopyGrid(SourceGrid: Object, DestinationGrid: Object, IterationFilter: Categorical): Boolean",
            "```",
            "-----------------------------------",
            "Combines the response value for nested grid question iterations (used for `OnNextCase` events).",
            "+ `SourceGrid`: *Object* - Grid question.",
            "+ `DestinationGrid`: *Object* - Grid question.",
            "+ `IterationFilter`: *Categorical* - Categorical for iteration filter.",
            "+ `return`: *Double* - *True* if copy is successful.",
            "",
            "### Remarks",
            "If `IterationFilter` is null, data transfer from `SourceGrid` to `DestinationGrid` will be processed according to the iterations for `DestinationGrid`, otherwise according to the iterations in `IterationFilter`.",
            "There may be some iterations or sub-questions in `DestinationGrid` that do not exist in `SourceGrid`. This function only copies the common iterations and sub-questions in `DestinationGrid` and `SourceGrid`.",
            "",
            "### Example",
            "```ds",
            "CopyGrid(Loop1, LoopForCopy, Null)",
            "```",
            "The definitions for *Loop1* and *LoopForCopy* are as follows:",
            "```ds",
            "Loop1 - loop",
            "    {",
            "        A -,",
            "        B -,",
            "        C -,",
            "        D -",
            "    } fields -",
            "    (",
            "",
            "       Q1 \"LikeOrNot\"     categorical [1..1]",
            "        {",
            "            Like -,",
            "            Dislike -",
            "        };",
            "       Q2 Text[20];",
            "       Q3 Long[1..5];",
            "        ",
            "    ) expand grid;",
            " ",
            " LoopForCopy - loop",
            "    {",
            "        B -,",
            "        A -,",
            "        D -",
            "    } fields -",
            "    (",
            "       Q2 Text[20];",
            "       Q1 \"LikeOrNot\"     categorical [1..1]",
            "        {",
            "            Like -,",
            "            Dislike -",
            "        };",
            "        ",
            "    ) expand grid;",
            "```",
            "",
            "For the current record, the value for *Loop1* is as follows:",
            "",
            "| LevelID | Q1       | Q2           | Q3     |",
            "| :------ | :------- | :----------- | :----- |",
            "| {A}     |{Dislike} | I am testing | 2      |",
            "| {B}     |{Like}    | I am         | 2      |",
            "| {C}     |{Dislike} | I            | 3      |",
            "| {D}     |{Like}    | I am t       | 4      |",
            "",
            "The value for *LoopForCopy* is as follows:",
            "",
            "| LevelID  |    Q2        | Q1          |",
            "| :------- | :----------- | :---------- |",
            "| {A}      | I am testing | {Dislike}   |",
            "| {B}      | I am         | {Like}      |",
            "| {D}      | I am t       | {Like}      |",
            "",
            "```ds",
            "CopyGrid(Loop1, LoopForCopy, {A,B})",
            "```",
            "Based on the above value for *Loop1*, the value for *LoopForCopy* will be as follows:",
            "",
            "| LevelID | Q2           | Q1           |",
            "| :------ | :---------   | :----------- |",
            "| {A}     | I am testing | { Dislike }  |",
            "| {B}     | I am         | {Like}       |",
            "",
            "### Performance note",
            "`CopyGrid` can transfer data between grids for many scenarios. The grid may contain any type of question (single response, compound, block, nested grid, and so on). Use the following script example for better performance when the grid being copied has only one nested question:",
            "```ds",
            "For Each Iteration In Grid1",
            "     Grid1_Copy[Iteration.QuestionName].Item[0].Response = Iteration.Item[0]",
            "Next",
            "```",
            "",
        ].join("\n")
    },
    {
        name: "CreateGridSummary",
        label: "CreateGridSummary(Grid: Variant, SummaryVarible: Variant, SummaryCategories: Variant, QuestionNameForSummary: String): Void",
        insertText: "CreateGridSummary",
        definitionType: "function",
        arguments: [
            {
                name: "Grid",
                type: BasicTypeDefinitions.variant,
                note: "The summarized grid question.",
            },
            {
                name: "SummaryVariable",
                type: BasicTypeDefinitions.variant,
                note: "The categorical question for saving summary results.",
            },
            {
                name: "SummaryCategories",
                type: BasicTypeDefinitions.variant,
                note: "The category list for calculating summary results.",
            },
            {
                name: "QuestionNameForSummary",
                type: BasicTypeDefinitions.string,
                note: "The name of sub-question in the summarized grid.",
            },
        ],
        note: [
            "```ds",
            "(function) CreateGridSummary(Grid: Variant, SummaryVarible: Variant, SummaryCategories: Variant, QuestionNameForSummary: String): Void",
            "```",
            "-----------------------------------",
            "Combines the response value for nested grid question iterations (used for `OnNextCase` events).",
            "+ `Grid`: *Variant* - The summarized grid question.",
            "+ `SummaryVariable`: *Variant* - The categorical question for saving summary results.",
            "+ `SummaryCategories`: *Variant* - The category list for calculating summary results.",
            "+ `QuestionNameForSummary`: *String* - The name of sub-question in the summarized grid.",
            "",
            "### Remarks",
            "The function creates the summarized results for grid sub-questions and saves the results to the categorical question `SummaryVariable`. There can be more than one sub-question; `QuestionNameForSummary` is the only sub-question that is summarized.",
            "There are restrictions when using this function:",
            "+ The grid iteration categories are the same as defined categories for the categorical question `SummaryVariable`.",
            "",
            "### Example",
            "```ds",
            "CreateGridSummary (BrandsGrid, TopBrand2, {A,B}, \"Rating\")",
            "```",
            "```ds",
            "BrandsGrid \"BrandsGrid\" loop",
            "{",
            "    BrandA \"BrandA\",",
            "    BrandB \"BrandB\",",
            "    BrandC \"BrandC\",",
            "    BrandD \"BrandD\" ",
            "} fields -",
            "(",
            "    Rating \"Rating\"    categorical [1..]",
            "    {",
            "        A \"_1\",",
            "        B \"_2\",",
            "        C \"_3\",",
            "        D \"_4\",",
            "        E \"_5\"",
            "    };",
            "",
            "    LongRating \"Rating\"   long [0 .. 10];",
            "",
            "    TextRating \"Rating\"     text [10..10];",
            "",
            ") expand grid;",
            "",
            "BrandTop \"Top 2 summary Brand\" categorical[1..]",
            "{",
            "    BrandA \"BrandA\",",
            "    BrandB \"BrandB\",",
            "    BrandC \"BrandC\",",
            "    BrandD \"BrandD\" ",
            "}",
            "```",
            "The value for *BrandsGrid* is as follows:",
            "",
            "|         | A     | B     | C     | D     | E     |",
            "| :------ | :---- | :---- | :---- | :---- | :---- |",
            "| BrandA  | √     |       | √     |       |       |",
            "| BrandB  |       | √     |       | √     |       |",
            "| BrandC  |       |       | √     | √     | √     |",
            "| BrandD  | √     |       |       |       |       |",
            "",
            "The value for the question *TopBrand2* is:",
            "```ds",
            "{BrandA, BrandB, BrandD}",
            "```",
            "",
        ].join("\n"),
    },{
        name: "FlattenGrid",
        label: "FlattenGrid(FlattenQuestionFullName: String, FilterIteration: String, MDMObject: Object): Boolean",
        insertText: "FlattenGrid",
        definitionType: "function",
        arguments: [
            {
                name: "FlattenQuestionFullName",
                type: BasicTypeDefinitions.string,
                note: "FullName for the question being flattened"
            },
            {
                name: "FilterIteration",
                type: BasicTypeDefinitions.string,
                note: "String for the iteration filter"
            },
            {
                name: "MDMObject",
                type: BasicTypeDefinitions.object,
                note: "MDM object related to the *.mdd* file that contains `GridObjectName`"
            },
        ],
        note: [
            "```ds",
            "(function) FlattenGrid(FlattenQuestionFullName: String, FilterIteration: String, MDMObject: Object): Boolean",
            "```",
            "-----------------------------------",
            "Converts categorical loop sub-questions (both grid and non-grid) into flattened questions that can be used in the DMOM `eventOnBeforeJobStart/OnAfterMetaDataTransformation`.",
            "+ `FlattenQuestionFullName`: *String* - `FullName` for the question being flattened.",
            "+ `FilterIteration`: *String* - String for the iteration filter.",
            "+ `MDMObject`: *Object* - MDM object related to the *.mdd* file that contains `GridObjectName`.",
            "+ `return`: *Boolean* - True if the function is successful.",
            "",
            "### Remarks",
            "The generated questions are saved on the top level in the *.mdd* file related to `MDMObject`. The policy for avoiding duplicate question names is to append _1, _2, _n to the default question name.",
            "",
            "### Example",
            "```ds",
            "FlattenGrid(\"MyLoopCatQuestion.rating\", Null, MDMObject)",
            "```",
            "The definition for *MyLoopCatQuestion* is as follows:",
            "```ds",
            "MyLoopCatQuestion - loop",
            "    {",
            "        A \"A\",",
            "        B \"B\",",
            "        C \"C\",",
            "        D \"D\"",
            "    } fields -",
            "    (",
            "        rating categorical [1..1]",
            "        {",
            "            LikeABit \"LikeABit\",",
            "            Like \"Like\",",
            "            Dislike \"Dislike\"",
            "        };",
            "",
            "    ) expand grid;",
            "```",
            "The generated, flattened questions are as follows:",
            "```ds",
            "A_rating     categorical ",
            " expression(\"MyLoopCatQuestion[{A}].rating\");",
            "",
            "B_rating    categorical ",
            " expression(\"MyLoopCatQuestion[{B}].rating\");",
            "",
            "C_rating     categorical ",
            " expression(\"MyLoopCatQuestion[{C}].rating\");",
            "",
            "D_rating    categorical ",
            " expression(\"MyLoopCatQuestion[{D}].rating\");",
            "```",
            "```ds",
            "FlattenGrid (\"MyLoopCatQuestion.rating\", \"a,b\", MDMObject)",
            "```",
            "Then newly created variables are as follows:",
            "```ds",
            "A_rating     categorical ",
            " expression(\"MyLoopCatQuestion[{A}].rating\");",
            "",
            "B_rating    categorical ",
            "expression(\"MyLoopCatQuestion[{B}].rating\");",
            "```",
            "```ds",
            "FlattenGrid (\"ComplexLoop.Grid1\", \"a,b\", MDMObject)",
            "```",
            "The definition for *ComplexLoop* is as follows:",
            "```ds",
            "ComplexLoop - loop",
            "    {",
            "        A \"A\",",
            "        B \"B\",",
            "        C \"C\",",
            "        D \"D\"",
            "    } fields -",
            "    (",
            "        Grid1 - loop",
            "        {",
            "            1 \"1\",",
            "            2 \"2\",",
            "            3 \"3\"",
            "        } fields -",
            "        (",
            "            rating    categorical [1..1]",
            "            {",
            "                ABitLike \"ABitLike\",",
            "                Like \"Like\",",
            "                Dislike \"Dislike\"",
            "            };",
            "",
            "        ) expand grid;",
            "",
            "    ) expand grid;",
            "```",
            "The generated, flattened questions are as follows:",
            "```ds",
            "ComplexLoop_A_1_rating     categorical ",
            "expression(\"ComplexLoop[{A}].Grid1[{1}].rating\");",
            "",
            " ComplexLoop_A_2_rating    categorical ",
            "expression(\"ComplexLoop[{A}].Grid1[{_2}].rating\");",
            "",
            " ComplexLoop_A_3_rating     categorical ",
            "expression(\"ComplexLoop[{A}].Grid1[{_3}].rating\");",
            "",
            " ComplexLoop_B_1_rating     categorical ",
            "expression(\"ComplexLoop[{B}].Grid1[{_1}].rating\");",
            "",
            " ComplexLoop_B_2_rating     categorical ",
            "expression(\"ComplexLoop[{B}].Grid1[{_2}].rating\");",
            "",
            " ComplexLoop_B_3_rating     categorical ",
            "expression(\"ComplexLoop[{B}].Grid1[{_3}].rating\");",
            "```",
            "",
            "",
        ].join("\n"),
    },
    {
        name: "FlipGrid",
        label: "FlipGrid(SourceGrid: Object, DestinationGrid: Object, [QuestionNameForFlip: String], [IterationFilter: Variant = NULL]): Boolean",
        insertText: "FlipGrid",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "SourceGrid",
                type: BasicTypeDefinitions.object,
                note: "Grid question",
            },
            {
                name: "DestinationGrid",
                type: BasicTypeDefinitions.object,
                note: "Grid question",
            },
            {
                name: "QuestionNameForFlip",
                type: BasicTypeDefinitions.string,
                optional: true,
                note: "The categorical question name for being flipped (optional).",
            },
            {
                name: "IterationFilter",
                type: BasicTypeDefinitions.variant,
                optional: true,
                defaultValue: "NULL",
                note: "Categorical for iteration filter. The default is NULL.",
            },
        ],
        note: [
            "```ds",
            "(function) FlipGrid(SourceGrid: Object, DestinationGrid: Object, [QuestionNameForFlip: String], [IterationFilter: Variant = NULL]): Boolean",
            "```",
            "-----------------------------------",
            "Retrieves flipped data from `SourceGrid`. `SourceGrid` contains the originally collected data; `DestinationGrid` (used for `OnNextCase` events) stores the flipped data.",
            "+ `SourceGrid`: *Object* - Grid question.",
            "+ `DestinationGrid`: *Object* - Grid question.",
            "+ `QuestionNameForFlip`: *String* - The categorical question name for being flipped (optional).",
            "+ `IterationFilter`: *Variant* - Categorical for iteration filter. The default is *NULL*.",
            "+ `return`: *Boolean* - *True* if the flip is successful.",
            "",
            "### Remarks",
            "There are restrictions when using this function:",
            "+ When `DestinationGrid` is a categorical loop with only one nested categorical question, and `SourceGrid` is a categorical loop, which may have more than one question but has at least one categorical question, the flipping only occurs for the categorical question QuestionNameForFlip. If the question name QuestionNameForFlip is not specified, the flip occurs for the first nested categorical question.",
            "+ There may be some iteration categories for `DestinationGrid` that do not exist in the question categories for sub-questions in SourceGrid, or there may be some question categories in the sub-questions for DestinationGrid that do not exist in the iteration categories for `SourceGrid`. This function only flips for",
            "    - The common categories between the `DestinationGrid` sub-question categories and the `SourceGrid` iteration categories.",
            "    - The common categories between the `DestinationGrid` iteration categories and SourceGrid sub-question categories.",
            "",
            "If the `DestinationGrid` sub-question response values are null after being flipped, they are assigned to the NA category (if the question has one).",
            "",
            "### Example",
            "```ds",
            "FlipGrid(myTestLoop, MyFlipLoop, \"Grid\", null)",
            "```",
            "The definitions for *myTestLoop* and *MyFlipLoop* are as follows:",
            "```ds",
            "MyTestLoop \"For the following products,please indicate your opinion?\" loop",
            "    {",
            "        A \"Product A\",",
            "        B \"Product B\",",
            "        C \"Product C\",",
            "        D \"Product D\"",
            "    } fields -",
            "    (",
            "        Grid \"Preference\"     categorical [1..1]",
            "        {",
            "            Like \"Like\",",
            "            LikeABit -,",
            "            Dislike \"Dislike\",",
            "            SourceNa - NA",
            "        };",
            "",
            "    ) expand grid; ",
            "",
            " MyFlipLoop - loop",
            "    {",
            "        Like -,",
            "        LikeABit -,",
            "        Dislike -",
            "    } fields -",
            "    (",
            "        Type \"Type\"        categorical [1..]",
            "        {",
            "            A -,",
            "            B -,",
            "            C -,",
            "            D -",
            "        };",
            "",
            "    ) expand grid;",
            "```",
            "For the current record, the value for *MyTestLoop* is as follows:",
            "",
            "| LevelID | Grid       |",
            "| :------ | :--------- |",
            "| {A}     | {Dislike}  |",
            "| {B}     | {Like}     |",
            "| {C}     | {LikeABit} |",
            "| {D}     | {LikeABit} |",
            "",
            "The value for *MyFlipLoop* is as follows:",
            "",
            "| LevelID     | Type       |",
            "| :---------- | :--------- |",
            "| {Like}      | {B}        |",
            "| {Dislike}   | {A}        |",
            "| {LikeABit}  | {C,D}      |",
            "",
            "```ds",
            "FlipGrid(myTestLoop, MyFlipLoop, \"Grid\", {Like,Dislike})",
            "```",
            "The value for *MyFlipLoop* is as follows:",
            "",
            "| LevelID     | Type       |",
            "| :---------- | :--------- |",
            "| {Like}      | {B}        |",
            "| {Dislike}   | {A}        |",
            "",
        ].join("\n"),
    },
    {
        name: "RemoveCategory",
        label: "RemoveCategory(MDMObject: Object, QuestionName: String, OldCategory: String): Boolean",
        insertText: "RemoveCategory",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "MDMObject",
                type: BasicTypeDefinitions.object,
                note: "The name for the MDM document that contains QuestionName."
            },
            {
                name: "QuestionName",
                type: BasicTypeDefinitions.string,
                note: "The name of the question object from which `oldCategory` will be removed."
            },
            {
                name: "OldCategory",
                type: BasicTypeDefinitions.string,
                note: "The category item being moved from `QuestionName`."
            },
        ],
        note: [
            "```ds",
            "(function) RemoveCategory(MDMObject: Object, QuestionName: String, OldCategory: String): Boolean",
            "```",
            "-----------------------------------",
            "Removes the deprecated `OldCategory` from `MDMObject` (often used in the `OnJobEnd` event).",
            "+ `MDMObject`: *Object* - The name for the MDM document that contains `QuestionName`.",
            "+ `QuestionName`: *String* - The name of the question object from which `oldCategory` will be removed.",
            "+ `OldCategory`: *String* - The category item being moved from `QuestionName`.",
            "+ `return`: *Boolean* - Returns *True* if moving `oldCategory` is successful, otherwise returns *False*.",
            "",
            "### Remarks",
            "The category `OldCategory` may exist in defined categories for categorical questions, iteration categorical, or defined question categories for loop questions.",
            "There are restrictions when using this function:",
            "    - The `QuestionName` question type is categorical, loop numeric, or loop categorical.",
            "",
            "### Example",
            "```ds",
            "RemoveCategory(mdmObject, \"cat\", \"snake\")",
            "```",
            "The following table illustrates changes after running the above example:",
            "- Before Removing",
            "```ds",
            "cat -    categorical [1..]",
            "    {",
            "        Dog -,",
            "        Goldfish -,",
            "        Panda -,",
            "        Giraffe -,",
            "        snake -,",
            "        DonKnow -",
            "    };",
            "```",
            "- After Removing",
            "```ds",
            "cat -   categorical [1..]",
            "    {",
            "        Dog -,",
            "        Goldfish -,",
            "        Panda -,",
            "        Giraffe -,",
            "        DonKnow -",
            "        ",
            "    };",
            "```",
            "```ds",
            "RemoveCategory(mdmObject, \"MyLoopCatQuestion\", \"snake\")",
            "```",
            "The following table illustrates changes after running the above example:",
            "- Before Removing",
            "```ds",
            "MyLoopCatQuestion - loop",
            "    {",
            "        A \"A\",",
            "        B \"B\",",
            "        C \"C\",",
            "        D \"D\"",
            "    } fields -",
            "    (",
            "        rating \"rating\"",
            "        categorical [1..1]",
            "        {",
            "            Dog \"Dog\",",
            "            Goldfish \"Goldfish\",",
            "            snake \"snake\",",
            "            Panda \"Panda\",",
            "            Giraffe \"Giraffe\"",
            "        };",
            "",
            "    ) expand grid;",
            "```",
            "- After Removing",
            "```ds",
            "MyLoopCatQuestion - loop",
            "    {",
            "        A \"A\",",
            "        B \"B\",",
            "        C \"C\",",
            "        D \"D\"",
            "    } fields -",
            "    (",
            "        rating \"rating\"",
            "        categorical [1..1]",
            "        {",
            "            Dog \"Dog\",",
            "            Goldfish \"Goldfish\",",
            "            Panda \"Panda\",",
            "            Giraffe \"Giraffe\"",
            "        };",
            "",
            "    ) expand grid;",
            "```",
            "```ds",
            "RemoveCategory(mdmObject, \"MyLoopLogicQuestion\", \"snake\")",
            "```",
            "The following table illustrates changes after running the above example:",
            "- Before Removing",
            "```ds",
            "MyLoopLogicQuestion - loop",
            "    {",
            "        Dog \"Dog\",",
            "        Goldfish \"Goldfish\",",
            "        Panda \"Panda\",",
            "        Giraffe \"Giraffe\",",
            "        snake \"snake\"",
            "    } fields -",
            "    (",
            "     YesOrNo  categorical [1..1]",
            "     {",
            "        Yes \"Yes\",",
            "        No \"No\"",
            "        };",
            "",
            "    ) expand grid;",
            "```",
            "- After Removing",
            "```ds",
            "MyLoopLogicQuestion - loop",
            "    {",
            "        Dog \"Dog\",",
            "        Goldfish \"Goldfish\",",
            "        Panda \"Panda\",",
            "        Giraffe \"Giraffe\"",
            "        ",
            "    } fields -",
            "    (",
            "     YesOrNo  categorical [1..1]",
            "     {",
            "        Yes \"Yes\",",
            "        No \"No\"",
            "        };",
            "",
            "    ) expand grid;",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "ReplaceCategory",
        label: "ReplaceCategory(Question: Object, oldCategory: String, newCategory: String): Boolean",
        insertText: "ReplaceCategory",
        definitionType: "function",
        arguments: [
            {
                name: "Question",
                type: BasicTypeDefinitions.object,
                note: "Category question or loop question.",
            },
            {
                name: "oldCategory",
                type: BasicTypeDefinitions.string,
                note: "Category item that will be replaced with `newCategory`.",
            },
            {
                name: "newCategory",
                type: BasicTypeDefinitions.string,
                note: "The new category value that replaces `oldCategory`.",
            },
        ],
        note: [
            "```ds",
            "(function) ReplaceCategory(Question: Object, oldCategory: String, newCategory: String): Boolean",
            "```",
            "-----------------------------------",
            "Replaces `oldCategory` with `newCategory` for a loop/categorical questions (used for `OnNextCase` events).",
            "+ `Question`: *Object* - Category question or loop question.",
            "+ `oldCategory`: *String* - Category item that will be replaced with `newCategory`.",
            "+ `newCategory`: *String* - The new category value that replaces `oldCategory`.",
            "+ `return`: *Boolean* - *True* when `oldCategory` successfully replaces `newCategory`, otherwise *False*",
            "",
            "### Remarks",
            "For each question, the `oldCategory` can be an iteration category, a question category for a loop question, or a category for categorical question.",
            "There are restrictions when using this function:",
            "    - When the question is a category question, `oldCategory` and `newCategory` are the defined categories.",
            "    - When the question is a loop question, `oldCategory` can be in the iteration categories or in the defined category items for the nested question.",
            "",
            "### Example",
            "The definitions for cat, *MyLoopCatQuestion*, and *MyLoopLogicQuestion* are as follows:",
            "```ds",
            "cat \"What animal you like?\"categorical [1..]",
            "    {",
            "        Dog \"Dog\",",
            "        Goldfish \"Goldfish\",",
            "        Panda \"Panda\",",
            "        Giraffe \"Giraffe\",",
            "        snake \"snake\",",
            "        dontKnow \"dontKnow\",",
            "        Serpent \"Serpent\"",
            "    };",
            "",
            " MyLoopCatQuestion - loop",
            "    {",
            "        A \"A\",",
            "        B \"B\",",
            "        C \"C\",",
            "        D \"D\"",
            "    } fields -",
            "    (",
            "        rating  categorical [1..1]",
            "        {",
            "            Dog \"Dog\",",
            "            Goldfish \"Goldfish\",",
            "            Panda \"Panda\",",
            "            Giraffe \"Giraffe\",",
            "            snake \"snake\",",
            "            Serpent \" Serpent \"",
            "        };",
            "",
            "    ) expand grid;",
            "",
            " MyLoopLogicQuestion - loop",
            "    {",
            "        Dog \"Dog\",",
            "        Goldfish \"Goldfish\",",
            "        Panda \"Panda\",",
            "        Giraffe \"Giraffe\",",
            "        snake \"snake\",",
            "        Serpent \" Serpent \"",
            "    } fields -",
            "    (",
            "        YesOrNo  categorical [1..1]",
            "        {",
            "            Yes \"Yes\",",
            "            No \"No\"",
            "        };",
            "",
            "    ) expand grid;",
            "```",
            "```ds",
            "ReplaceCategory(cat, \"snake\", \"Serpent\")",
            "```",
            "The related `response.value` for the question cat is as follows:",
            "",
            "| Before Replacement | After Replacement   |",
            "| :----------------- | :----------------   |",
            "| {dog,snake,panda}  | {dog,serpent,panda} |",
            "| {giraffe,snake}    | {giraffe,serpent}   |",
            "| {dog,goldfish}     | {dog,goldfish}      |",
            "",
            "```ds",
            "ReplaceCategory(MyLoopCatQuestion, \"snake\", \"Serpent\")",
            "```",
            "The related `response.value` for the question *MyLoopCatQuestion* is as follows:",
            "",
            "| Question	                     | Before Replacement   | After Replacement   |",
            "| :---------------------------- | :------------------- | :------------------ |",
            "| MyLoopCatQuestion[{A}].Rating | {dog,snake,panda}    | {dog,serpent,panda} |",
            "| MyLoopCatQuestion[{B}].Rating | {giraffe,snake}      | {giraffe,serpent}   |",
            "| MyLoopCatQuestion[{C}].Rating | {dog,goldfish}       | {dog,goldfish}      |",
            "| MyLoopCatQuestion[{D}].Rating | {snake}              | {serpent}           |",
            "",
            "```ds",
            "ReplaceCategory(MyLoopLogicQuestion, \"snake\", \"Serpent\")",
            "```",
            "After running the function, the value of all sub-questions for iteration snake are copied for iteration serpent.",
        ].join("\n"),
    },
    {
        name: "SubtractQuestion",
        label: "SubtractQuestion(ResultCat: Object, CatVar1: Object, CatVar2: Object,...): Categorical",
        insertText: "SubtractQuestion",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical,
        arguments: [
            {
                name: "ResultCat",
                type: BasicTypeDefinitions.object,
                note: "Categorical question"
            },
            {
                name: "CatVar1",
                type: BasicTypeDefinitions.object,
                note: "Categorical question"
            },
            {
                name: "CatVar2",
                type: BasicTypeDefinitions.object,
                ellipsis: true,
                note: "Categorical question. `ResultCat.Response.value = catVar1.Response.Value - catVar2.Response.Value-…-catVarN.Response.Value`"
            },
        ],
        note: [
            "```ds",
            "(function) SubtractQuestion(ResultCat: Object, CatVar1: Object, CatVar2: Object,...): Categorical",
            "```",
            "-----------------------------------",
            "Replaces `oldCategory` with `newCategory` for a loop/categorical questions (used for `OnNextCase` events).",
            "+ `CatVar1`: *Object* - Categorical question.",
            "+ `CatVar2`: *Object* - Categorical question.",
            "+ `ResultCat`: *Object* - Categorical question. `ResultCat.Response.value = catVar1.Response.Value - catVar2.Response.Value-…-catVarN.Response.Value`",
            "+ `return`: *Categorical* - ResultCat.Response.Value",
            "",
            "### Remarks",
            "The value for question being subtracted from the first question (`CatVar1`) can be zero. In this case, the `ResultCat` value is same as the `CatVar1` value.",
            "There are restrictions when using this function:",
            "    - Questions can contain special responses, such as *DK* / *NA*/ *REF*, but the questions will be adjusted to the related special response for `CatVar1`.",
            "",
            "### Example",
            "```ds",
            "SubtractQuestion(Result4, Spont, Prompt1, Prompt2, Prompt3)",
            "```",
            "The definitions for *Result4*, *Spont*, *Prompt1*, *Prompt2*, and *Prompt3* are as follows:",
            "```ds",
            "Spont     categorical [1..]",
            "    {",
            "        Dog -,",
            "        Goldfish -,",
            "        Panda -,",
            "        Giraffe -,",
            "        snake -,",
            "        SpontDK - DK,",
            "        SpontREF - REF,",
            "        SpontNA - NA",
            "    };",
            "",
            "    Prompt1    categorical [1..]",
            "    {",
            "        Dog -,",
            "        Goldfish -,",
            "        Panda -,",
            "        Giraffe -,",
            "        snake -,",
            "        Prompt1DK - DK,",
            "        Prompt1REF - REF,",
            "        Prompt1NA - NA",
            "    };",
            "",
            "    Prompt2     categorical [1..]",
            "    {",
            "        Dog -,",
            "        Goldfish -,",
            "        Panda -,",
            "        Giraffe -,",
            "        snake -,",
            "        Prompt2DK - DK,",
            "        Prompt2REF - REF,",
            "        Prompt2NA - NA",
            "    };",
            "",
            "    Prompt3     categorical [1..]",
            "    {",
            "        Dog -,",
            "        Goldfish -,",
            "        Panda -,",
            "        Giraffe -,",
            "        snake -,",
            "        Prompt3DK - DK,",
            "        Prompt3REF - REF,",
            "        Prompt3NA - NA",
            "};",
            "Result4 \"What animal you like? (Do not read the list)\"    categorical [1..]",
            "    {",
            "        Dog \"Dog\",",
            "        Goldfish \"Goldfish\",",
            "        Panda \"Panda\",",
            "        Giraffe \"Giraffe\",",
            "        snake \"snake\",",
            "        SpontDK \"SpontDK\" DK,",
            "        SpontREF \"SpontREF\" REF,",
            "        SpontNA \"SpontNA\" NA",
            "    };",
            "```",
            "The related values are as follows:",
            "",
            "| Question | Case 1                   | Case2        |",
            "| :------- | :----------------------- | :----------- |",
            "| Spont    | {SpontRef}               | {SpontDK}    |",
            "| Prompt1  | {snake,Griaffe,Goldfish} | {Prompt1DK}  |",
            "| Prompt2  | {dog,goldfish,giraffe}   | {Prompt2NA}  |",
            "| Prompt3  | {giraffe,dog}            | {Prompt3NA}  |",
            "| Result4  | {SpontRef}               | { }          |",
            "",
        ].join("\n")
    },
    {
        name: "SumQuestions",
        label: "SumQuestions(TotalCat: Object, CatVar1: Object, CatVar2: Object, CarVar3: Object,...): Categorical",
        insertText: "SumQuestions",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical,
        arguments: [
            {
                name: "TotalCat",
                type: BasicTypeDefinitions.object,
                note: "Categorical question. `TotalCat.response.value=catVar1.response.value + catvar2.response.value`"
            },
            {
                name: "CatVar1",
                type: BasicTypeDefinitions.object,
                note: "Categorical question. The number of questions varies, but there should be at least two questions.",
            },
            {
                name: "CatVar2",
                type: BasicTypeDefinitions.object,
                ellipsis: true,
                note: "Categorical question. The number of questions varies, but there should be at least two questions.",
            },
        ],
        note: [
            "```ds",
            "(function) SumQuestions(TotalCat: Object, CatVar1: Object, CatVar2: Object, CarVar3: Object,...): Categorical",
            "```",
            "-----------------------------------",
            "Replaces `oldCategory` with `newCategory` for a loop/categorical questions (used for `OnNextCase` events).",
            "+ `TotalCat`: *Object* - Categorical question. `TotalCat.response.value=catVar1.response.value + catvar2.response.value`.",
            "+ `CatVar1`: *Object* - Categorical question.",
            "+ `CatVar2`: *Object* - Categorical question.",
            "+ `return`: *Categorical* - TotalCat.Response.Value",
            "",
            "### Remarks",
            "The question `TotalCat` will sum the response.value of questions `CatVar1`, `CatVar2`, to `CatVarN`. If there is only one question, `TotalCat` will have the same value as `CatVar1`.",
            "There are restrictions when using this function:",
            "    - All questions must be categorical.",
            "    - Questions can contain special responses, such as *DK* / *NA*/ *REF*, but the questions will be adjusted to the related special response for `CatVar1`.",
            "",
            "### Example",
            "```ds",
            "SumQuestions(TotalSum4, Spont, Prompt1, Prompt2, Prompt3)",
            "```",
            "The definitions for *TotalSum4*, *Spont*, *Prompt1, *Prompt2*, and *Prompt3* are as follows",
            "```ds",
            "TotalSum4 \"What animal you like? (Do not read the list)\"",
            "    categorical [1..]",
            "    {",
            "        Dog \"Dog\",",
            "        Goldfish \"Goldfish\",",
            "        Panda \"Panda\",",
            "        Giraffe \"Giraffe\",",
            "        snake \"snake\",",
            "        SpontDK \"SpontDK\" DK,",
            "        SpontREF \"SpontREF\" REF,",
            "        SpontNA \"SpontNA\" NA",
            "    };",
            "",
            "",
            "",
            "Spont \"What animal you like? (Do not read the list)\" categorical [1..]",
            "    {",
            "        Dog \"Dog\",",
            "        Goldfish \"Goldfish\",",
            "        Panda \"Panda\",",
            "        Giraffe \"Giraffe\",",
            "        snake \"snake\",",
            "        SpontDK \"SpontDK\" DK,",
            "        SpontREF \"SpontREF\" REF,",
            "        SpontNA \"SpontNA\" NA",
            "    };",
            "",
            " Prompt1 \"What animal you like? (read the list)\"  categorical [1..]",
            "    {",
            "        Dog \"Dog\",",
            "        Goldfish \"Goldfish\",",
            "        Panda \"Panda\",",
            "        Giraffe \"Giraffe\",",
            "        snake \"snake\",",
            "        Prompt1DK \"SpontDK\" DK,",
            "        Prompt1REF \"SpontREF\" REF,",
            "        Prompt1NA \"SpontNA\" NA",
            "    };",
            "",
            " Prompt2 \"What animal you like? (read the list)\"  categorical [1..]",
            "    {",
            "        Dog \"Dog\",",
            "        Goldfish \"Goldfish\",",
            "        Panda \"Panda\",",
            "        Giraffe \"Giraffe\",",
            "        snake \"snake\",",
            "        Prompt2DK \"SpontDK\" DK,",
            "        Prompt2REF \"SpontREF\" REF,",
            "        Prompt2NA \"SpontNA\" NA",
            "    };",
            "",
            " Prompt3 \"What animal you like? (read the list)\"  categorical [1..]",
            "    {",
            "        Dog \"Dog\",",
            "        Goldfish \"Goldfish\",",
            "        Panda \"Panda\",",
            "        Giraffe \"Giraffe\",",
            "        snake \"snake\",",
            "        Prompt3DK \"SpontDK\" DK,",
            "        Prompt3REF \"SpontREF\" REF,",
            "        Prompt3NA \"SpontNA\" NA",
            "    };",
            "```",
            "The related values are as follows:",
            "",
            "| Question  | Case 1                     | Case 2                    |",
            "| :-------  | :------------------------- | :------------------------ |",
            "| Spont     | {spontDK}                  | {Giraffe}                 |",
            "| Prompt1   | {Prompt1DK}                | {Prompt1NA}               |",
            "| Prompt2   | {Giraffe}                  | {Prompt2DK}               |",
            "| Prompt3   | {Prompt3NA}                | {Giraffe}                 |",
            "| TotalSum4 | {Giraffe,SpontNA ,spontDK} | {Giraffe,SpontNA,SpontDK} |",
            "",
        ].join("\n")
    },
]);

export const builtInCallByDotCategoricalFunctions = new Set<BuiltInDefinition>([
    {
        name: "AnswerCount",
        label: "AnswerCount(): Long",
        insertText: "AnswerCount",
        returnType: BasicTypeDefinitions.long ,
        definitionType: "function",
        note: [
            "```ds",
            "(function) AnswerCount(): Long",
            "```",
            "------------------------------------------",
            "Returns the number of categories selected in a category list.",
            "+ `return`: *Long* - Number of categories in Val.",
            "### Example",
            "For example, to define a quota for respondentswho can name more than five brands of fizzy drinks:",
            "```ds",
            "fizzy.AnswerCount() > 5",
            "```",
        ].join("\n"),
    },
    {
        name: "ContainsAll",
        label: "ContainsAll(Answers: Variant, [Exactly: Boolean]): Boolean",
        insertText: "ContainsAll",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Answers",
                type: BasicTypeDefinitions.variant,
                note: "Variant value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *True*, unless `Exactly` is *True* and `Val` is not empty.",
            },
            {
                name: "Exactly",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                note: "Optional. If *True*, the function returns *True* only if `Val` contains all of the categories in `Answers` and no others. If `Exactly` is omitted or *False*, the function returns *True* if all of the categories in `Answers` are in `Val`, even if `Val` contains other categories."
            }
        ],
        note: [
            "```ds",
            "(function) ContainsAll(Answers: Variant, [Exactly: Boolean]): Boolean",
            "```",
            "-----------------------------------",
            "Identifies whether a category list contains all of the categories in a given list.",
            "+ `Answers`: *Variant* - Variant value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *True*, unless `Exactly` is *True* and `Val` is not empty.",
            "+ `Exactly`: *Boolean* - Optional. If *True*, the function returns *True* only if `Val` contains all of the categories in `Answers` and no others. If `Exactly` is omitted or *False*, the function returns *True* if all of the categories in `Answers` are in `Val`, even if `Val` contains other categories.",
            "+ `return`: *Boolean* - *True* if `Val` contains all of the categories in `Answers`, otherwise *False*. ",
            "",
            "### Remark",
            "+ If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is *False*. If `Answers` is *NULL*, the return value is *False*.",
            "+ This function is equivalent to the >= comparison operator for *Categorical* values, except that the *NULL* behavior is different. However, using the >= operator is generally faster than using the `ContainsAll` function.",
            "",
            "### Examples",
            "Like `ContainsAny` and `ContainsSome`, `ContainsAll` is typically used to filter multiple response data. The Museum sample data set contains a multiple response variable called *remember*, which records the galleries that respondents remember viewing. You could use the following example to create a filter to select respondents who chose the *Fossils* and *Dinosaurs* categories in response to the question:",
            "",
            "```ds",
            "remember.ContainsAll({fossils, dinosaurs})",
            "```",
            "",
            "This filter will select respondents who chose both *Fossils* and *Dinosaurs* regardless of whether they chose any additional categories. To restrict the filter to respondents who chose *Fossils* and *Dinosaurs* and no other categories, set `Exactly` to *True*:",
            "",
            "```ds",
            "remember.ContainsAll({fossils, dinosaurs}, True)",
            "```",
        ].join("\n"),
    },
    {
        name: "ContainsAny",
        label: "ContainsAny(Answers: Variant, [Exactly: Boolean])",
        insertText: "ContainsAny",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Answers",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *False*.",
            },
            {
                name: "Exactly",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                note: "Optional. If *True*, the function returns *False* if `Val` contains any categories that are not in `Answers`. If `Exactly` is omitted or *False*, the function returns *True* if any of the categories in `Answers` are in `Val`, even if `Val` contains other categories.",
            }
        ],
        note: [
            "```ds",
            "(function) ContainsAny(Answers: Variant, [Exactly: Boolean])",
            "```",
            "-----------------------------------",
            "Identifies whether a category list contains one or more categories in a given list.",
            "+ `Answers`: *Variant* - *Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *False*.",
            "+ `Exactly`: *Boolean* - Optional. If *True*, the function returns *False* if `Val` contains any categories that are not in `Answers`. If `Exactly` is omitted or *False*, the function returns *True* if any of the categories in `Answers` are in `Val`, even if `Val` contains other categories.",
            "+ `return`: *Boolean* - *True* if `Val` contains the categories as specified, otherwise *False*.",
            "",
            "### Remarks",
            "If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is *False*. If `Answers` is *NULL*, the return value is *False*.",
            "",
            "### Examples",
            "Like `ContainsAll` and `ContainsSome`, `ContainsAny` is typically used to filter multiple response data. The Museum sample data set contains a multiple response variable called *remember*, which records the galleries that respondents *remember* viewing. You could use the following example to create a filter to select respondents who chose either or both of the *Fossils* and *Dinosaurs* categories in response to the question:",
            "```ds",
            "remember.ContainsAny({fossils, dinosaurs})",
            "```",
            "This filter will select respondents who chose either one or both of the two categories regardless of whether they chose any additional categories. For example, it will select respondents who chose any of the following:",
            "+ The *Fossils* category only.",
            "+ The *Dinosaurs* category only.",
            "+ The *Fossils* and *Dinosaurs* categories only.",
            "+ The *Fossils* category and any other category. ",
            "+ The *Dinosaurs* category and any other category.",
            "",
            "To restrict the filter to respondents who chose either or both of the two specified categories and no others, set `Exactly` to *True*:",
            "```ds",
            "remember.ContainsAny({fossils, dinosaurs}, True)",
            "```",
        ].join("\n"),
    },
    {
        name: "ContainsSome",
        label: "ContainsSome(Answers: Variant, [Min: Long], [Max: Long], [Exactly: Boolean]): Boolean",
        insertText: "ContainsSome",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Answers",
                type: BasicTypeDefinitions.variant,
                note: "*Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *True* (unless `Exactly` is *True* and `Val` is not empty).",
            },
            {
                name: "Min",
                type: BasicTypeDefinitions.long,
                note: "*Long* - Optional. The minimum number of categories in `Answers` that must be in `Val` for the function to return *True*. If omitted, the minimum is one.",
            },
            {
                name: "Max",
                type: BasicTypeDefinitions.long,
                note: "Optional. The maximum number of categories in `Answers` that must be in `Val` for the function to return *True*. If omitted, the maximum is the number of categories in `Answers`.",
            },
            {
                name: "Exactly",
                type: BasicTypeDefinitions.boolean,
                note: "Optional. If *True*, the function returns *True* only if `Val` contains the specified number of categories and no others. If `Exactly` is omitted or *False*, the function returns *True* if the specifiednumber of categories in `Answers` are in `Val`, even if `Val` contains other categories.",
            }
        ],
        note: [
            "```ds",
            "(function) ContainsSome(Answers: Variant, [Min: Long], [Max: Long], [Exactly: Boolean]): Boolean",
            "```",
            "-----------------------------------",
            "Identifies whether a category list contains some of the categories in a given list.",
            "+ `Answers`: *Variant* - *Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *True* (unless `Exactly` is *True* and `Val` is not empty).",
            "+ `Min`: *Long* - Optional. The minimum number of categories in `Answers` that must be in `Val` for the function to return *True*. If omitted, the minimum is one. ",
            "+ `Max`: *Long* - Optional. The maximum number of categories in `Answers` that must be in `Val` for the function to return *True*. If omitted, the maximum is the number of categories in `Answers`.  ",
            "+ `Exactly`: *Boolean* - Optional. If *True*, the function returns *True* only if `Val` contains the specified number of categories and no others. If `Exactly` is omitted or *False*, the function returns *True* if the specifiednumber of categories in `Answers` are in `Val`, even if `Val` contains other categories.",
            "+ `return`: *Boolean* - *True* if `Val` contains the specified categories, otherwise *False*.",
            "",
            "### Remarks",
            "If the current value is *NULL*, `Val` is an empty Categorical value ({}) and the return value is *False*. If `Answers` is *NULL*, the return value is *False*.",
            "",
            "### Examples",
            "Like `ContainsAll` and `ContainsAny`, `ContainsSome` is typically used to filter multiple response data. The Museum sample data set contains a multiple response variable called *remember*, which records the galleries that respondents *remember* viewing. You could use the following example to create a filter to select respondents who chose two or more of four specified categories in response to the question:",
            "```ds",
            "remember.ContainsSome({fossils, dinosaurs, birds, whales}, 2)",
            "```",
            "To restrict the filter to respondents who chose at least two, but not more than three, of the four categories, set `Max` to 3:",
            "```",
            "remember.ContainsSome({fossils, dinosaurs, birds, whales}, 2, 3)",
            "```",
            "To restrict the filter to respondents who chose at least two, but not more than three, of the four categories and no others, set `Exactly` to *True*:",
            "```",
            "remember.ContainsSome({fossils, dinosaurs, birds, whales}, 2, 3, True)",
            "```",
        ].join("\n"),
    },
    {
        name: "DefinedCategories",
        label: "DefinedCategories([Answers: Variant]): Categorical",
        insertText: "DefinedCategories",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Answers",
                type: BasicTypeDefinitions.categorical,
                optional: true,
                note: "Optional. *Variant* value of type *Categorical* or *Text*, specifying a set of categories. If omitted, all categoriesfrom the `VariableInstance` are returned.",
            }
        ],
        note: [
            "```ds",
            "(function) DefinedCategories([Answers: Variant]): Categorical",
            "```",
            "-----------------------------------",
            "Returns a set of categories of a categorical variable.",
            "+ `Answers`: *Variant* - Optional. *Variant* value of type *Categorical* or *Text*, specifying a set of categories. If omitted, all categoriesfrom the `VariableInstance` are returned. ",
            "+ `return`: *Categorical* - Set of category numbers as defined in the VariableInstance.",
            "",
            "### Remarks",
            "`Val` may refer to any type of MDM object that has elements, for example, `Field`, `Array` , `Grid` or `VariableInstance`, or it may be an Elements list itself.",
            "If `Answers` is of type Text, it is assumed to be a category expression and is resolved to a list of categories. If `Answers` is of type *Categorical* and contains category names, they are converted to category numbers.",
            "This function requires the case data to be opened with an MDM document or for a script to have an open MDM document available to it. Otherwise, an error will occur. ",
            "If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is also an empty *Categorical* value. If `Answers` is *NULL*, the return value is all of the categories defined in the current variable.",
            "",
            "### Examples",
            "This example shows how the `DefinedCategories` function can be used in an SQL query on a multiple response variable to define groups based on the categories.",
            "```sql",
            "SELECT groupby.col[0] AS Museums,",
            "    BASE(museums) AS 'Base'",
            "FROM vdata",
            "WHERE museums IS NOT NULL",
            "GROUP BY museums ON museums.DefinedCategories()",
            "```",
            "",
            "Here is the result set:",
            "",
            "| Museums                               | Base    |",
            "| :------------------------------------ | :------ |",
            "| {national_museum_of_science}          | 333     |",
            "| {museum_of_design}                    | 92      |",
            "| {institute_of_textiles_and_fashion}   | 47      |",
            "| {archeological_museum}                | 26      |",
            "| {national_art_gallery}                | 19      |",
            "| {northern_gallery}                    | 21      |",
            "| {other}                               | 37      |",
            "| {not_answered}                        | 0       |",
        ].join("\n"),
    },
    {
        name: "DefinedElements",
        label: "DefinedElements([Types: Long]): Categorical",
        insertText: "DefinedElements",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Types",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. Flags specifying which types of `Element` objects to include. The default is (Category + Base).",
            }
        ],
        note: [
            "```ds",
            "(function) DefinedElements([Types: Long]): Categorical",
            "```",
            "-----------------------------------",
            "Returns a set of elements of a categorical variable.",
            "The possible values for Types are shown in the following table.",
            "+ `Types`: *Long* - Optional. Flags specifying which types of `Element` objects to include. The default is (Category + Base).",
            "+ `return`: *Categorical* - Set of category numbers as defined in the VariableInstance.",
            "",
            "| Value       | Description           |",
            "| :---------- | :-------------------- |",
            "| 1           | Category elements     |",
            "| 2           | Base elements         |",
            "| 4           | Subtotal elements     |",
            "| 8           | Summary data elements |",
            "| 16          | Derived elements      |",
            "| 32          | Subheading elements   |",
            "",
            "The flags may be used in any combination, to select elements of more than one type. For example, to select all Category and Base elements, use `1 + 2 = 3`.",
            "",
            "### Remarks",
            "`Val` may refer to any type of MDM object that has elements, for example, Field, Array , Grid or VariableInstance, or it may be an Elements list itself.",
            "If the current value is *NULL*, `Val` is an empty Categorical value ({}) and the return value is also an empty Categorical value. ",
            "This function requires the case data to be opened with an MDM document or for a script to have an open MDM document available to it. Otherwise, an error will occur. ",
            "Like `DefinedCategories`, `DefinedElements` is typically used to define groups in SQL queries. However, whereas `DefinedCategories` defines groups based on categories only, you can use `DefinedElements` to define groups based on any element type that stores case data or a combination of these element types. ",
            "",
            "### Examples",
            "The following query creates groups based on all categories and any base elements in the gender and *gender.Ex* variables in the Museum IBM® SPSS® Quanvert™ sample data base. The *gender.Ex* variable is included in the GROUP BY statement because Quanvert DSC stores special elements in a separate variable that has an *.Ex* suffix.",
            "```sql",
            "SELECT groupby.col[0] AS Gender, ",
            "    SUM(visits) AS 'Sum of visits' ",
            "FROM vdata ",
            "WHERE visits > 0 ",
            "GROUP BY gender.EX + gender ",
            "    ON gender.Ex.Definedelements() + gender.Definedelements() ",
            "```",
            "",
            "Here is the result set:",
            "",
            "| Gender      | Sum of visits |",
            "| :---------- | :------------ |",
            "| {base}      | 2131          |",
            "| {male}      | 1309          |",
            "| {female}    | 822           |",
        ].join("\n"),
    },
    {
        name: "DefinedFactors",
        label: "DefinedFactors([Answers: Variant]): Categorical",
        insertText: "DefinedFactors",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Answers",
                type: BasicTypeDefinitions.variant,
                optional: true,
                note: "Optional. *Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for. If omitted, all categoriesfrom the object are used."
            }
        ],
        note: [
            "```ds",
            "(function) DefinedFactors([Answers: Variant]): Categorical",
            "```",
            "-----------------------------------",
            "Returns a set of factor numbers as defined on the categories in a variable.",
            "+ `Answers`: *Categorical* - Optional. *Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for. If omitted, all categoriesfrom the object are used.",
            "+ `return`: *Categorical* - Set of factor numbers as defined in on the categories, matching the order of the categories in *Answers*.",
            "",
            "### Remarks",
            "`Val` may refer to any type of MDM object that has elements, for example, Field, Array , Grid or VariableInstance, or it may be an Elements list itself.",
            "If `Answers` is of type Text, it is assumed to be a category expression and is resolved to a list of categories. If `Answers` is of type Categorical and contains category names, they are converted to category numbers.",
            "This function requires the case data to be opened with an MDM document or for a script to have an open MDM document available to it. Otherwise, an error will occur. ",
            "The function returns a factor of 0 for sublists and for categories with no factor defined. Factors can be long or double values.",
            "To sort the returned values, use *SortAsc* or *SortDesc*.",
        ].join("\n"),
    },
    {
        name: "Difference",
        label: "Difference(Answers: String | Categorical): Categorical",
        insertText: "Difference",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Answers",
                type: [
                    BasicTypeDefinitions.string,
                    BasicTypeDefinitions.categorical,
                ],
                note: "*Variant* value of type *Categorical* or *Text*, specifying a set of categories.",
            }
        ],
        note: [
            "```ds",
            "(function) Difference(Answers: String | Categorical): Categorical",
            "```",
            "-----------------------------------",
            "Returns the difference of two category lists--that is, it returns the categories that are in the first category list but not in the second. The categories are returned in the order in which they appear in the first category list.",
            "+ `Answers`: *String* | *Categorical* - *Variant* value of type *Categorical* or *Text*, specifying a set of categories.",
            "+ `return`: *Categorical* - Set of categories that are in `Val` but not in `Answers`, in the order in which they appear in `Val`.",
            "",
            "### Remarks",
            "If the current value is *NULL*, `Val` is an empty Categorical value ({}) and the return value is also an empty Categorical value. If `Answers` is *NULL*, the return value is `Val`.",
            "This function is equivalent to the `subtract (-) arithmetic operator` for Categorical values, except that `Difference` can operate on named categories and the *NULL* behavior is different.",
            "However, using the `subtract (-) operator` is generally faster than using the `Difference` function.",
            "",
            "### Examples",
            "",
            "| Function call       | Q1            | Q2            | Result     |",
            "| :------------------ | :------------ | :------------ | :--------- |",
            "| Q1.Difference(Q2)   | {1,2,3}       | {4,5,6}       | {1,2,3}    |",
            "| Q1.Difference(Q2)   | {1,2,3,4,5,6} | {4,5,6}       | {1,2,3}    |",
            "| Difference(Q1, Q2)  | {1,2,3,4,5,6} | {3,6,4,1,2,5} | {}         |",
            "",
            "Like `Intersection` and `XUnion`, `Difference` is useful when categorical variables have identical or overlapping category lists. ",
            "For example, the *remember* and *interest* variables are categorical variables that have similar category lists. *remember* is a multiple response variable that records which galleries the respondents *remember* viewing, and interest is a single response variable that records which gallery respondents found most interesting. In the following example, the `Difference` function is used to remove the responses given to the *interest* question from the responses given to the *remember* question. The `>=` operator then tests whether the resulting list of categories includes the *Fossils* category. You could use this expression to create a filter to select respondents who remember the *Fossils* gallery, but who did not find it the most interesting gallery.",
            "```ds",
            "Difference(remember, interest) >= {FOSSILS}",
            "```",
        ].join("\n"),
    },
    {
        name: "Factor",
        label: "Factor(): Variant",
        insertText: "Factor",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        note: [
            "```ds",
            "(function) Factor(): Variant",
            "```",
            "-----------------------------------",
            "Returns the factor defined for an element of a categorical variable.",
            "+ `return`: *Variant* - Factor number as defined on the element.",
            "",
            "### Remarks",
            "If `Val` contains more than one element, only the factor for the first element is returned. If Val is {}, the return value is *NULL*. If the current data value is *NULL*, Val is {} and the return value is *NULL*.",
            "If the first \"element\" in `Val` is actually (the MDM value of) an element list, the sublist is expanded until an actual element is found, if any. If the element does not have a factor defined, the return value is *NULL*. Note that the factor can be a *Long* or *Double* value.",
        ].join("\n"),
    },
    {
        name: "GetAnswer",
        label: "GetAnswer(Index: Long): Categorical",
        insertText: "GetAnswer",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Index",
                type: BasicTypeDefinitions.long,
                note: "Position of category to retrieve from `Val`, starting from 0.",
            }
        ],
        note: [
            "```ds",
            "(function) GetAnswer(Index: Long): Categorical",
            "```",
            "-----------------------------------",
            "Returns a specified category in a category list.",
            "+ `Index`: *Long* - Position of category to retrieve from `Val`, starting from 0.",
            "+ `return`: *Categorical* - The category at the requested position in Val, if found, or an empty *Categorical* value if it is not found",
            "",
            "### Remarks",
            "If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is also an empty *Categorical* value.",
            "",
            "### Examples",
            "",
            "| Function call  | Q1        | Index     | Result |",
            "| :------------- | :-------- | --------- | ------ |",
            "| GetAnswer(Q1, Index) | {5,1,6,3,2,4} | 0 | {5} |",
            "| Q1.GetAnswer(Index) | {5,1,6,3,2,4} | 3 | {3} |",
            "",
            "The following example tests whether the Fossils category is in the first position in the list of responses stored for each respondent in the remember multiple response variable: ",
            "```ds",
            "remember.GetAnswer(0) = {FOSSILS}",
            "```",
        ].join("\n"),
    },
    {
        name: "HasAnswer",
        label: "HasAnswer(Answer: Long): Boolean",
        insertText: "HasAnswer",
        definitionType: "function",
        returnType: BasicTypeDefinitions.boolean,
        arguments: [
            {
                name: "Answer",
                type: BasicTypeDefinitions.long,
                note: "Category to look for in `Val`."
            }
        ],
        note: [
            "```ds",
            "(function) HasAnswer(Answer: Long): Boolean",
            "```",
            "-----------------------------------",
            "Identifies whether a specified category is in a category list.",
            "+ `Answer`: *Long* - Category to look for in `Val`.",
            "+ `return`: *Boolean* - *True* if `Val` contains the category, *False* otherwise.",
            "",
            "### Remarks",
            "If the current value is *NULL*, Val is an empty *Categorical* value ({}) and the return value is *False*.",
            "The `HasAnswer` function has been superseded by `ContainsAll`, `ContainsAny`, and `ContainsSome`. However, `HasAnswer` has been retained for backwards compatibility.",
            "",
            "### Examples",
            "",
            "| Function call         | Response      | Filter  | Result |",
            "| :-------------------- | :------------ | :------ | :----- |",
            "| Q1.HasAnswer(Filter)  | {4,2,9,6,1,7} | 10      | False  |",
            "| HasAnswer(Q1, Filter) | {4,2,9,6,1,7} | 6       | True   |",
            "",
            "The following example selects respondents who chose the category with the mapped category value of 31 (which is the *Dinosaurs* category) in response to the *remember* question. In a multiple response variable, `HasAnswer` returns *True* regardless of whether any other category was chosen in response to the question. This example therefore selects all respondents who chose the *Dinosaurs* category regardless of whether they also chose any other category.",
            "```ds",
            "remember.HasAnswer(31)",
            "```",
        ].join("\n"),
    },
    {
        name: "Intersection",
        label: "Intersection([Vals: String | Categorical ...]): Categorical",
        insertText: "Intersection",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Vals",
                type: [
                    BasicTypeDefinitions.string,
                    BasicTypeDefinitions.categorical,
                ],
                ellipsis: true,
                optional: true,
                note: "One or more variant values of type *Categorical* or *Text*. Each value specifies a set of categories.",
            }
        ],
        note: [
            "```ds",
            "(function) Intersection([Vals: String | Categorical ...]): Categorical",
            "```",
            "-----------------------------------",
            "Returns the intersection of two or more category lists--that is, it returns the categories that appear in all of the category lists. The categories are returned in the order in which they appear in the first category list.",
            "+ `Vals`: *String* | *Categorical* - One or more variant values of type *Categorical* or *Text*. Each value specifies a set of categories.",
            "+ `return`: *Categorical* - Set of categories that are in all of `Val` and `Vals`, in the order in which they occur in `Val`.",
            "",
            "### Remarks",
            "If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is also an empty Categorical value. If an item in `Vals` is *NULL*, the item is ignored.",
            "This function is equivalent to the `* arithmetic operator` for *Categorical* values, except that `Intersection` can operate on named categories and the *NULL* behavior is different. However, using the `* operator` is generally **faster** than using the `Intersection` function.",
            "",
            "### Examples",
            "",
            "| Function call        | Q1            | Q2            | Result    |",
            "| :-------------       | :--------     | :------------ | :-------- |",
            "| Q1.Intersection(Q2)  | {4,2,9,6,1,7} | {6,10,3,5,9}  | {9,6}     |",
            "| Intersection(Q1, Q2) | {4,2,9,6,1,7} | {3}           | {}        |",
            "",
            "| Function call            | Q1            | Q2            | Q3           | Result    |",
            "| :-------------------     | :------------ | :------------ | :----------- | :-------- |",
            "| Q1.Intersection(Q2, Q3)  | {5,6,8,2,3}   | {1,3,4,6}     | {2,4,6,7,8}  | {6}       |",
            "| Intersection(Q1, Q2, Q3) | {5,6,8,2,3}   | NULL          | {2,4,6,7,8}  | {6,8,2}   |",
            "",
            "Like `Difference` and `XUnion`, `Intersection` is useful when categorical variables have identical or overlapping response lists. The *biology* and *education* variables are single response categorical variables that have identical category lists (*Yes*, *No*, and *Not answered*). You could use the `Intersection` function to return the categories that are in both of the category lists. In the following example, the `= operator` tests whether the result is the *Yes* category. You could therefore use this example to select respondents who chose the Yes category in response to both questions.",
            "```ds",
            "biology.Intersection(education) = {yes}",
            "```",
        ].join("\n"),
    },
    {
        name: "Union",
        label: "Union([Vals: Categorical | String ...]): Categorical",
        insertText: "Union",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Vals",
                type: [
                    BasicTypeDefinitions.categorical,
                    BasicTypeDefinitions.string,
                ],
                ellipsis: true,
                optional: true,
                note: "One or more variant values of type *Categorical* or *Text*. Each value specifies a set of categories."
            }
        ],
        note: [
            "```ds",
            "(function) Union([Vals: Categorical | String ...]): Categorical",
            "```",
            "-----------------------------------",
            "Returns the union of two or more category lists--that is, it returns all of the categories that are in any one or more of the category lists.",
            "+ `Vals`: *Categorical* | *String* - One or more variant values of type *Categorical* or *Text*. Each value specifies a set of categories.",
            "+ `return`: *Categorical* - All of the categories in `Val` , followed by any other categories that are in `Vals`.",
            "",
            "### Remarks",
            "If an item in `Vals` is *NULL*, the item is ignored. If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is the union of all non-NULL items in `Vals`.",
            "This function is equivalent to the `+ arithmetic operator` for *Categorical* values, except that Union can operate on named categories and the *NULL* behavior is different. However, using the `+ operator` is generally faster than using the `Union` function.",
            "",
            "### Examples",
            "",
            "| Function call       | Q1             | Q2                | Result          |",
            "| :------------------ | :------------- | :---------------- | :------------   |",
            "| Union(Q1, Q2)       | {5,1,6,3,2,4}  | {3,6,7,5}         | {5,1,6,3,2,4,7} |",
            "| Q1.Union(Q2)        | {4,2,9,6,1,7}  | {}                | {4,2,9,6,1,7}   |",
            "",
            "| Function call       | Q1             | Q2                | Q3               | Result          |",
            "| :------------------ | :------------- | :---------------- | :--------------- | :------------   |",
            "| Q1.Union(Q2, Q3)    | {6,8,2,3}      | {3,4,6}           | {1,7,8}          | {6,8,2,3,4,1,7} |",
            "| Union(Q1, Q2, Q3)   | {6,8,2,3}      | {3,4,6}           | NULL             | {6,8,2,3,4}     |",
            "",
            "The following example uses `Union` to combine the results of two single response categorical variables that have similar category lists and tests whether the result includes the *Yes* category. For example, you could use this example to select respondents who chose *Yes* in response to at least one of the questions.",
            "```ds",
            "Union(biology, education) >= {yes}",
            "```",
        ].join("\n"),
    },
    {
        name: "XUnion",
        label: "XUnion(Answers: Categorical | String): Categorical",
        insertText: "XUnion",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Answers",
                type: [
                    BasicTypeDefinitions.categorical,
                    BasicTypeDefinitions.string
                ],
                note: "*Variant* value of type *Categorical* or *Text*, specifying a set of categories."
            }
        ],
        note: [
            "```ds",
            "(function) XUnion(Answers: Categorical | String): Categorical",
            "```",
            "-----------------------------------",
            "Returns the exclusive union of two category lists--that is, it returns all of the categories that are in either one of the category lists, but not in both.",
            "+ `Answers`: *Categorical* | *String* - *Variant* value of type *Categorical* or *Text*, specifying a set of categories. ",
            "+ `return`: *Categorical* - Set of categories that are in either `Val` or `Answers` but not in both.",
            "",
            "### Remarks",
            "If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is `Answers`. If `Answers` is *NULL*, the return value is `Val`.",
            "This function is equivalent to the `/ arithmetic operator` for *Categorical* values, except that it can operate on named categories and the *NULL* behavior is different. However, using the `/ operator` is generally faster than using the `XUnion` function.",
            "",
            "### Examples",
            "",
            "| Function call  | Q1                | Q2               | Result          |",
            "| :------------  | :------------     | :------------    | :----------     |",
            "| XUnion(Q1, Q2) | {3,5,9,10,23,5,6} | {5,16,4,10}      | {3,9,23,6,16,4} |",
            "| Q1.XUnion( Q2) | {3,5,9,}          | {5,3,9}          | {}              |",
            "",
            "Like the `Difference` and `Intersection` functions, `XUnion` is useful when categorical variables have identical or overlapping category lists. For example the *biology* and *education* variables have identical response lists. In the following example, `XUnion` is used to return any categories that are in either one of the category lists, but not in both and the `>= operator` tests whether the result contains the *Yes* category. For example, you could use this expression to select respondents who chose the *Yes* category in response to either one of the questions, but not to both.",
            "```ds",
            "XUnion(biology, education) >= {yes}",
            "```",
        ].join("\n"),
    },
]);


export const builtInCallByDotTextFunctions = new Set<BuiltInDefinition>([
    {
        name: "Format",
        label: "Format([Style: String], [Width: Long], [Locale: Long]): String",
        insertText: "Format",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        arguments: [
            {
                name: "Style",
                type: BasicTypeDefinitions.string,
                optional: true,
                note: "Optional. One or more formatting codes. Multiple codes must be separated by semicolons."
            },
            {
                name: "Width",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The minimum width of the formatted string."
            },
            {
                name: "Locale",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The output locale to use for regional variations in formatting. If `Locale` is omitted or is negative, the current output locale is used for formatting."
            }
        ],
        note: [
            "```ds",
            "(function) Format([Style: String], [Width: Long], [Locale: Long]): String",
            "```",
            "-----------------------------------",
            "Returns a string that is the result of formatting a value according to one or more specified styles.",
            "+ `Style`: *String* - Optional. One or more formatting codes. Multiple codes must be separated by semicolons. ",
            "+ `Width`: *Long* - Optional. The minimum width of the formatted string. ",
            "+ `Locale`: *Long* - Optional. The output locale to use for regional variations in formatting. If `Locale` is omitted or is negative, the current output locale is used for formatting. ",
            "+ `return`: *String* - `Val` formatted as a text string. ",
            "",
            "### Remarks",
            "`Val` is formatted according to `Style`, as described below. If `Width` is supplied and the formatted string is shorter than the absolute value of `Width`, the string is padded with space characters to make it up to (the absolute value of) `Width` characters. If `Width` is negative, spaces are added at the end of the string; otherwise, spaces are added at the start.",
            "An error occurs if Val is an array with more than one dimension. Locale, if specified, is used for regional variations in formatting, but not for error messages. Custom formatting is not currently supported.",
            "If the metadata to be used for formatting needs to provided by a separate variable from `Val`, use the `FormatValue` function.",
            "",
            "#### Style Code Syntax",
            "`Style` consists of one or more formatting codes. Multiple codes must be separated by semicolons. Each code is of the form C[p][=t], where:",
            "+ *C* is a letter specifying the type of formatting to do.",
            "+ *p* is an optional integer that modifies the formatting in some way, depending on *C*.",
            "+ *t* is an optional text argument whose meaning depends on *C*.",
            "",
            "If *C* is an unknown code, the formatting described under None in the table below is used (and no error occurs), using the values of p and t, if supplied. The argument p may not have a plus or minus sign, so it can only be a non-negative integer. If *p* or *t* is inappropriate for *C*, it is ignored (and no error occurs).",
            "",
            "#### Applying a Style",
            "Except for the Count style (s, described in the table below), if Val is an array or a categorical value, the result is a comma-separated list of the results of applying the given style code (or codes) to each item or element in turn (in this case, `Val` in the table below refers to each individual item or element, not the whole array). No attempt is made to differentiate the separator character from any occurrences of the same character in the individual formatted values. Note that this gives the same result for a categorical value as for an array of long values. Note also that, if an array contains values of different types, the style code (or codes) may be interpreted differently for different items. If `Width` is specified, it is applied to the whole list, not to individual items.",
            "Except for special cases described in the table below, the value is converted to the expected type, using the input locale where necessary to interpret strings. For an object, the value of the object’s default property is used (in this case, `Val` below refers to the retrieved value). If any error occurs in retrieving an object’s properties, or in converting a value to the expected type, the result for that value is “”, except where noted below.",
            "Where formatting is affected by locale settings, the system settings for the locale are used, ignoring any “user overrides” (changes made to regional settings by the user currently logged in to the server).",
            "Except for the Count style (s, described below), if `Val` is *NULL*, the result is an empty string (\"\").",
            "",
            "#### Applying Multiple Styles",
            "If `Style` consists of more than one formatting code, each code is applied in turn to Val as described in “Applying a Style” above. Because the result of applying the first code will always be a text value, subsequent codes should only be those that are relevant to text values, for example, LowerFirst, Count, or UpperAll (*l*, *s*, or *U*, described below).",
            "Any padding required by `Width` is done after all codes have been applied.",
            "",
            "#### Style Code Definitions",
            "+ **None** - ",
            "    - For an MDMLabeledObject, the same as for *Label* (*b*), using *t* if supplied.",
            "    - For any other object, the same as for *Value* (*v*), using *t* if supplied.",
            "    - For other types, the same as `CText(Val)`, ignoring *p* and *t*.",
            "+ **a**: *Name* - ",
            "    - For an MDMLabeledObject, the Name property. If an error occurs retrieving the name, the result is “”.",
            "    - For any other object, the result of applying the Name format to the object's default property value.",
            "    - For other types, the Name of the MDM Element whose value is `CLong(Val)`. If the MDM Element or its Name cannot be accessed, the Name of the MDM mapped category value whose value is `CLong(Val)`. If the MDM mapped category value does not exist, the result is the same as for *Decimal1* (*d*), using *p* if supplied.",
            "+ **A**: *NameFull* - Same as for *Name* (*a*), but using the FullName instead of the Name for an MDMLabeledObject or MDM Element.",
            "+ **b**: *Label* - ",
            "    - For an MDMLabeledObject, its Label. If an error occurs retrieving the label, the result is “”.",
            "    - For any other object, the result of applying the Label format to the object’s default property value.",
            "    - For other types, the Label of the MDM Element (in the current MDM object) whose value is `CLong(Val)`. If an error occurs retrieving the label, the result is the same as *Decimal1* (*d*), using *p* if supplied.",
            "    - Labels are retrieved using the current Context and Language in the metadata. If t is given, it’s the name of the LabelType to use. If t is omitted, or specifies a nonexistent *LabelType*, the current LabelType is used.",
            "+ **B**: *LabelFull* - Same as for *Label* (*b*), but using the FullLabel instead of the Label for an MDMLabeledObject or MDM Element. The FullLabel can only be retrieved for the MDM document’s current LabelType, so t is ignored.",
            "+ **c**: *Currency* - `Val` converted to double and formatted as a currency, using the currency symbol and format specified by the output locale. The number of decimal places is adjusted to p by rounding Val (away from zero, for borderline cases), or by adding zeros at the end. If `p = 0`, the result has no decimal separator and no fractional part. If *p* is omitted, the default for the output locale is used.",
            "+ **C**: *Currency-Code* - Same as for *Currency* (*c*), but using the three-character international monetary symbol specified by the output locale.",
            "+ **d**: *DateShort,Decimal1* - ",
            "    - For a date value, short date format specified by the output locale (ignoring time of day in `Val`).",
            "    - The string length is increased to *p*, if given, by inserting zeros before the first digit.",
            "+ **D**: *DateLong, Decimal2* - ",
            "    - For a date value, long date format specified by the output locale (ignoring time of day in `Val`).",
            "    - For other types, `Val` converted to long and formatted as follows:",
            "        - A minus sign (-) if `Val` < 0. Followed by...",
            "        - One or more decimal digits (0-9).",
            "    - For other types, same as for Decimal1 (*d*).",
            "+ **e**: *Scientific-Lower* - ",
            "    - `Val` converted to double and formatted as follows:",
            "        - A minus sign (-) if Val < 0. Followed by...",
            "        - One decimal digit (0-9). Followed by...",
            "        - A decimal point (.). Followed by...",
            "        - p decimal digits (0-9). Followed by...",
            "        - Lower-case e. Followed by...",
            "        - A plus or minus sign (+ or -). Followed by...",
            "        - Three decimal digits (0-9).",
            "    - The part before the *e* (the mantissa) is `Val` scaled by a power of 10 so that its absolute value is `>= 1.0` and `< 10.0`, unless `Val` is 0.0. The number of decimal places is adjusted by rounding the mantissa (away from zero, for borderline cases), or by adding zeros at the end. If *p* = 0, the mantissa has no decimal separator and no fractional part. If *p* is omitted, it has 6 decimal places.",
            "    - The part after the *e* (the exponent) is the power of 10 by which the mantissa must be multiplied to give `Val`. The exponent length is increased to 3 digits, if necessary, by adding zeros at the left. If `Val` is 0.0, the mantissa and exponent are both zero. If the absolute value of `Val` is `> 0.0` and `< 1.0`, the exponent is negative, otherwise it is positive.",
            "+ **E**: *Scientific-Upper* - Same as for ScientificLower (*e*), but with an upper-case E.",
            "+ **f,F**: *DateTime,FixedPoint* - ",
            "    - For a date value, long date and time formats specified by the output locale, separated by a space.",
            "    - For other types, `Val` converted to double and formatted as follows:",
            "        - A minus sign (-) if Val < 0. Followed by...",
            "        - One or more decimal digits (0-9). Followed by...",
            "        - *A* decimal separator (specified by the output locale). Followed by...",
            "        - *p* decimal digits.",
            "    - The number of decimal places is adjusted by rounding Val (away from zero, for borderline cases), or by adding zeros at the end. If *p* = 0, the result has no decimal separator and no fractional part. If *p* is omitted, the default for the output locale is used.",
            "+ **l**: *LowerFirst* - `CText(Val)`, with the first alphanumeric character converted to lower case (if it’s an upper-case letter) according to the rules for the output locale.",
            "+ **L**: *LowerAll* - `CText(Val)`, with all alphabetic characters converted to lower case according to the rules for the output locale.",
            "+ **n,N**: *Fixed-Grouped* - `Val` converted to double and formatted as for FixedPoint1 (*f*), but with digits before the decimal separator grouped according to the rules for the output locale.",
            "+ **p,P**: *Percent* - `Val` converted to double and multiplied by 100.0, formatted as for FixedPoint (f), followed by a percent sign (%).",
            "+ **s,S**: *Count* - ",
            "    - For an array or categorical value, the number of items/elements it contains.",
            "    - For text, the number of characters in the string.",
            "    - For NULL, 0.",
            "    - For other types, 1.",
            "    - For all types, the count is formatted as for *Decimal1* (*d*), using p if supplied.",
            "+ **t,T**: *Time* - `Val` converted to date and formatted according to the time format specified by the output locale (ignoring the date part of `Val`).",
            "+ **u**: *UpperFirst* - `CText(Val)`, with the first alphanumeric character converted to upper case (if it’s a lower-case letter) according to the rules for the output locale.",
            "+ **U**: *UpperAll* - `CText(Val)`, with all alphabetic characters converted to upper case according to the rules for the output locale.",
            "+ **v**: *Value* - For an object value, the value of a specified property, converted to text. If t is given, it’s the name of the property to use. If t is omitted, or the value of the specified property can’t be retrieved, the default property of the object is used, if it exists. If no suitable property is found, the result is “”. The first property that returns a value is used, even if the value it returns is “”.",
            "For other types, `Val` converted to long and formatted as for *Decimal1* (*d*), using *p* if supplied.",
            "+ **V**: *ValueNative* - ",
            "    - For an object value, the value of a specified property (same as for *Value* (*v*)).",
            "    - For other types, the native value (for the current DataSource in the metadata) of the MDM ElementInstance whose value is `CLong(Val)`, formatted as for *Decimal1* (*d*), using *p* if supplied. If the native value can’t be retrieved, the result is “”.",
            "+ **w**: *TitleFirst* - `CText(Val)`, with the first alphanumeric character converted to upper case, and the rest of the string converted to lower case according to the rules for the output locale.",
            "+ **W**: *TitleAll* - `CText(Val)`, with the first character of each word (any alphanumeric character that isn’t preceded by an alphanumeric character) converted to upper case, and the rest of the string converted to lower case according to the rules for the output locale.",
            "+ **x**: *HexLower* - ",
            "    - `Val` converted to long and formatted as one or more hexadecimal digits (0-9 and a-f).",
            "    - `Val` is treated as an unsigned value; this means that if `Val` < 0, the value formatted is equivalent to Val + Pow(2, 31). Thus the range of possible non-negative long values (0 to 2147483647) is formatted as “0” to “7fffffff”, and the range of negative values (-2147483648 to -1) is formatted as “80000000” to “ffffffff”. This is consistent with the hexadecimal syntax for expressing integers in mrScript, eg &H80000000 = -2147483648.",
            "    - The string length is increased to *p*, if given, by inserting zeros before the first digit.",
            "+ **X**: *HexUpper* - Same as for HexLower (*x*), but with upper-case A-F for the hexadecimal digits.",
            "",
            "### Examples",
            "#### 1. Using the Format function in mrScriptBasic",
            "Note: Many of the examples in the table below make use of the Household sample metadata document, household.mdd, that is installed with the DDL.",
            "",
            "| Function call                                             | Result             |",
            "| :---------                                                | :-----------------------  |",
            "| Format(CDate(\"2004-12-02 15:49:31\"), \"f\", , 1046)                   | \"quinta-feira, 2 de dezembro de 2004 15:49:31\"                                     |",
            "| Format(CDate(\"2004-12-02 15:49:31\"), \"f\", , 1052)                   | \"2004-12-02 3:49:31.MD \"                                                           |",
            "| Format(MDM.Fields[\"person.trip.purpose\"], \"a\")                      | \"purpose\"                                                                          |",
            "| Format(MDM.Fields[\"person.trip.purpose\"], \"A\")                      | \"person[..].trip[..].purpose\"                                                      |",
            "| Format(MDM.Fields[\"person.trip.purpose\"], \"b\")                      | \"Purpose of trip\"                                                                  |",
            "| Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"a\")  | \"Column\"                                                                           |",
            "| Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"A\")  | \"person[2].tvdays[{Channel_3}].Column\"                                             |",
            "| Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"b\")  | \"Number of days watched last week\"                                                 |",
            "| Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"B\")  | \"2,{Channel_3} : Number of days watched last week\"                                 |",
            "| Format(MDM.Fields[\"person.newspapers\"], \"v=EffectiveMaxValue\")      | \"12\"                                                                               |",
            "| Format(MDM.CategoryMap, \"v=Count\")                                    | \"125\"                                                                              |",
            "| Format(MDM.Variables[\"person[6].occupation\"], \"V=hascasedata\")      | \"True\"                                                                             |",
            "| Format(MDM, \"V=URL\")                                                  | \"[INSTALL_FOLDER]\\IBM\\SPSS\\DataCollection\\6\\DDL\\Data\\Data Collection File\\household.mdd\"    |",
            "| Format(MDM.URL, \"L\")                                                  | \"[INSTALL_FOLDER]\\ibm\\spss\\datacollection\\6\\ddl\\data\\data collection file\\household.mdd\"  |",
            "| Format(MDM.URL, \"U\")                                                  | \"[INSTALL_FOLDER]\\IBM\\SPSSDATACOLLECTION\\6\\DDL\\DATA\\DATA COLLECTION FILE\\HOUSEHOLD.MDD\" |",
            "| MDM.MDMVersion.Split(\".\").Format(\"d4\")                              | \"0002,0010,0000,1664\" |",
            "| Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"b;l\")| \"number of days watched last week\" |",
            "",
            "#### 2. Using the Format function in an SQL query",
            "This example shows the use of the `Format` function in an SQL query that can be run against the IBM® SPSS® Data Collection Data File version of the Household sample data set, *household.ddf*. The function is used to display the value of a decimal variable called Satisfaction as a fixed point decimal and as a percentage figure: ",
            "```sql",
            "SELECT DISTINCT",
            "    satisfaction,",
            "    satisfaction.Format('f2') AS FixedPoint,",
            "    Format(satisfaction / 10.0, 'p0') AS Percentage",
            "FROM hdata.person.trip",
            "```",
            "Here is the result set:",
            "",
            "| satisfaction     | FixedPoint | Percentage     |",
            "| :--------------- | :--------- | :---------     |",
            "| 8.5              | 8.50       | 85%    |",
            "| 9                | 9.00       | 90%    |",
            "| 7.75             | 7.75       | 78%    |",
            "| 8                | 8.00       | 80%    |",
            "| 7.5              | 7.50       | 75%    |",
            "| 9.5              | 9.50       | 95%    |",
            "| 10               | 10.00      | 100%   |",
            "| 5                | 5.00       | 50%    |",
            "| 8.30000019073486 | 8.30       | 83%    |",
            "| 7.90000009536743 | 7.90       | 79%    |",
            "| 8.19999980926514 | 8.20       | 82%    |",
            "| 6.30000019073486 | 6.30       | 63%    |",
            "| 5.5              | 5.50       | 55%    |",
            "",
            "This next example shows another SQL query that can be run against the Household sample data set, *household.ddf*. The Format function is used to display the value of a categorical variable called Country in five alternative formats:",
            "```sql",
            "SELECT DISTINCT",
            "    country, ",
            "    country.Format('v2') AS Value, ",
            "    country.Format('a') AS Name, ",
            "    country.Format('b') AS Label, ",
            "    country.Format('b;U') AS LabelUpperCase, ",
            "    country.Format('s4') AS [Count] ",
            "FROM hdata.person.trip",
            "```",
            "Here is the result set:",
            "",
            "| country         |  Value | Name          | Label         | LabelUpperCase | Count  |",
            "| :-------------- |  :----- | :------------ | :------------ | :------------ |  :----- |",
            "| {united_states} |  85    | United_States | United States | UNITED STATES  | 0001  |",
            "| {switzerland}   |  83    | Switzerland   | Switzerland   | SWITZERLAND    | 0001  |",
            "| {india}         |  68    | India         | India         | INDIA          | 0001  |",
            "| {portugal}      |  78    | Portugal      | Portugal      | PORTUGAL       | 0001  |",
            "| {holland}       |  67    | Holland       | Holland       | HOLLAND        | 0001  |",
            "| {morocco}       |  75    | Morocco       | Morocco       | MOROCCO        | 0001  |",
            "| {australia}     |  57    | Australia     | Australia     | AUSTRALIA      | 0001  |",
            "| {france,spain}  |  64,81 | France,Spain  | France,Spain  | FRANCE,SPAIN   | 0002  |",
            "| {china,japan}   |  61,71 | China,Japan   | China,Japan   | CHINA,JAPAN    | 0002  |",
            "| {germany}       |  65    | Germany       | Germany       | GERMANY        | 0001 |",
            "",
            "The first column shows the categorical variable without any formatting, the second column shows the categorical values, the third and fourth columns show the values of the Name and Label properties respectively, the fifth column shows the result of applying two style codes, and the sixth column shows the number of elements in the categorical variable.",
            "",
            "#### 3. Using the Format function in an interview script",
            "The next example shows the `Format` function being used in an interview script that will run in version 3.0 (or later) of IBM® SPSS® Data Collection Interviewer Server. The Format function is used to display the labels and formatted values of the categories selected in the LikeColors question:",
            "```ds",
            "Metadata(en-US, Question, label)",
            "    LikeColors \"Which colors do you like?\" categorical",
            "    {",
            "        red \"I like Red\",",
            "        blue \"I like Blue\",",
            "        green \"I like Green\",",
            "        yellow \"I like Yellow\",",
            "        pink \"I like Pink\",",
            "        purple \"I like Purple\",",
            "        orange \"I like Orange\"",
            "    };",
            "",
            "    LikeColorsResponse \"{InsertHere}\" info;",
            "End Metadata",
            "",
            "Routing(Web)",
            "    LikeColors.Ask()",
            "",
            "    Dim labels, values, str",
            "    labels = LikeColors.Format(\"b\")    ' labels of responses",
            "    labels = labels.Replace(\",\", mr.CrLf)",
            "    values = LikeColors.Format(\"d3\")   ' response values with leading zeroes",
            "    str = \"You chose these:\" + mr.CrLf + labels + mr.CrLf",
            "    str = str + \"Their numerical values are (\" + values + \").\"",
            "    ",
            "    LikeColorsResponse.Ask(str)",
            "End Routing",
            "```",
        ].join("\n"),
    },
    {
        name: "LCase",
        label: "LCase(): String",
        insertText: "LCase",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        note: [
            "```ds",
            "(function) LCase(): String",
            "```",
            "-----------------------------------",
            "Returns a string that has been converted to lower case.",
            "+ `return`: *String* - Lowercase copy of `Val`.",
            "",
            "### Remarks",
            "The input string is converted to lower case, according to the rules of the input locale.",
            "If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "",
            "### Examples",
            "This example uses the `LCase` function to return a copy of the contents of the address variable converted to lower case:",
            "```ds",
            "address.LCase()",
            "```",
        ].join("\n"),
    },
    {
        name: "LTrim",
        label: "LTrim(): String",
        insertText: "LTrim",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        note: [
            "```ds",
            "(function) LTrim(): String",
            "```",
            "-----------------------------------",
            "Returns a copy of a string with any leading spaces removed.",
            "+ `return`: *String* - Copy of `Val` with leading spaces removed.",
            "",
            "### Remarks",
            "`LTrim` removes white space (such as space and tab characters) that appears at the beginning of the input string. `LTrim` uses the rules of the input locale when interpreting white space. ",
            "If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "",
            "### Examples",
            "This example uses the `LTrim` function to return a copy of the contents of the address variable with any leading spaces removed:",
            "```ds",
            "address.LTrim()",
            "```",
        ].join("\n"),
    },
    {
        name: "RTrim",
        label: "RTrim(): String",
        insertText: "RTrim",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        note: [
            "```ds",
            "(function) RTrim(): String",
            "```",
            "-----------------------------------",
            "Returns a copy of a string with any trailing spaces removed.",
            "+ `return`: *String* - Copy of `Val` with trailing spaces removed.",
            "",
            "### Remarks",
            "`RTrim` removes white space (such as space and tab characters) that appears at the end of the input string. RTrim uses the rules of the input locale when interpreting white space. ",
            "If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "",
            "### Examples",
            "This example uses the `RTrim` function to return a copy of the contents of the address variable with any trailing spaces removed:",
            "```ds",
            "address.RTrim()",
            "```",
        ].join("\n"),
    },
    {
        name: "Split",
        label: "Split([Delimiter: String], [Count: Long]): Categorical",
        insertText: "Split",
        definitionType: "function",
        returnType: BasicTypeDefinitions.categorical ,
        arguments: [
            {
                name: "Delimiter",
                type: BasicTypeDefinitions.string,
                optional: true,
                defaultValue: "\" \"",
                note: "Optional. `Delimiter` between substrings. The default is a single space (\" \")."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. The maximum number of substrings to return. If omitted or less than zero, all substrings are returned."
            }
        ],
        note: [
            "```ds",
            "(function) Split([Delimiter: String = \" \"], [Count: Long]): Categorical",
            "```",
            "-----------------------------------",
            "Returns an array that contains substrings.",
            "+ `Delimiter`: *String* - Optional. `Delimiter` between substrings. The default is a single space (\" \").",
            "+ `Count`: *Long* - Optional. The maximum number of substrings to return. If omitted or less than zero, all substrings are returned.",
            "+ `return`: *Categorical* - An *array* containing the substrings from `Val`.",
            "",
            "### Remarks",
            "This function is useful when you are parsing text strings that contain a number of substrings separated by a character such as a comma (,). For example, the lines of an address are often separated by a comma.",
            "If `Val` is an empty string, the return value is an empty array. Otherwise, if Delimiter is an empty string or is not found in `Val`, the return value is an array containing one item, a copy of `Val`. If the current data value is *NULL*, `Val` is an empty string and the return value is an empty array.",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or elsewhere, such as in mrScriptBasic or mrScriptMetadata, or when creating filters in IBM® SPSS® Data Collection Survey Tabulation or quotas in IBM® SPSS® Data Collection Interviewer Server. Enclose text strings in single quotation marks (' ') in SQL queries and enclose text strings in double quotation marks (\" \") everywhere else.",
            "",
            "@Note - The `Split` function returns a categorical value, making it impossible to assign elements of the returned array. It should also be noted that the result from the `Split` function is not a real categorical value, because the elements of a categorical must be of type *Long* (int - VT_I4), not text. The parser treats the value as a categorical, but an error is returned when attempting to pass the value into a function that expects a real categorical (ContainsAny for example).",
            "",
            "### Examples",
            "This mrScriptBasic example uses the `Split` function to return the first line and the first two lines of an address that is stored in a single variable with the lines separated by commas. It also shows an example of using the function using the default parameters:",
            "```ds",
            "Dim Address, FirstLine, FirstTwoLines, Defaults",
            "",
            "Address = \"363 Park Road, Ashford, Kent\"",
            "",
            "FirstLine = Address.Split(",", 1)      ' Returns {363 Park Road}",
            "FirstTwoLines = Address.Split(",", 2)  ' Returns {363 Park Road, Ashford}",
            "Defaults = Address.Split()             ' Returns {363,Park,Road,,Ashford,,Kent}",
            "```",
        ].join("\n"),
    },
    {
        name: "Replace",
        label: "Replace(Key: Variant, Replacement: Variant, [Start: Long], [Count: Long], [IgnoreCase: Boolean]): Variant",
        insertText: "Replace",
        definitionType: "function",
        returnType: BasicTypeDefinitions.variant,
        arguments: [
            {
                name: "Key",
                type: BasicTypeDefinitions.variant,
                note: "Variant value to look for in `Val`, of the same type as `Val`."
            },
            {
                name: "Replacement",
                type: BasicTypeDefinitions.variant,
                note: "Variant value with which to replace `Key`, of the same type as `Val`."
            },
            {
                name: "Start",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. Position in `Val` (starting from 0), from which to start searching for `Key`. If omitted or less than 0, searching starts at the start of `Val`."
            },
            {
                name: "Count",
                type: BasicTypeDefinitions.long,
                optional: true,
                note: "Optional. Maximum number of replacements to make. If omitted or less than 0, all possible replacements are made."
            },
            {
                name: "IgnoreCase",
                type: BasicTypeDefinitions.boolean,
                optional: true,
                note: "Optional. Whether to do case-insensitive comparison for `Key`. The default is *False*."
            }
        ],
        note: [
            "```ds",
            "(function) Replace(Key: Variant, Replacement: Variant, [Start: Long], [Count: Long], [IgnoreCase: Boolean]): Variant",
            "```",
            "-----------------------------------",
            "Replaces part of a text or categorical value with another value of the same type.",
            "+ `Key`: *Variant* - Variant value to look for in `Val`, of the same type as `Val`.",
            "+ `Replacement`: *Variant* - Variant value with which to replace `Key`, of the same type as `Val`.",
            "+ `Start`: *Long* - Optional. Position in `Val` (starting from 0), from which to start searching for `Key`. If omitted or less than 0, searching starts at the start of `Val`.",
            "+ `Count`: *Long* - Optional. Maximum number of replacements to make. If omitted or less than 0, all possible replacements are made.",
            "+ `IgnoreCase`: *Boolean* - Optional. Whether to do case-insensitive comparison for `Key`. The default is *False*.",
            "+ `return`: *Variant* - Copy of `Val` with `Key` replaced with `Replacement`.",
            "",
            "### Remarks",
            "If `Val` is of type `Text`, `Key` and `Replacement` are converted to text values, unless they are already text values or *NULL*. If `Val` is of type *Categorical*, `Key` and `Replacement` are converted to categorical values, unless they are already categorical values or *NULL*. An error occurs if `Key` or `Replacement` cannot be converted to the required type.",
            "If `Val` is *NULL*, the return value is *NULL*. If `Key` is *NULL*, no replacements are made. If `Replacement` is *NULL*, occurrences of `Key` are removed instead of being replaced. If `Val` is of any other type, an error occurs.",
            "",
            "### Examples",
            "The following mrScriptBasic example shows the use of the `Replace` function to replace all the hyphens in a text variable with spaces.",
            "```ds",
            "strVal = strVal.Replace(\"-\", \" \")",
            "```",
            "",
        ].join("\n"),
    },
    {
        name: "Trim",
        label: "Trim(): String",
        insertText: "Trim",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        note: [
            "```ds",
            "(function) Trim(): String",
            "```",
            "-----------------------------------",
            "Returns a copy of a string with any leading and trailing spaces removed.",
            "+ `return`: *String* - Copy of `Val` with leading and trailing spaces removed.",
            "",
            "### Remarks",
            "`Trim` removes white space (such as space and tab characters) that appears at the beginning and end of the input string. `Trim` uses the rules of the input locale when interpreting white space.",
            "If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "",
            "### Examples",
            "This example uses the `Trim` function to return a copy of the contents of the address variable with any leading and trailing spaces removed:",
            "```ds",
            "address.Trim()",
            "```",
        ].join("\n"),
    },
    {
        name: "UCase",
        label: "UCase(): String",
        insertText: "UCase",
        definitionType: "function",
        returnType: BasicTypeDefinitions.string,
        note: [
            "```ds",
            "(function) UCase(): String",
            "```",
            "-----------------------------------",
            "Returns a string that has been converted to upper case.",
            "+ `return`: *String* - Uppercase copy of `Val`.",
            "",
            "### Remarks",
            "The input string is converted to upper case, according to the rules of the input locale.",
            "If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".",
            "How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").",
            "",
            "### Examples",
            "This example returns an uppercase copy of the contents of the *name* variable:",
            "```ds",
            "name.UCase()",
            "```",
            "The next example uses the `Trim` and `Mid` functions in addition to the `UCase` function. The example returns characters 5-10 of the name variable converted to upper case and with any leading or trailing spaces removed:",
            "```ds",
            "Trim(UCase(name.Mid(4, 5)))",
            "```",
        ].join("\n"),
    }
]);


