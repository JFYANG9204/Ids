
Class Long
End Class

Class Date
End Class

Class Boolean
End Class

Class Double
End Class

Class String

    '!
    ```ds
    (function) Format([Style: String], [Width: Long], [Locale: Long]): String
    ```
    -----------------------------------
    Returns a string that is the result of formatting a value according to one or more specified styles.
    + `Style`: *String* - Optional. One or more formatting codes. Multiple codes must be separated by semicolons.
    + `Width`: *Long* - Optional. The minimum width of the formatted string.
    + `Locale`: *Long* - Optional. The output locale to use for regional variations in formatting. If `Locale` is omitted or is negative, the current output locale is used for formatting.
    + `return`: *String* - `Val` formatted as a text string.

    ### Remarks
    `Val` is formatted according to `Style`, as described below. If `Width` is supplied and the formatted string is shorter than the absolute value of `Width`, the string is padded with space characters to make it up to (the absolute value of) `Width` characters. If `Width` is negative, spaces are added at the end of the string; otherwise, spaces are added at the start.
    An error occurs if Val is an array with more than one dimension. Locale, if specified, is used for regional variations in formatting, but not for error messages. Custom formatting is not currently supported.
    If the metadata to be used for formatting needs to provided by a separate variable from `Val`, use the `FormatValue` function.

    #### Style Code Syntax
    `Style` consists of one or more formatting codes. Multiple codes must be separated by semicolons. Each code is of the form C[p][=t], where:
    + *C* is a letter specifying the type of formatting to do.
    + *p* is an optional integer that modifies the formatting in some way, depending on *C*.
    + *t* is an optional text argument whose meaning depends on *C*.

    If *C* is an unknown code, the formatting described under None in the table below is used (and no error occurs), using the values of p and t, if supplied. The argument p may not have a plus or minus sign, so it can only be a non-negative integer. If *p* or *t* is inappropriate for *C*, it is ignored (and no error occurs).

    #### Applying a Style
    Except for the Count style (s, described in the table below), if Val is an array or a categorical value, the result is a comma-separated list of the results of applying the given style code (or codes) to each item or element in turn (in this case, `Val` in the table below refers to each individual item or element, not the whole array). No attempt is made to differentiate the separator character from any occurrences of the same character in the individual formatted values. Note that this gives the same result for a categorical value as for an array of long values. Note also that, if an array contains values of different types, the style code (or codes) may be interpreted differently for different items. If `Width` is specified, it is applied to the whole list, not to individual items.
    Except for special cases described in the table below, the value is converted to the expected type, using the input locale where necessary to interpret strings. For an object, the value of the object’s default property is used (in this case, `Val` below refers to the retrieved value). If any error occurs in retrieving an object’s properties, or in converting a value to the expected type, the result for that value is “”, except where noted below.
    Where formatting is affected by locale settings, the system settings for the locale are used, ignoring any “user overrides” (changes made to regional settings by the user currently logged in to the server).
    Except for the Count style (s, described below), if `Val` is *NULL*, the result is an empty string (\"\").

    #### Applying Multiple Styles
    If `Style` consists of more than one formatting code, each code is applied in turn to Val as described in “Applying a Style” above. Because the result of applying the first code will always be a text value, subsequent codes should only be those that are relevant to text values, for example, LowerFirst, Count, or UpperAll (*l*, *s*, or *U*, described below).
    Any padding required by `Width` is done after all codes have been applied.

    #### Style Code Definitions
    + **None** -
        - For an MDMLabeledObject, the same as for *Label* (*b*), using *t* if supplied.
        - For any other object, the same as for *Value* (*v*), using *t* if supplied.
        - For other types, the same as `CText(Val)`, ignoring *p* and *t*.
    + **a**: *Name* -
        - For an MDMLabeledObject, the Name property. If an error occurs retrieving the name, the result is “”.
        - For any other object, the result of applying the Name format to the object's default property value.
        - For other types, the Name of the MDM Element whose value is `CLong(Val)`. If the MDM Element or its Name cannot be accessed, the Name of the MDM mapped category value whose value is `CLong(Val)`. If the MDM mapped category value does not exist, the result is the same as for *Decimal1* (*d*), using *p* if supplied.
    + **A**: *NameFull* - Same as for *Name* (*a*), but using the FullName instead of the Name for an MDMLabeledObject or MDM Element.
    + **b**: *Label* -
        - For an MDMLabeledObject, its Label. If an error occurs retrieving the label, the result is “”.
        - For any other object, the result of applying the Label format to the object’s default property value.
        - For other types, the Label of the MDM Element (in the current MDM object) whose value is `CLong(Val)`. If an error occurs retrieving the label, the result is the same as *Decimal1* (*d*), using *p* if supplied.
        - Labels are retrieved using the current Context and Language in the metadata. If t is given, it’s the name of the LabelType to use. If t is omitted, or specifies a nonexistent *LabelType*, the current LabelType is used.
    + **B**: *LabelFull* - Same as for *Label* (*b*), but using the FullLabel instead of the Label for an MDMLabeledObject or MDM Element. The FullLabel can only be retrieved for the MDM document’s current LabelType, so t is ignored.
    + **c**: *Currency* - `Val` converted to double and formatted as a currency, using the currency symbol and format specified by the output locale. The number of decimal places is adjusted to p by rounding Val (away from zero, for borderline cases), or by adding zeros at the end. If `p = 0`, the result has no decimal separator and no fractional part. If *p* is omitted, the default for the output locale is used.
    + **C**: *Currency-Code* - Same as for *Currency* (*c*), but using the three-character international monetary symbol specified by the output locale.
    + **d**: *DateShort,Decimal1* -
        - For a date value, short date format specified by the output locale (ignoring time of day in `Val`).
        - The string length is increased to *p*, if given, by inserting zeros before the first digit.
    + **D**: *DateLong, Decimal2* -
        - For a date value, long date format specified by the output locale (ignoring time of day in `Val`).
        - For other types, `Val` converted to long and formatted as follows:
            - A minus sign (-) if `Val` < 0. Followed by...
            - One or more decimal digits (0-9).
        - For other types, same as for Decimal1 (*d*).
    + **e**: *Scientific-Lower* -
        - `Val` converted to double and formatted as follows:
            - A minus sign (-) if Val < 0. Followed by...
            - One decimal digit (0-9). Followed by...
            - A decimal point (.). Followed by...
            - p decimal digits (0-9). Followed by...
            - Lower-case e. Followed by...
            - A plus or minus sign (+ or -). Followed by...
            - Three decimal digits (0-9).
        - The part before the *e* (the mantissa) is `Val` scaled by a power of 10 so that its absolute value is `>= 1.0` and `< 10.0`, unless `Val` is 0.0. The number of decimal places is adjusted by rounding the mantissa (away from zero, for borderline cases), or by adding zeros at the end. If *p* = 0, the mantissa has no decimal separator and no fractional part. If *p* is omitted, it has 6 decimal places.
        - The part after the *e* (the exponent) is the power of 10 by which the mantissa must be multiplied to give `Val`. The exponent length is increased to 3 digits, if necessary, by adding zeros at the left. If `Val` is 0.0, the mantissa and exponent are both zero. If the absolute value of `Val` is `> 0.0` and `< 1.0`, the exponent is negative, otherwise it is positive.
    + **E**: *Scientific-Upper* - Same as for ScientificLower (*e*), but with an upper-case E.
    + **f,F**: *DateTime,FixedPoint* -
        - For a date value, long date and time formats specified by the output locale, separated by a space.
        - For other types, `Val` converted to double and formatted as follows:
            - A minus sign (-) if Val < 0. Followed by...
            - One or more decimal digits (0-9). Followed by...
            - *A* decimal separator (specified by the output locale). Followed by...
            - *p* decimal digits.
        - The number of decimal places is adjusted by rounding Val (away from zero, for borderline cases), or by adding zeros at the end. If *p* = 0, the result has no decimal separator and no fractional part. If *p* is omitted, the default for the output locale is used.
    + **l**: *LowerFirst* - `CText(Val)`, with the first alphanumeric character converted to lower case (if it’s an upper-case letter) according to the rules for the output locale.
    + **L**: *LowerAll* - `CText(Val)`, with all alphabetic characters converted to lower case according to the rules for the output locale.
    + **n,N**: *Fixed-Grouped* - `Val` converted to double and formatted as for FixedPoint1 (*f*), but with digits before the decimal separator grouped according to the rules for the output locale.
    + **p,P**: *Percent* - `Val` converted to double and multiplied by 100.0, formatted as for FixedPoint (f), followed by a percent sign (%).
    + **s,S**: *Count* -
        - For an array or categorical value, the number of items/elements it contains.
        - For text, the number of characters in the string.
        - For NULL, 0.
        - For other types, 1.
        - For all types, the count is formatted as for *Decimal1* (*d*), using p if supplied.
    + **t,T**: *Time* - `Val` converted to date and formatted according to the time format specified by the output locale (ignoring the date part of `Val`).
    + **u**: *UpperFirst* - `CText(Val)`, with the first alphanumeric character converted to upper case (if it’s a lower-case letter) according to the rules for the output locale.
    + **U**: *UpperAll* - `CText(Val)`, with all alphabetic characters converted to upper case according to the rules for the output locale.
    + **v**: *Value* - For an object value, the value of a specified property, converted to text. If t is given, it’s the name of the property to use. If t is omitted, or the value of the specified property can’t be retrieved, the default property of the object is used, if it exists. If no suitable property is found, the result is “”. The first property that returns a value is used, even if the value it returns is “”.
    For other types, `Val` converted to long and formatted as for *Decimal1* (*d*), using *p* if supplied.
    + **V**: *ValueNative* -
        - For an object value, the value of a specified property (same as for *Value* (*v*)).
        - For other types, the native value (for the current DataSource in the metadata) of the MDM ElementInstance whose value is `CLong(Val)`, formatted as for *Decimal1* (*d*), using *p* if supplied. If the native value can’t be retrieved, the result is “”.
    + **w**: *TitleFirst* - `CText(Val)`, with the first alphanumeric character converted to upper case, and the rest of the string converted to lower case according to the rules for the output locale.
    + **W**: *TitleAll* - `CText(Val)`, with the first character of each word (any alphanumeric character that isn’t preceded by an alphanumeric character) converted to upper case, and the rest of the string converted to lower case according to the rules for the output locale.
    + **x**: *HexLower* -
        - `Val` converted to long and formatted as one or more hexadecimal digits (0-9 and a-f).
        - `Val` is treated as an unsigned value; this means that if `Val` < 0, the value formatted is equivalent to Val + Pow(2, 31). Thus the range of possible non-negative long values (0 to 2147483647) is formatted as “0” to “7fffffff”, and the range of negative values (-2147483648 to -1) is formatted as “80000000” to “ffffffff”. This is consistent with the hexadecimal syntax for expressing integers in mrScript, eg &H80000000 = -2147483648.
        - The string length is increased to *p*, if given, by inserting zeros before the first digit.
    + **X**: *HexUpper* - Same as for HexLower (*x*), but with upper-case A-F for the hexadecimal digits.

    ### Examples
    #### 1. Using the Format function in mrScriptBasic
    Note: Many of the examples in the table below make use of the Household sample metadata document, household.mdd, that is installed with the DDL.

    | Function call                                             | Result             |
    | :---------                                                | :-----------------------  |
    | Format(CDate(\"2004-12-02 15:49:31\"), \"f\", , 1046)                   | \"quinta-feira, 2 de dezembro de 2004 15:49:31\"                                     |
    | Format(CDate(\"2004-12-02 15:49:31\"), \"f\", , 1052)                   | \"2004-12-02 3:49:31.MD \"                                                           |
    | Format(MDM.Fields[\"person.trip.purpose\"], \"a\")                      | \"purpose\"                                                                          |
    | Format(MDM.Fields[\"person.trip.purpose\"], \"A\")                      | \"person[..].trip[..].purpose\"                                                      |
    | Format(MDM.Fields[\"person.trip.purpose\"], \"b\")                      | \"Purpose of trip\"                                                                  |
    | Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"a\")  | \"Column\"                                                                           |
    | Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"A\")  | \"person[2].tvdays[{Channel_3}].Column\"                                             |
    | Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"b\")  | \"Number of days watched last week\"                                                 |
    | Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"B\")  | \"2,{Channel_3} : Number of days watched last week\"                                 |
    | Format(MDM.Fields[\"person.newspapers\"], \"v=EffectiveMaxValue\")      | \"12\"                                                                               |
    | Format(MDM.CategoryMap, \"v=Count\")                                    | \"125\"                                                                              |
    | Format(MDM.Variables[\"person[6].occupation\"], \"V=hascasedata\")      | \"True\"                                                                             |
    | Format(MDM, \"V=URL\")                                                  | \"[INSTALL_FOLDER]\\IBM\\SPSS\\DataCollection\\6\\DDL\\Data\\Data Collection File\\household.mdd\"    |
    | Format(MDM.URL, \"L\")                                                  | \"[INSTALL_FOLDER]\\ibm\\spss\\datacollection\\6\\ddl\\data\\data collection file\\household.mdd\"  |
    | Format(MDM.URL, \"U\")                                                  | \"[INSTALL_FOLDER]\\IBM\\SPSSDATACOLLECTION\\6\\DDL\\DATA\\DATA COLLECTION FILE\\HOUSEHOLD.MDD\" |
    | MDM.MDMVersion.Split(\".\").Format(\"d4\")                              | \"0002,0010,0000,1664\" |
    | Format(MDM.Variables[\"person[2].tvdays[{Channel_3}].Column\"], \"b;l\")| \"number of days watched last week\" |

    #### 2. Using the Format function in an SQL query
    This example shows the use of the `Format` function in an SQL query that can be run against the IBM® SPSS® Data Collection Data File version of the Household sample data set, *household.ddf*. The function is used to display the value of a decimal variable called Satisfaction as a fixed point decimal and as a percentage figure:
    ```sql
    SELECT DISTINCT
        satisfaction,
        satisfaction.Format('f2') AS FixedPoint,
        Format(satisfaction / 10.0, 'p0') AS Percentage
    FROM hdata.person.trip
    ```
    Here is the result set:

    | satisfaction     | FixedPoint | Percentage     |
    | :--------------- | :--------- | :---------     |
    | 8.5              | 8.50       | 85%    |
    | 9                | 9.00       | 90%    |
    | 7.75             | 7.75       | 78%    |
    | 8                | 8.00       | 80%    |
    | 7.5              | 7.50       | 75%    |
    | 9.5              | 9.50       | 95%    |
    | 10               | 10.00      | 100%   |
    | 5                | 5.00       | 50%    |
    | 8.30000019073486 | 8.30       | 83%    |
    | 7.90000009536743 | 7.90       | 79%    |
    | 8.19999980926514 | 8.20       | 82%    |
    | 6.30000019073486 | 6.30       | 63%    |
    | 5.5              | 5.50       | 55%    |

    This next example shows another SQL query that can be run against the Household sample data set, *household.ddf*. The Format function is used to display the value of a categorical variable called Country in five alternative formats:
    ```sql
    SELECT DISTINCT
        country,
        country.Format('v2') AS Value,
        country.Format('a') AS Name,
        country.Format('b') AS Label,
        country.Format('b;U') AS LabelUpperCase,
        country.Format('s4') AS [Count]
    FROM hdata.person.trip
    ```
    Here is the result set:

    | country         |  Value | Name          | Label         | LabelUpperCase | Count  |
    | :-------------- |  :----- | :------------ | :------------ | :------------ |  :----- |
    | {united_states} |  85    | United_States | United States | UNITED STATES  | 0001  |
    | {switzerland}   |  83    | Switzerland   | Switzerland   | SWITZERLAND    | 0001  |
    | {india}         |  68    | India         | India         | INDIA          | 0001  |
    | {portugal}      |  78    | Portugal      | Portugal      | PORTUGAL       | 0001  |
    | {holland}       |  67    | Holland       | Holland       | HOLLAND        | 0001  |
    | {morocco}       |  75    | Morocco       | Morocco       | MOROCCO        | 0001  |
    | {australia}     |  57    | Australia     | Australia     | AUSTRALIA      | 0001  |
    | {france,spain}  |  64,81 | France,Spain  | France,Spain  | FRANCE,SPAIN   | 0002  |
    | {china,japan}   |  61,71 | China,Japan   | China,Japan   | CHINA,JAPAN    | 0002  |
    | {germany}       |  65    | Germany       | Germany       | GERMANY        | 0001 |

    The first column shows the categorical variable without any formatting, the second column shows the categorical values, the third and fourth columns show the values of the Name and Label properties respectively, the fifth column shows the result of applying two style codes, and the sixth column shows the number of elements in the categorical variable.

    #### 3. Using the Format function in an interview script
    The next example shows the `Format` function being used in an interview script that will run in version 3.0 (or later) of IBM® SPSS® Data Collection Interviewer Server. The Format function is used to display the labels and formatted values of the categories selected in the LikeColors question:
    ```ds
    Metadata(en-US, Question, label)
        LikeColors \"Which colors do you like?\" categorical
        {
            red \"I like Red\",
            blue \"I like Blue\",
            green \"I like Green\",
            yellow \"I like Yellow\",
            pink \"I like Pink\",
            purple \"I like Purple\",
            orange \"I like Orange\"
        };

        LikeColorsResponse \"{InsertHere}\" info;
    End Metadata

    Routing(Web)
        LikeColors.Ask()

        Dim labels, values, str
        labels = LikeColors.Format(\"b\")    ' labels of responses
        labels = labels.Replace(\",\", mr.CrLf)
        values = LikeColors.Format(\"d3\")   ' response values with leading zeroes
        str = \"You chose these:\" + mr.CrLf + labels + mr.CrLf
        str = str + \"Their numerical values are (\" + values + \").\"

        LikeColorsResponse.Ask(str)
    End Routing
    ```
    !'
    Function Format(Optional Style As String, Optional Width As Long, Optional Locale As Long) As String
    End Function

    '!
    ```ds
    (function) LCase(): String
    ```
    -----------------------------------
    Returns a string that has been converted to lower case.
    + `return`: *String* - Lowercase copy of `Val`.

    ### Remarks
    The input string is converted to lower case, according to the rules of the input locale.
    If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".
    How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").

    ### Examples
    This example uses the `LCase` function to return a copy of the contents of the address variable converted to lower case:
    ```ds
    address.LCase()
    ```
    !'
    Function LCase() As String
    End Function

    '!
    ```ds
    (function) LTrim(): String
    ```
    -----------------------------------
    Returns a copy of a string with any leading spaces removed.
    + `return`: *String* - Copy of `Val` with leading spaces removed.

    ### Remarks
    `LTrim` removes white space (such as space and tab characters) that appears at the beginning of the input string. `LTrim` uses the rules of the input locale when interpreting white space.
    If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".
    How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").

    ### Examples
    This example uses the `LTrim` function to return a copy of the contents of the address variable with any leading spaces removed:
    ```ds
    address.LTrim()
    ```
    !'
    Function LTrim() As String
    End Function

    '!
    ```ds
    (function) RTrim(): String
    ```
    -----------------------------------
    Returns a copy of a string with any trailing spaces removed.
    + `return`: *String* - Copy of `Val` with trailing spaces removed.

    ### Remarks
    `RTrim` removes white space (such as space and tab characters) that appears at the end of the input string. RTrim uses the rules of the input locale when interpreting white space.
    If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".
    How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").

    ### Examples
    This example uses the `RTrim` function to return a copy of the contents of the address variable with any trailing spaces removed:
    ```ds
    address.RTrim()
    ```
    !'
    Function RTrim() As String
    End Function

    '!
    ```ds
    (function) Split([Delimiter: String = \" \"], [Count: Long]): Categorical
    ```
    -----------------------------------
    Returns an array that contains substrings.
    + `Delimiter`: *String* - Optional. `Delimiter` between substrings. The default is a single space (\" \").
    + `Count`: *Long* - Optional. The maximum number of substrings to return. If omitted or less than zero, all substrings are returned.
    + `return`: *Categorical* - An *array* containing the substrings from `Val`.

    ### Remarks
    This function is useful when you are parsing text strings that contain a number of substrings separated by a character such as a comma (,). For example, the lines of an address are often separated by a comma.
    If `Val` is an empty string, the return value is an empty array. Otherwise, if Delimiter is an empty string or is not found in `Val`, the return value is an array containing one item, a copy of `Val`. If the current data value is *NULL*, `Val` is an empty string and the return value is an empty array.
    How you specify a text string as an argument depends on whether you are using the function in an SQL query or elsewhere, such as in mrScriptBasic or mrScriptMetadata, or when creating filters in IBM® SPSS® Data Collection Survey Tabulation or quotas in IBM® SPSS® Data Collection Interviewer Server. Enclose text strings in single quotation marks (' ') in SQL queries and enclose text strings in double quotation marks (\" \") everywhere else.

    @Note - The `Split` function returns a categorical value, making it impossible to assign elements of the returned array. It should also be noted that the result from the `Split` function is not a real categorical value, because the elements of a categorical must be of type *Long* (int - VT_I4), not text. The parser treats the value as a categorical, but an error is returned when attempting to pass the value into a function that expects a real categorical (ContainsAny for example).

    ### Examples
    This mrScriptBasic example uses the `Split` function to return the first line and the first two lines of an address that is stored in a single variable with the lines separated by commas. It also shows an example of using the function using the default parameters:
    ```ds
    Dim Address, FirstLine, FirstTwoLines, Defaults

    Address = \"363 Park Road, Ashford, Kent\"

    FirstLine = Address.Split(",", 1)      ' Returns {363 Park Road}
    FirstTwoLines = Address.Split(",", 2)  ' Returns {363 Park Road, Ashford}
    Defaults = Address.Split()             ' Returns {363,Park,Road,,Ashford,,Kent}
    ```
    !'
    Function Split(Optional Delimiter As String = " ", Optional Count As Long) As Categorical
    End Function

    '!
    ```ds
    (function) Replace(Key: Variant, Replacement: Variant, [Start: Long], [Count: Long], [IgnoreCase: Boolean]): Variant
    ```
    -----------------------------------
    Replaces part of a text or categorical value with another value of the same type.
    + `Key`: *Variant* - Variant value to look for in `Val`, of the same type as `Val`.
    + `Replacement`: *Variant* - Variant value with which to replace `Key`, of the same type as `Val`.
    + `Start`: *Long* - Optional. Position in `Val` (starting from 0), from which to start searching for `Key`. If omitted or less than 0, searching starts at the start of `Val`.
    + `Count`: *Long* - Optional. Maximum number of replacements to make. If omitted or less than 0, all possible replacements are made.
    + `IgnoreCase`: *Boolean* - Optional. Whether to do case-insensitive comparison for `Key`. The default is *False*.
    + `return`: *Variant* - Copy of `Val` with `Key` replaced with `Replacement`.

    ### Remarks
    If `Val` is of type `Text`, `Key` and `Replacement` are converted to text values, unless they are already text values or *NULL*. If `Val` is of type *Categorical*, `Key` and `Replacement` are converted to categorical values, unless they are already categorical values or *NULL*. An error occurs if `Key` or `Replacement` cannot be converted to the required type.
    If `Val` is *NULL*, the return value is *NULL*. If `Key` is *NULL*, no replacements are made. If `Replacement` is *NULL*, occurrences of `Key` are removed instead of being replaced. If `Val` is of any other type, an error occurs.

    ### Examples
    The following mrScriptBasic example shows the use of the `Replace` function to replace all the hyphens in a text variable with spaces.
    ```ds
    strVal = strVal.Replace(\"-\", \" \")
    ```
    !'
    Function Replace(Key As Variant, Replacement As Variant, Optional Start As Long, Optional Count As Long, Optional IgnoreCase As Boolean) As Variant
    End Function

    '!
    ```ds
    (function) Trim(): String
    ```
    -----------------------------------
    Returns a copy of a string with any leading and trailing spaces removed.
    + `return`: *String* - Copy of `Val` with leading and trailing spaces removed.

    ### Remarks
    `Trim` removes white space (such as space and tab characters) that appears at the beginning and end of the input string. `Trim` uses the rules of the input locale when interpreting white space.
    If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".
    How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").

    ### Examples
    This example uses the `Trim` function to return a copy of the contents of the address variable with any leading and trailing spaces removed:
    ```ds
    address.Trim()
    ```
    !'
    Function Trim() As String
    End Function

    '!
    ```ds
    (function) UCase(): String
    ```
    -----------------------------------
    Returns a string that has been converted to upper case.
    + `return`: *String* - Uppercase copy of `Val`.

    ### Remarks
    The input string is converted to upper case, according to the rules of the input locale.
    If the current data value is *NULL*, `Val` is \"\" and the return value is \"\".
    How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").

    ### Examples
    This example returns an uppercase copy of the contents of the *name* variable:
    ```ds
    name.UCase()
    ```
    The next example uses the `Trim` and `Mid` functions in addition to the `UCase` function. The example returns characters 5-10 of the name variable converted to upper case and with any leading or trailing spaces removed:
    ```ds
    Trim(UCase(name.Mid(4, 5)))
    ```
    !'
    Function UCase() As String
    End Function

    '!
    ```ds
    (function) Find(Key: Variant, [Skip: Long = 0], [Reverse: Boolean = False], [IgnoreCase: Boolean = True]): Long
    ```
    -----------------------------------
    Searches a string, a category list, or an array, for a specified substring, subcategory list, or subarray, and if it is found, returns its start position.
    + `Key`: *Variant* - Value to search for in `Val`.
    + `Skip`: *Long* - Optional. The number of positions to skip in `Val` before starting the search. If `Reverse` is *True*, `Skip` is the number of positions to skip from the end of `Val`. If `Reverse` is omitted or *False*, Skip is the number of positions to skip from the start of `Val`. Treated as 0 if omitted or is < 0.
    + `Reverse`: *Boolean* - Optional. If *True*, `Val` is searched backwards. If `Reverse` is omitted or *False*, `Val` is searched forwards.
    + `IgnoreCase`: *Boolean* - Optional. If *False*, the comparison is case-sensitive. If `IgnoreCase` is omitted or *True*, the comparison is case-insensitive.
    + `return`: *Long* - Position in `Val`, relative to the start of `Val`, of `Key` if found, -1 otherwise.

    ### Remarks
    If `Val` is *Text*, `Key` is converted to text if necessary and is searched for as a substring of `Val`. Unless `IgnoreCase` is *False*, the comparison is case-insensitive.
    If `Val` is *Categorical* or an *Array* (which can contain values of any type), Key can be a *long*, *double*, *text*, *date*, *boolean*, or *categorical* value, or an *array*. When comparing `Key` (or the items in `Key`) with the items in `Val`, the normal conversion and comparison rules for variant types are used if necessary. Unless IgnoreCase is False, the comparison of text items (or items converted to text) is case-insensitive. If either item is *Null*, they are equal only if both are *Null*. If `Key` is a categorical value or an array, it is found only if its items occur as a sequence of consecutive items in `Val` and in the same order.
    If either `Val` or Key is *NULL*, the return value is -1 (not found). If `Val` is not *Text*, *Categorical*, or an *Array*, an error occurs.
    How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").

    ### Examples

    | Function call             | Val                            | Key                  |  Result |
    | :----------------         | :-----------                   | :-------------       | :-----  |
    | Find(Val, Key)            | 24 St John's Road, Barnes      | barnes               | 19      |
    | Find(Val, Key, , True)    | 3 Glasgow Hill, Glasgow        | glasgow              | 16      |
    | Find(Val, Key)            | {3,7,8,1,9,10,5,4}             | 5                    | 6       |
    | Find(Val, Key, 7)         | {3,7,8,1,9,10,5,4}             | 5                    | -1      |
    | Find(Val, Key, , , False) | 24 St John's Road, Barnes      | barnes               | -1      |
    | Find(Val, Key)            | Split(\"The quick brown fox\") | Split(\"brown fox\") | 2       |

    **Text variables**. These examples use the name and address variables, which are text variables that store respondents' names and addresses, respectively. These examples show how you would use the Find function in mrScriptBasic or mrScriptMetadata. In SQL queries, you should enclose text strings in single quotation marks (' ') instead of double quotation marks (\" \").
    The following example selects any respondent whose address contains \"London\" in upper case, lower case, or a mixture of both cases. Find returns -1 when the search string has not been found. In this example the <> operator is used to test that the return value is not -1, which means that \"London\" exists somewhere in the text being searched.
    ```ds
    address.Find(\"London\") <> -1
    ```
    Find lets you search for a string in a particular position. This is useful when the position of the search string in the text you are searching is important. For example, the following selects respondents whose names begin with the string \"Brian\":
    ```ds
    Find(name, \"Brian\") = 0
    ```

    **Categorical variables**. These examples use the *remember* multiple response variable.
    This example selects all respondents who chose the *Dinosaurs* category regardless of its position in the list of categories chosen:
    ```ds
    remember.Find({dinosaurs}) <> -1
    ```
    The next example selects respondents for whom the *Dinosaurs* category is the first category in the list of their responses:
    ```ds
    remember.Find({dinosaurs}) = 0
    ```
    !'
    Function Find(Key As Variant, Optional Skip As Long = 0, Optional Reverse As Boolean = False, Optional IgnoreCase As Boolean = True) As Long
    End Function

    '!
    ```ds
    (function) Left(Length: Long): Variant
    ```
    -----------------------------------
    Returns a string containing the first characters from a string, a category list containing the first categories from a category list, or an array containing the first elements from an array.
    + `Val`: *String* | *Categorical* | *Array* - *Text* value, *categorical* value, or *Array* to operate on.
    + `Length`: *Long* - Number of characters, categories, or elements to return. If `Length` is greater than the number of items available, all of the items are returned.
    + `return`: *Variant* - The required characters, categories, or elements from `Val`.

    ### Remarks
    For type *Text*, the return value is of type *Text*, and contains `Length` characters from the start of `Val`. For type *Categorical*, the return value is of type *Categorical*, and contains Length categories from the start of `Val`. For an array (which can contain values of any type), the return value is an array, and contains `Length` elements from the start of `Val`. For any other type, an error occurs.
    When `Val` is *NULL*, the return value is *NULL*.

    ### Examples

    | Function call     | Val                            | Length | Result            |
    | :-------------    | :-------------                 | :----- | :---------------- |
    | Left(Val, Length) | 24 St John's Road, Barnes      | 10     | 24 St John        |
    | Left(Val, Length) | {4,2,9}                        | 1      | {4}               |
    | Left(Val, Length) | Split(\"The quick brown fox\") | 2      | {The,quick}       |

    The following example returns the first six characters of the *name* text variable:
    ```ds
    name.Left(6)
    ```
    The following example returns the first three categories stored in the *remember* multiple response variable:
    ```ds
    remember.Left(3)
    ```
    !'
    Function Left(Length As Long) As Variant
    End Function

    '!
    ```ds
    (function) Len(): Long
    ```
    -----------------------------------
    Returns a *Long* containing the number of characters in a string, the number of categories in a category list, or the number of elements in an array.
    + `Val`: *String* | *Categorical* | *Array* - *Text* value, *Categorical* value, or *Array* to operate on.
    + `return`: *Long* - Numbers of characters, categories, or elements in `Val`.

    ### Remarks
    For type *Text*, the return value is the number of characters in `Val`. For type *Categorical*, the return value is the number of categories in `Val`. For an *Array* (which can contain values of any type), the return value is the number of elements in `Val`. For any other type, an error occurs.
    When `Val` is *NULL*, the return value is zero.

    ### Examples

    | Function call | Val                            | Result |
    | :------------ | :---------------               | :----  |
    | Len(Val)      | 24 St John's Road, Barnes      | 25 |
    | Len(Val)      | {4,2,9}                        | 3 |
    | Len(Val)      | Split(\"The quick brown fox\") | 4 |

    The following example returns the number of characters stored in the *address* text variable:
    ```ds
    address.Len()
    ```
    The following example returns the number of categories selected by the respondent in response to the *remember* multiple response question:
    ```ds
    remember.Len()
    ```
    !'
    Function Len() As Long
    End Function

    '!
    ```ds
    (function) Mid(Start: Long, [Length: Long]): Variant
    ```
    -----------------------------------
    + `Val`: *String* | *Categorical* | *Array* - *Text* value, *categorical* value, or *array* to operate on.
    + `Start`: *Long* - Position in `Val` of the first character, category, or element wanted (counting from 0). If `Start` is greater than the number of items in `Val`, no items are returned. If `Start` is less than 0, items are returned from the start of `Val`.
    + `Length`: *Long* - Optional. Number of characters, categories, or elements to return. If `Length` is omitted, or if there are fewer than *Lengthcharacters* (including the `Start` character), all characters from `Start` to the end of the string are returned. If `Start` + `Length` is < 1, no items are returned.
    + `return`: *Variant* - The required characters, categories, or elements from `Val`.

    ### Remarks
    For type *Text*, the return value is of type *Text*, and contains `Length` characters from the position `Start` in `Val`. For type *Categorical*, the value is of type *Categorical*, and contains `Length` categories from the position `Start` in `Val`. For an *array* (which can contain values of any type), the return value is an *array*, and contains `Length` elements from the position `Start` in `Val`. For any other type, an error occurs.
    When `Val` is *NULL*, the return value is *NULL*.

    ### Examples

    | Function call           | Val                            | Start | Length | Result      |
    | :-------------          | :---------------               | :---- | :----- | :---------- |
    | Mid(Val, Start, Length) | 24 St John's Road, Barnes      | 10    | 15     | 's Road, Barnes |
    | Mid(Val, Start, Length) | {4,2,9}                        | 2     | 1      | {9}             |
    | Mid(Val, Start, Length) | {4,2,9}                        | 6     | 3      | {}              |
    | Mid(Val, Start, Length) | {4,2,9}                        | 0     | 2      | {4,2}           |
    | Mid(Val, Start, Length) | {4,2,9}                        | 0     |        | {4,2,9}         |
    | Mid(Val, Start, Length) | Split(\"The quick brown fox\") | 1     | 2      | {quick,brown}   |

    The following example returns characters 8-17 from the *address* text variable:
    ```ds
    address.Mid(7, 10)
    ```
    The following example returns the fourth category from the list of categories stored in the *remember* multiple response variable:
    ```ds
    remember.Mid(3, 1)
    ```
    For respondents who chose less than four categories, this returns an empty category list ({}).
    !'
    Function Mid(Start As Long, Optional Length As Long) As Variant
    End Function

    '!
    ```ds
    (function) Right(Length: Long): Variant
    ```
    -----------------------------------
    Returns a string containing the last characters from a string, a category list containing the last categories from a category list, or an array containing the last elements from an array.
    + `Val`: *String* | *Categorical* | *Array* - *Text* value, *categorical* value, or *array* to operate on.
    + `Length`: *Long* - Number of characters, categories, or elements to return. If `Length` is greater than the number of items available, all of the items are returned.
    + `return`: *Variant* - The required characters, categories, or elements from `Val`.

    ### Remarks
    For type *Text*, the return value is of type *Text*, and contains Length characters from the end of `Val`. For type *Categorical*, the return value is of type *Categorical*, and contains `Length` categories from the end of `Val`. For an *array* (which can contain values of any type), the return value is an *array*, and contains `Length` elements from the end of `Val`. For any other type, an error occurs.
    When `Val` is *NULL*, the return value is *NULL*.

    ### Examples

    | Function call      | Val                            | Length | Result       |
    | :----------------  | :--------------------          | :----- | :----------- |
    | Right(Val, Length) | 24 St John's Road, Barnes      | 6      | Barnes       |
    | Right(Val, Length) | {4,2,9,15,6,7}                 | 1      | {7}          |
    | Right(Val, Length) | Split(\"The quick brown fox\") | 3      | {quick,brown,fox} |

    The following example returns the 10 rightmost characters stored in the *address* text variable:
    ```ds
    address.Right(10)
    ```
    The following example returns the last two categories in the list of categories stored in the *remember* multiple response variable:
    ```ds
    remember.Right(2)
    ```
    !'
    Function Right(Length As Long) As Variant
    End Function

End Class

Class Categorical Implements IEnumerable

    '!
    ```ds
    (function) AnswerCount(): Long
    ```
    ------------------------------------------
    Returns the number of categories selected in a category list.
    + `return`: *Long* - Number of categories in Val.
    ### Example
    For example, to define a quota for respondentswho can name more than five brands of fizzy drinks:
    ```ds
    fizzy.AnswerCount() > 5
    ```
    !'
    Function AnswerCount() As Long
    End Function

    '!
    ```ds
    (function) ContainsAll(Answers: Variant, [Exactly: Boolean]): Boolean
    ```
    -----------------------------------
    Identifies whether a category list contains all of the categories in a given list.
    + `Answers`: *Variant* - Variant value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *True*, unless `Exactly` is *True* and `Val` is not empty.
    + `Exactly`: *Boolean* - Optional. If *True*, the function returns *True* only if `Val` contains all of the categories in `Answers` and no others. If `Exactly` is omitted or *False*, the function returns *True* if all of the categories in `Answers` are in `Val`, even if `Val` contains other categories.
    + `return`: *Boolean* - *True* if `Val` contains all of the categories in `Answers`, otherwise *False*.

    ### Remark
    + If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is *False*. If `Answers` is *NULL*, the return value is *False*.
    + This function is equivalent to the >= comparison operator for *Categorical* values, except that the *NULL* behavior is different. However, using the >= operator is generally faster than using the `ContainsAll` function.

    ### Examples
    Like `ContainsAny` and `ContainsSome`, `ContainsAll` is typically used to filter multiple response data. The Museum sample data set contains a multiple response variable called *remember*, which records the galleries that respondents remember viewing. You could use the following example to create a filter to select respondents who chose the *Fossils* and *Dinosaurs* categories in response to the question:

    ```ds
    remember.ContainsAll({fossils, dinosaurs})
    ```

    This filter will select respondents who chose both *Fossils* and *Dinosaurs* regardless of whether they chose any additional categories. To restrict the filter to respondents who chose *Fossils* and *Dinosaurs* and no other categories, set `Exactly` to *True*:

    ```ds
    remember.ContainsAll({fossils, dinosaurs}, True)
    ```
    !'
    Function ContainsAll(Answers As Variant, Optional Exactly As Boolean) As Boolean
    End Function

    '!
    ```ds
    (function) ContainsAny(Answers: Variant, [Exactly: Boolean]): Boolean
    ```
    -----------------------------------
    Identifies whether a category list contains one or more categories in a given list.
    + `Answers`: *Variant* - *Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *False*.
    + `Exactly`: *Boolean* - Optional. If *True*, the function returns *False* if `Val` contains any categories that are not in `Answers`. If `Exactly` is omitted or *False*, the function returns *True* if any of the categories in `Answers` are in `Val`, even if `Val` contains other categories.
    + `return`: *Boolean* - *True* if `Val` contains the categories as specified, otherwise *False*.

    ### Remarks
    If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is *False*. If `Answers` is *NULL*, the return value is *False*.

    ### Examples
    Like `ContainsAll` and `ContainsSome`, `ContainsAny` is typically used to filter multiple response data. The Museum sample data set contains a multiple response variable called *remember*, which records the galleries that respondents *remember* viewing. You could use the following example to create a filter to select respondents who chose either or both of the *Fossils* and *Dinosaurs* categories in response to the question:
    ```ds
    remember.ContainsAny({fossils, dinosaurs})
    ```
    This filter will select respondents who chose either one or both of the two categories regardless of whether they chose any additional categories. For example, it will select respondents who chose any of the following:
    + The *Fossils* category only.
    + The *Dinosaurs* category only.
    + The *Fossils* and *Dinosaurs* categories only.
    + The *Fossils* category and any other category.
    + The *Dinosaurs* category and any other category.

    To restrict the filter to respondents who chose either or both of the two specified categories and no others, set `Exactly` to *True*:
    ```ds
    remember.ContainsAny({fossils, dinosaurs}, True)
    ```
    !'
    Function ContainsAny(Answers As Variant, Optional Exactly As Boolean) As Boolean
    End Function

    '!
    ```ds
    (function) ContainsSome(Answers: Variant, [Min: Long], [Max: Long], [Exactly: Boolean]): Boolean
    ```
    -----------------------------------
    Identifies whether a category list contains some of the categories in a given list.
    + `Answers`: *Variant* - *Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for in `Val`. If `Answers` is empty, the function returns *True* (unless `Exactly` is *True* and `Val` is not empty).
    + `Min`: *Long* - Optional. The minimum number of categories in `Answers` that must be in `Val` for the function to return *True*. If omitted, the minimum is one.
    + `Max`: *Long* - Optional. The maximum number of categories in `Answers` that must be in `Val` for the function to return *True*. If omitted, the maximum is the number of categories in `Answers`.
    + `Exactly`: *Boolean* - Optional. If *True*, the function returns *True* only if `Val` contains the specified number of categories and no others. If `Exactly` is omitted or *False*, the function returns *True* if the specifiednumber of categories in `Answers` are in `Val`, even if `Val` contains other categories.
    + `return`: *Boolean* - *True* if `Val` contains the specified categories, otherwise *False*.

    ### Remarks
    If the current value is *NULL*, `Val` is an empty Categorical value ({}) and the return value is *False*. If `Answers` is *NULL*, the return value is *False*.

    ### Examples
    Like `ContainsAll` and `ContainsAny`, `ContainsSome` is typically used to filter multiple response data. The Museum sample data set contains a multiple response variable called *remember*, which records the galleries that respondents *remember* viewing. You could use the following example to create a filter to select respondents who chose two or more of four specified categories in response to the question:
    ```ds
    remember.ContainsSome({fossils, dinosaurs, birds, whales}, 2)
    ```
    To restrict the filter to respondents who chose at least two, but not more than three, of the four categories, set `Max` to 3:
    ```
    remember.ContainsSome({fossils, dinosaurs, birds, whales}, 2, 3)
    ```
    To restrict the filter to respondents who chose at least two, but not more than three, of the four categories and no others, set `Exactly` to *True*:
    ```
    remember.ContainsSome({fossils, dinosaurs, birds, whales}, 2, 3, True)
    ```
    !'
    Function ContainsSome(Answers As Variant, Optional Min As Long, Optional Max As Long, Optional Exactly As Boolean) As Boolean
    End Function

    '!
    ```ds
    (function) DefinedCategories([Answers: Variant]): Categorical
    ```
    -----------------------------------
    Returns a set of categories of a categorical variable.
    + `Answers`: *Variant* - Optional. *Variant* value of type *Categorical* or *Text*, specifying a set of categories. If omitted, all categoriesfrom the `VariableInstance` are returned.
    + `return`: *Categorical* - Set of category numbers as defined in the VariableInstance.

    ### Remarks
    `Val` may refer to any type of MDM object that has elements, for example, `Field`, `Array` , `Grid` or `VariableInstance`, or it may be an Elements list itself.
    If `Answers` is of type Text, it is assumed to be a category expression and is resolved to a list of categories. If `Answers` is of type *Categorical* and contains category names, they are converted to category numbers.
    This function requires the case data to be opened with an MDM document or for a script to have an open MDM document available to it. Otherwise, an error will occur.
    If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is also an empty *Categorical* value. If `Answers` is *NULL*, the return value is all of the categories defined in the current variable.

    ### Examples
    This example shows how the `DefinedCategories` function can be used in an SQL query on a multiple response variable to define groups based on the categories.
    ```sql
    SELECT groupby.col[0] AS Museums,
        BASE(museums) AS 'Base'
    FROM vdata
    WHERE museums IS NOT NULL
    GROUP BY museums ON museums.DefinedCategories()
    ```

    Here is the result set:

    | Museums                               | Base    |
    | :------------------------------------ | :------ |
    | {national_museum_of_science}          | 333     |
    | {museum_of_design}                    | 92      |
    | {institute_of_textiles_and_fashion}   | 47      |
    | {archeological_museum}                | 26      |
    | {national_art_gallery}                | 19      |
    | {northern_gallery}                    | 21      |
    | {other}                               | 37      |
    | {not_answered}                        | 0       |

    !'
    Function DefinedCategories(Optional Answers As Variant) As Categorical
    End Function

    '!
    ```ds
    (function) DefinedElements([Types: Long]): Categorical
    ```
    -----------------------------------
    Returns a set of elements of a categorical variable.
    The possible values for Types are shown in the following table.
    + `Types`: *Long* - Optional. Flags specifying which types of `Element` objects to include. The default is (Category + Base).
    + `return`: *Categorical* - Set of category numbers as defined in the VariableInstance.

    | Value       | Description           |
    | :---------- | :-------------------- |
    | 1           | Category elements     |
    | 2           | Base elements         |
    | 4           | Subtotal elements     |
    | 8           | Summary data elements |
    | 16          | Derived elements      |
    | 32          | Subheading elements   |

    The flags may be used in any combination, to select elements of more than one type. For example, to select all Category and Base elements, use `1 + 2 = 3`.

    ### Remarks
    `Val` may refer to any type of MDM object that has elements, for example, Field, Array , Grid or VariableInstance, or it may be an Elements list itself.
    If the current value is *NULL*, `Val` is an empty Categorical value ({}) and the return value is also an empty Categorical value.
    This function requires the case data to be opened with an MDM document or for a script to have an open MDM document available to it. Otherwise, an error will occur.
    Like `DefinedCategories`, `DefinedElements` is typically used to define groups in SQL queries. However, whereas `DefinedCategories` defines groups based on categories only, you can use `DefinedElements` to define groups based on any element type that stores case data or a combination of these element types.

    ### Examples
    The following query creates groups based on all categories and any base elements in the gender and *gender.Ex* variables in the Museum IBM® SPSS® Quanvert™ sample data base. The *gender.Ex* variable is included in the GROUP BY statement because Quanvert DSC stores special elements in a separate variable that has an *.Ex* suffix.
    ```sql
    SELECT groupby.col[0] AS Gender,
        SUM(visits) AS 'Sum of visits'
    FROM vdata
    WHERE visits > 0
    GROUP BY gender.EX + gender
        ON gender.Ex.Definedelements() + gender.Definedelements()
    ```

    Here is the result set:

    | Gender      | Sum of visits |
    | :---------- | :------------ |
    | {base}      | 2131          |
    | {male}      | 1309          |
    | {female}    | 822           |

    !'
    Function DefinedElements(Optional Types As Long) As Categorical
    End Function

    '!
    ```ds
    (function) DefinedFactors([Answers: Variant]): Categorical
    ```
    -----------------------------------
    Returns a set of factor numbers as defined on the categories in a variable.
    + `Answers`: *Categorical* - Optional. *Variant* value of type *Categorical* or *Text*, specifying a set of categories to look for. If omitted, all categoriesfrom the object are used.
    + `return`: *Categorical* - Set of factor numbers as defined in on the categories, matching the order of the categories in *Answers*.

    ### Remarks
    `Val` may refer to any type of MDM object that has elements, for example, Field, Array , Grid or VariableInstance, or it may be an Elements list itself.
    If `Answers` is of type Text, it is assumed to be a category expression and is resolved to a list of categories. If `Answers` is of type Categorical and contains category names, they are converted to category numbers.
    This function requires the case data to be opened with an MDM document or for a script to have an open MDM document available to it. Otherwise, an error will occur.
    The function returns a factor of 0 for sublists and for categories with no factor defined. Factors can be long or double values.
    To sort the returned values, use *SortAsc* or *SortDesc*.
    !'
    Function DefinedFactors(Optional Answers As Variant) As Categorical
    End Function

    '!
    ```ds
    (function) Difference(Answers: Variant): Categorical
    ```
    -----------------------------------
    Returns the difference of two category lists--that is, it returns the categories that are in the first category list but not in the second. The categories are returned in the order in which they appear in the first category list.
    + `Answers`: *String* | *Categorical* - *Variant* value of type *Categorical* or *Text*, specifying a set of categories.
    + `return`: *Categorical* - Set of categories that are in `Val` but not in `Answers`, in the order in which they appear in `Val`.

    ### Remarks
    If the current value is *NULL*, `Val` is an empty Categorical value ({}) and the return value is also an empty Categorical value. If `Answers` is *NULL*, the return value is `Val`.
    This function is equivalent to the `subtract (-) arithmetic operator` for Categorical values, except that `Difference` can operate on named categories and the *NULL* behavior is different.
    However, using the `subtract (-) operator` is generally faster than using the `Difference` function.

    ### Examples

    | Function call       | Q1            | Q2            | Result     |
    | :------------------ | :------------ | :------------ | :--------- |
    | Q1.Difference(Q2)   | {1,2,3}       | {4,5,6}       | {1,2,3}    |
    | Q1.Difference(Q2)   | {1,2,3,4,5,6} | {4,5,6}       | {1,2,3}    |
    | Difference(Q1, Q2)  | {1,2,3,4,5,6} | {3,6,4,1,2,5} | {}         |

    Like `Intersection` and `XUnion`, `Difference` is useful when categorical variables have identical or overlapping category lists.
    For example, the *remember* and *interest* variables are categorical variables that have similar category lists. *remember* is a multiple response variable that records which galleries the respondents *remember* viewing, and interest is a single response variable that records which gallery respondents found most interesting. In the following example, the `Difference` function is used to remove the responses given to the *interest* question from the responses given to the *remember* question. The `>=` operator then tests whether the resulting list of categories includes the *Fossils* category. You could use this expression to create a filter to select respondents who remember the *Fossils* gallery, but who did not find it the most interesting gallery.
    ```ds
    Difference(remember, interest) >= {FOSSILS}
    ```
    !'
    Function Difference(Answers As Variant) As Categorical
    End Function

    '!
    ```ds
    (function) Factor(): Variant
    ```
    -----------------------------------
    Returns the factor defined for an element of a categorical variable.
    + `return`: *Variant* - Factor number as defined on the element.

    ### Remarks
    If `Val` contains more than one element, only the factor for the first element is returned. If Val is {}, the return value is *NULL*. If the current data value is *NULL*, Val is {} and the return value is *NULL*.
    If the first \"element\" in `Val` is actually (the MDM value of) an element list, the sublist is expanded until an actual element is found, if any. If the element does not have a factor defined, the return value is *NULL*. Note that the factor can be a *Long* or *Double* value.
    !'
    Function Factor() As Variant
    End Function

    '!
    ```ds
    (function) GetAnswer(Index: Long): Categorical
    ```
    -----------------------------------
    Returns a specified category in a category list.
    + `Index`: *Long* - Position of category to retrieve from `Val`, starting from 0.
    + `return`: *Categorical* - The category at the requested position in Val, if found, or an empty *Categorical* value if it is not found

    ### Remarks
    If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is also an empty *Categorical* value.

    ### Examples

    | Function call  | Q1        | Index     | Result |
    | :------------- | :-------- | --------- | ------ |
    | GetAnswer(Q1, Index) | {5,1,6,3,2,4} | 0 | {5} |
    | Q1.GetAnswer(Index) | {5,1,6,3,2,4} | 3 | {3} |

    The following example tests whether the Fossils category is in the first position in the list of responses stored for each respondent in the remember multiple response variable:
    ```ds
    remember.GetAnswer(0) = {FOSSILS}
    ```
    !'
    Function GetAnswer(Index As Long) As Categorical
    End Function

    '!
    ```ds
    (function) HasAnswer(Answer: Long): Boolean
    ```
    -----------------------------------
    Identifies whether a specified category is in a category list.
    + `Answer`: *Long* - Category to look for in `Val`.
    + `return`: *Boolean* - *True* if `Val` contains the category, *False* otherwise.

    ### Remarks
    If the current value is *NULL*, Val is an empty *Categorical* value ({}) and the return value is *False*.
    The `HasAnswer` function has been superseded by `ContainsAll`, `ContainsAny`, and `ContainsSome`. However, `HasAnswer` has been retained for backwards compatibility.

    ### Examples

    | Function call         | Response      | Filter  | Result |
    | :-------------------- | :------------ | :------ | :----- |
    | Q1.HasAnswer(Filter)  | {4,2,9,6,1,7} | 10      | False  |
    | HasAnswer(Q1, Filter) | {4,2,9,6,1,7} | 6       | True   |

    The following example selects respondents who chose the category with the mapped category value of 31 (which is the *Dinosaurs* category) in response to the *remember* question. In a multiple response variable, `HasAnswer` returns *True* regardless of whether any other category was chosen in response to the question. This example therefore selects all respondents who chose the *Dinosaurs* category regardless of whether they also chose any other category.
    ```ds
    remember.HasAnswer(31)
    ```
    !'
    Function HasAnswer(Answer As Long) As Boolean
    End Function

    '!
    ```ds
    (function) Intersection([Vals: Variant ...]): Categorical
    ```
    -----------------------------------
    Returns the intersection of two or more category lists--that is, it returns the categories that appear in all of the category lists. The categories are returned in the order in which they appear in the first category list.
    + `Vals`: *String* | *Categorical* - One or more variant values of type *Categorical* or *Text*. Each value specifies a set of categories.
    + `return`: *Categorical* - Set of categories that are in all of `Val` and `Vals`, in the order in which they occur in `Val`.

    ### Remarks
    If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is also an empty Categorical value. If an item in `Vals` is *NULL*, the item is ignored.
    This function is equivalent to the `* arithmetic operator` for *Categorical* values, except that `Intersection` can operate on named categories and the *NULL* behavior is different. However, using the `* operator` is generally **faster** than using the `Intersection` function.

    ### Examples

    | Function call        | Q1            | Q2            | Result    |
    | :-------------       | :--------     | :------------ | :-------- |
    | Q1.Intersection(Q2)  | {4,2,9,6,1,7} | {6,10,3,5,9}  | {9,6}     |
    | Intersection(Q1, Q2) | {4,2,9,6,1,7} | {3}           | {}        |

    | Function call            | Q1            | Q2            | Q3           | Result    |
    | :-------------------     | :------------ | :------------ | :----------- | :-------- |
    | Q1.Intersection(Q2, Q3)  | {5,6,8,2,3}   | {1,3,4,6}     | {2,4,6,7,8}  | {6}       |
    | Intersection(Q1, Q2, Q3) | {5,6,8,2,3}   | NULL          | {2,4,6,7,8}  | {6,8,2}   |

    Like `Difference` and `XUnion`, `Intersection` is useful when categorical variables have identical or overlapping response lists. The *biology* and *education* variables are single response categorical variables that have identical category lists (*Yes*, *No*, and *Not answered*). You could use the `Intersection` function to return the categories that are in both of the category lists. In the following example, the `= operator` tests whether the result is the *Yes* category. You could therefore use this example to select respondents who chose the Yes category in response to both questions.
    ```ds
    biology.Intersection(education) = {yes}
    ```
    !'
    Function Intersection(Optional ParamArray Vals As Variant) As Categorical
    End Function

    '!
    ```ds
    (function) Union([Vals: Variant ...]): Categorical
    ```
    -----------------------------------
    Returns the union of two or more category lists--that is, it returns all of the categories that are in any one or more of the category lists.
    + `Vals`: *Categorical* | *String* - One or more variant values of type *Categorical* or *Text*. Each value specifies a set of categories.
    + `return`: *Categorical* - All of the categories in `Val` , followed by any other categories that are in `Vals`.

    ### Remarks
    If an item in `Vals` is *NULL*, the item is ignored. If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is the union of all non-NULL items in `Vals`.
    This function is equivalent to the `+ arithmetic operator` for *Categorical* values, except that Union can operate on named categories and the *NULL* behavior is different. However, using the `+ operator` is generally faster than using the `Union` function.

    ### Examples

    | Function call       | Q1             | Q2                | Result          |
    | :------------------ | :------------- | :---------------- | :------------   |
    | Union(Q1, Q2)       | {5,1,6,3,2,4}  | {3,6,7,5}         | {5,1,6,3,2,4,7} |
    | Q1.Union(Q2)        | {4,2,9,6,1,7}  | {}                | {4,2,9,6,1,7}   |

    | Function call       | Q1             | Q2                | Q3               | Result          |
    | :------------------ | :------------- | :---------------- | :--------------- | :------------   |
    | Q1.Union(Q2, Q3)    | {6,8,2,3}      | {3,4,6}           | {1,7,8}          | {6,8,2,3,4,1,7} |
    | Union(Q1, Q2, Q3)   | {6,8,2,3}      | {3,4,6}           | NULL             | {6,8,2,3,4}     |

    The following example uses `Union` to combine the results of two single response categorical variables that have similar category lists and tests whether the result includes the *Yes* category. For example, you could use this example to select respondents who chose *Yes* in response to at least one of the questions.
    ```ds
    Union(biology, education) >= {yes}
    ```
    !'
    Function Union(Optional ParamArray Vals As Variant) As Categorical
    End Function

    '!
    ```ds
    (function) XUnion(Answers: Variant): Categorical
    ```
    -----------------------------------
    Returns the exclusive union of two category lists--that is, it returns all of the categories that are in either one of the category lists, but not in both.
    + `Answers`: *Categorical* | *String* - *Variant* value of type *Categorical* or *Text*, specifying a set of categories.
    + `return`: *Categorical* - Set of categories that are in either `Val` or `Answers` but not in both.

    ### Remarks
    If the current value is *NULL*, `Val` is an empty *Categorical* value ({}) and the return value is `Answers`. If `Answers` is *NULL*, the return value is `Val`.
    This function is equivalent to the `/ arithmetic operator` for *Categorical* values, except that it can operate on named categories and the *NULL* behavior is different. However, using the `/ operator` is generally faster than using the `XUnion` function.

    ### Examples

    | Function call  | Q1                | Q2               | Result          |
    | :------------  | :------------     | :------------    | :----------     |
    | XUnion(Q1, Q2) | {3,5,9,10,23,5,6} | {5,16,4,10}      | {3,9,23,6,16,4} |
    | Q1.XUnion( Q2) | {3,5,9,}          | {5,3,9}          | {}              |

    Like the `Difference` and `Intersection` functions, `XUnion` is useful when categorical variables have identical or overlapping category lists. For example the *biology* and *education* variables have identical response lists. In the following example, `XUnion` is used to return any categories that are in either one of the category lists, but not in both and the `>= operator` tests whether the result contains the *Yes* category. For example, you could use this expression to select respondents who chose the *Yes* category in response to either one of the questions, but not to both.
    ```ds
    XUnion(biology, education) >= {yes}
    ```
    !'
    Function XUnion(Answers As Variant) As Categorical
    End Function

    '!
    ```ds
    (function) Find(Key: Variant, [Skip: Long = 0], [Reverse: Boolean = False], [IgnoreCase: Boolean = True]): Long
    ```
    -----------------------------------
    Searches a string, a category list, or an array, for a specified substring, subcategory list, or subarray, and if it is found, returns its start position.
    + `Key`: *Variant* - Value to search for in `Val`.
    + `Skip`: *Long* - Optional. The number of positions to skip in `Val` before starting the search. If `Reverse` is *True*, `Skip` is the number of positions to skip from the end of `Val`. If `Reverse` is omitted or *False*, Skip is the number of positions to skip from the start of `Val`. Treated as 0 if omitted or is < 0.
    + `Reverse`: *Boolean* - Optional. If *True*, `Val` is searched backwards. If `Reverse` is omitted or *False*, `Val` is searched forwards.
    + `IgnoreCase`: *Boolean* - Optional. If *False*, the comparison is case-sensitive. If `IgnoreCase` is omitted or *True*, the comparison is case-insensitive.
    + `return`: *Long* - Position in `Val`, relative to the start of `Val`, of `Key` if found, -1 otherwise.

    ### Remarks
    If `Val` is *Text*, `Key` is converted to text if necessary and is searched for as a substring of `Val`. Unless `IgnoreCase` is *False*, the comparison is case-insensitive.
    If `Val` is *Categorical* or an *Array* (which can contain values of any type), Key can be a *long*, *double*, *text*, *date*, *boolean*, or *categorical* value, or an *array*. When comparing `Key` (or the items in `Key`) with the items in `Val`, the normal conversion and comparison rules for variant types are used if necessary. Unless IgnoreCase is False, the comparison of text items (or items converted to text) is case-insensitive. If either item is *Null*, they are equal only if both are *Null*. If `Key` is a categorical value or an array, it is found only if its items occur as a sequence of consecutive items in `Val` and in the same order.
    If either `Val` or Key is *NULL*, the return value is -1 (not found). If `Val` is not *Text*, *Categorical*, or an *Array*, an error occurs.
    How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").

    ### Examples

    | Function call             | Val                            | Key                  |  Result |
    | :----------------         | :-----------                   | :-------------       | :-----  |
    | Find(Val, Key)            | 24 St John's Road, Barnes      | barnes               | 19      |
    | Find(Val, Key, , True)    | 3 Glasgow Hill, Glasgow        | glasgow              | 16      |
    | Find(Val, Key)            | {3,7,8,1,9,10,5,4}             | 5                    | 6       |
    | Find(Val, Key, 7)         | {3,7,8,1,9,10,5,4}             | 5                    | -1      |
    | Find(Val, Key, , , False) | 24 St John's Road, Barnes      | barnes               | -1      |
    | Find(Val, Key)            | Split(\"The quick brown fox\") | Split(\"brown fox\") | 2       |

    **Text variables**. These examples use the name and address variables, which are text variables that store respondents' names and addresses, respectively. These examples show how you would use the Find function in mrScriptBasic or mrScriptMetadata. In SQL queries, you should enclose text strings in single quotation marks (' ') instead of double quotation marks (\" \").
    The following example selects any respondent whose address contains \"London\" in upper case, lower case, or a mixture of both cases. Find returns -1 when the search string has not been found. In this example the <> operator is used to test that the return value is not -1, which means that \"London\" exists somewhere in the text being searched.
    ```ds
    address.Find(\"London\") <> -1
    ```
    Find lets you search for a string in a particular position. This is useful when the position of the search string in the text you are searching is important. For example, the following selects respondents whose names begin with the string \"Brian\":
    ```ds
    Find(name, \"Brian\") = 0
    ```

    **Categorical variables**. These examples use the *remember* multiple response variable.
    This example selects all respondents who chose the *Dinosaurs* category regardless of its position in the list of categories chosen:
    ```ds
    remember.Find({dinosaurs}) <> -1
    ```
    The next example selects respondents for whom the *Dinosaurs* category is the first category in the list of their responses:
    ```ds
    remember.Find({dinosaurs}) = 0
    ```
    !'
    Function Find(Key As Variant, Optional Skip As Long = 0, Optional Reverse As Boolean = False, Optional IgnoreCase As Boolean = True) As Long
    End Function

    '!
    ```ds
    (function) Left(Length: Long): Variant
    ```
    -----------------------------------
    Returns a string containing the first characters from a string, a category list containing the first categories from a category list, or an array containing the first elements from an array.
    + `Val`: *String* | *Categorical* | *Array* - *Text* value, *categorical* value, or *Array* to operate on.
    + `Length`: *Long* - Number of characters, categories, or elements to return. If `Length` is greater than the number of items available, all of the items are returned.
    + `return`: *Variant* - The required characters, categories, or elements from `Val`.

    ### Remarks
    For type *Text*, the return value is of type *Text*, and contains `Length` characters from the start of `Val`. For type *Categorical*, the return value is of type *Categorical*, and contains Length categories from the start of `Val`. For an array (which can contain values of any type), the return value is an array, and contains `Length` elements from the start of `Val`. For any other type, an error occurs.
    When `Val` is *NULL*, the return value is *NULL*.

    ### Examples

    | Function call     | Val                            | Length | Result            |
    | :-------------    | :-------------                 | :----- | :---------------- |
    | Left(Val, Length) | 24 St John's Road, Barnes      | 10     | 24 St John        |
    | Left(Val, Length) | {4,2,9}                        | 1      | {4}               |
    | Left(Val, Length) | Split(\"The quick brown fox\") | 2      | {The,quick}       |

    The following example returns the first six characters of the *name* text variable:
    ```ds
    name.Left(6)
    ```
    The following example returns the first three categories stored in the *remember* multiple response variable:
    ```ds
    remember.Left(3)
    ```
    !'
    Function Left(Length As Long) As Variant
    End Function

    '!
    ```ds
    (function) Len(): Long
    ```
    -----------------------------------
    Returns a *Long* containing the number of characters in a string, the number of categories in a category list, or the number of elements in an array.
    + `Val`: *String* | *Categorical* | *Array* - *Text* value, *Categorical* value, or *Array* to operate on.
    + `return`: *Long* - Numbers of characters, categories, or elements in `Val`.

    ### Remarks
    For type *Text*, the return value is the number of characters in `Val`. For type *Categorical*, the return value is the number of categories in `Val`. For an *Array* (which can contain values of any type), the return value is the number of elements in `Val`. For any other type, an error occurs.
    When `Val` is *NULL*, the return value is zero.

    ### Examples

    | Function call | Val                            | Result |
    | :------------ | :---------------               | :----  |
    | Len(Val)      | 24 St John's Road, Barnes      | 25 |
    | Len(Val)      | {4,2,9}                        | 3 |
    | Len(Val)      | Split(\"The quick brown fox\") | 4 |

    The following example returns the number of characters stored in the *address* text variable:
    ```ds
    address.Len()
    ```
    The following example returns the number of categories selected by the respondent in response to the *remember* multiple response question:
    ```ds
    remember.Len()
    ```
    !'
    Function Len() As Long
    End Function

    '!
    ```ds
    (function) Mid(Start: Long, [Length: Long]): Variant
    ```
    -----------------------------------
    + `Val`: *String* | *Categorical* | *Array* - *Text* value, *categorical* value, or *array* to operate on.
    + `Start`: *Long* - Position in `Val` of the first character, category, or element wanted (counting from 0). If `Start` is greater than the number of items in `Val`, no items are returned. If `Start` is less than 0, items are returned from the start of `Val`.
    + `Length`: *Long* - Optional. Number of characters, categories, or elements to return. If `Length` is omitted, or if there are fewer than *Lengthcharacters* (including the `Start` character), all characters from `Start` to the end of the string are returned. If `Start` + `Length` is < 1, no items are returned.
    + `return`: *Variant* - The required characters, categories, or elements from `Val`.

    ### Remarks
    For type *Text*, the return value is of type *Text*, and contains `Length` characters from the position `Start` in `Val`. For type *Categorical*, the value is of type *Categorical*, and contains `Length` categories from the position `Start` in `Val`. For an *array* (which can contain values of any type), the return value is an *array*, and contains `Length` elements from the position `Start` in `Val`. For any other type, an error occurs.
    When `Val` is *NULL*, the return value is *NULL*.

    ### Examples

    | Function call           | Val                            | Start | Length | Result      |
    | :-------------          | :---------------               | :---- | :----- | :---------- |
    | Mid(Val, Start, Length) | 24 St John's Road, Barnes      | 10    | 15     | 's Road, Barnes |
    | Mid(Val, Start, Length) | {4,2,9}                        | 2     | 1      | {9}             |
    | Mid(Val, Start, Length) | {4,2,9}                        | 6     | 3      | {}              |
    | Mid(Val, Start, Length) | {4,2,9}                        | 0     | 2      | {4,2}           |
    | Mid(Val, Start, Length) | {4,2,9}                        | 0     |        | {4,2,9}         |
    | Mid(Val, Start, Length) | Split(\"The quick brown fox\") | 1     | 2      | {quick,brown}   |

    The following example returns characters 8-17 from the *address* text variable:
    ```ds
    address.Mid(7, 10)
    ```
    The following example returns the fourth category from the list of categories stored in the *remember* multiple response variable:
    ```ds
    remember.Mid(3, 1)
    ```
    For respondents who chose less than four categories, this returns an empty category list ({}).
    !'
    Function Mid(Start As Long, Optional Length As Long) As Variant
    End Function

    '!
    ```ds
    (function) Right(Length: Long): Variant
    ```
    -----------------------------------
    Returns a string containing the last characters from a string, a category list containing the last categories from a category list, or an array containing the last elements from an array.
    + `Val`: *String* | *Categorical* | *Array* - *Text* value, *categorical* value, or *array* to operate on.
    + `Length`: *Long* - Number of characters, categories, or elements to return. If `Length` is greater than the number of items available, all of the items are returned.
    + `return`: *Variant* - The required characters, categories, or elements from `Val`.

    ### Remarks
    For type *Text*, the return value is of type *Text*, and contains Length characters from the end of `Val`. For type *Categorical*, the return value is of type *Categorical*, and contains `Length` categories from the end of `Val`. For an *array* (which can contain values of any type), the return value is an *array*, and contains `Length` elements from the end of `Val`. For any other type, an error occurs.
    When `Val` is *NULL*, the return value is *NULL*.

    ### Examples

    | Function call      | Val                            | Length | Result       |
    | :----------------  | :--------------------          | :----- | :----------- |
    | Right(Val, Length) | 24 St John's Road, Barnes      | 6      | Barnes       |
    | Right(Val, Length) | {4,2,9,15,6,7}                 | 1      | {7}          |
    | Right(Val, Length) | Split(\"The quick brown fox\") | 3      | {quick,brown,fox} |

    The following example returns the 10 rightmost characters stored in the *address* text variable:
    ```ds
    address.Right(10)
    ```
    The following example returns the last two categories in the list of categories stored in the *remember* multiple response variable:
    ```ds
    remember.Right(2)
    ```
    !'
    Function Right(Length As Long) As Variant
    End Function

End Class

Class Array Implements IEnumerable

    '!
    ```ds
    (function) Find(Key: Variant, [Skip: Long = 0], [Reverse: Boolean = False], [IgnoreCase: Boolean = True]): Long
    ```
    -----------------------------------
    Searches a string, a category list, or an array, for a specified substring, subcategory list, or subarray, and if it is found, returns its start position.
    + `Key`: *Variant* - Value to search for in `Val`.
    + `Skip`: *Long* - Optional. The number of positions to skip in `Val` before starting the search. If `Reverse` is *True*, `Skip` is the number of positions to skip from the end of `Val`. If `Reverse` is omitted or *False*, Skip is the number of positions to skip from the start of `Val`. Treated as 0 if omitted or is < 0.
    + `Reverse`: *Boolean* - Optional. If *True*, `Val` is searched backwards. If `Reverse` is omitted or *False*, `Val` is searched forwards.
    + `IgnoreCase`: *Boolean* - Optional. If *False*, the comparison is case-sensitive. If `IgnoreCase` is omitted or *True*, the comparison is case-insensitive.
    + `return`: *Long* - Position in `Val`, relative to the start of `Val`, of `Key` if found, -1 otherwise.

    ### Remarks
    If `Val` is *Text*, `Key` is converted to text if necessary and is searched for as a substring of `Val`. Unless `IgnoreCase` is *False*, the comparison is case-insensitive.
    If `Val` is *Categorical* or an *Array* (which can contain values of any type), Key can be a *long*, *double*, *text*, *date*, *boolean*, or *categorical* value, or an *array*. When comparing `Key` (or the items in `Key`) with the items in `Val`, the normal conversion and comparison rules for variant types are used if necessary. Unless IgnoreCase is False, the comparison of text items (or items converted to text) is case-insensitive. If either item is *Null*, they are equal only if both are *Null*. If `Key` is a categorical value or an array, it is found only if its items occur as a sequence of consecutive items in `Val` and in the same order.
    If either `Val` or Key is *NULL*, the return value is -1 (not found). If `Val` is not *Text*, *Categorical*, or an *Array*, an error occurs.
    How you specify a text string as an argument depends on whether you are using the function in an SQL query or in mrScriptBasic or mrScriptMetadata. In an SQL query, enclose text strings in single quotation marks (' '). In mrScriptBasic or mrScriptMetadata, enclose text strings in double quotation marks (\" \").

    ### Examples

    | Function call             | Val                            | Key                  |  Result |
    | :----------------         | :-----------                   | :-------------       | :-----  |
    | Find(Val, Key)            | 24 St John's Road, Barnes      | barnes               | 19      |
    | Find(Val, Key, , True)    | 3 Glasgow Hill, Glasgow        | glasgow              | 16      |
    | Find(Val, Key)            | {3,7,8,1,9,10,5,4}             | 5                    | 6       |
    | Find(Val, Key, 7)         | {3,7,8,1,9,10,5,4}             | 5                    | -1      |
    | Find(Val, Key, , , False) | 24 St John's Road, Barnes      | barnes               | -1      |
    | Find(Val, Key)            | Split(\"The quick brown fox\") | Split(\"brown fox\") | 2       |

    **Text variables**. These examples use the name and address variables, which are text variables that store respondents' names and addresses, respectively. These examples show how you would use the Find function in mrScriptBasic or mrScriptMetadata. In SQL queries, you should enclose text strings in single quotation marks (' ') instead of double quotation marks (\" \").
    The following example selects any respondent whose address contains \"London\" in upper case, lower case, or a mixture of both cases. Find returns -1 when the search string has not been found. In this example the <> operator is used to test that the return value is not -1, which means that \"London\" exists somewhere in the text being searched.
    ```ds
    address.Find(\"London\") <> -1
    ```
    Find lets you search for a string in a particular position. This is useful when the position of the search string in the text you are searching is important. For example, the following selects respondents whose names begin with the string \"Brian\":
    ```ds
    Find(name, \"Brian\") = 0
    ```

    **Categorical variables**. These examples use the *remember* multiple response variable.
    This example selects all respondents who chose the *Dinosaurs* category regardless of its position in the list of categories chosen:
    ```ds
    remember.Find({dinosaurs}) <> -1
    ```
    The next example selects respondents for whom the *Dinosaurs* category is the first category in the list of their responses:
    ```ds
    remember.Find({dinosaurs}) = 0
    ```
    !'
    Function Find(Key As Variant, Optional Skip As Long = 0, Optional Reverse As Boolean = False, Optional IgnoreCase As Boolean = True) As Long
    End Function

    '!
    ```ds
    (function) Left(Length: Long): Variant
    ```
    -----------------------------------
    Returns a string containing the first characters from a string, a category list containing the first categories from a category list, or an array containing the first elements from an array.
    + `Val`: *String* | *Categorical* | *Array* - *Text* value, *categorical* value, or *Array* to operate on.
    + `Length`: *Long* - Number of characters, categories, or elements to return. If `Length` is greater than the number of items available, all of the items are returned.
    + `return`: *Variant* - The required characters, categories, or elements from `Val`.

    ### Remarks
    For type *Text*, the return value is of type *Text*, and contains `Length` characters from the start of `Val`. For type *Categorical*, the return value is of type *Categorical*, and contains Length categories from the start of `Val`. For an array (which can contain values of any type), the return value is an array, and contains `Length` elements from the start of `Val`. For any other type, an error occurs.
    When `Val` is *NULL*, the return value is *NULL*.

    ### Examples

    | Function call     | Val                            | Length | Result            |
    | :-------------    | :-------------                 | :----- | :---------------- |
    | Left(Val, Length) | 24 St John's Road, Barnes      | 10     | 24 St John        |
    | Left(Val, Length) | {4,2,9}                        | 1      | {4}               |
    | Left(Val, Length) | Split(\"The quick brown fox\") | 2      | {The,quick}       |

    The following example returns the first six characters of the *name* text variable:
    ```ds
    name.Left(6)
    ```
    The following example returns the first three categories stored in the *remember* multiple response variable:
    ```ds
    remember.Left(3)
    ```
    !'
    Function Left(Length As Long) As Variant
    End Function

    '!
    ```ds
    (function) Len(): Long
    ```
    -----------------------------------
    Returns a *Long* containing the number of characters in a string, the number of categories in a category list, or the number of elements in an array.
    + `Val`: *String* | *Categorical* | *Array* - *Text* value, *Categorical* value, or *Array* to operate on.
    + `return`: *Long* - Numbers of characters, categories, or elements in `Val`.

    ### Remarks
    For type *Text*, the return value is the number of characters in `Val`. For type *Categorical*, the return value is the number of categories in `Val`. For an *Array* (which can contain values of any type), the return value is the number of elements in `Val`. For any other type, an error occurs.
    When `Val` is *NULL*, the return value is zero.

    ### Examples

    | Function call | Val                            | Result |
    | :------------ | :---------------               | :----  |
    | Len(Val)      | 24 St John's Road, Barnes      | 25 |
    | Len(Val)      | {4,2,9}                        | 3 |
    | Len(Val)      | Split(\"The quick brown fox\") | 4 |

    The following example returns the number of characters stored in the *address* text variable:
    ```ds
    address.Len()
    ```
    The following example returns the number of categories selected by the respondent in response to the *remember* multiple response question:
    ```ds
    remember.Len()
    ```
    !'
    Function Len() As Long
    End Function

    '!
    ```ds
    (function) Mid(Start: Long, [Length: Long]): Variant
    ```
    -----------------------------------
    + `Val`: *String* | *Categorical* | *Array* - *Text* value, *categorical* value, or *array* to operate on.
    + `Start`: *Long* - Position in `Val` of the first character, category, or element wanted (counting from 0). If `Start` is greater than the number of items in `Val`, no items are returned. If `Start` is less than 0, items are returned from the start of `Val`.
    + `Length`: *Long* - Optional. Number of characters, categories, or elements to return. If `Length` is omitted, or if there are fewer than *Lengthcharacters* (including the `Start` character), all characters from `Start` to the end of the string are returned. If `Start` + `Length` is < 1, no items are returned.
    + `return`: *Variant* - The required characters, categories, or elements from `Val`.

    ### Remarks
    For type *Text*, the return value is of type *Text*, and contains `Length` characters from the position `Start` in `Val`. For type *Categorical*, the value is of type *Categorical*, and contains `Length` categories from the position `Start` in `Val`. For an *array* (which can contain values of any type), the return value is an *array*, and contains `Length` elements from the position `Start` in `Val`. For any other type, an error occurs.
    When `Val` is *NULL*, the return value is *NULL*.

    ### Examples

    | Function call           | Val                            | Start | Length | Result      |
    | :-------------          | :---------------               | :---- | :----- | :---------- |
    | Mid(Val, Start, Length) | 24 St John's Road, Barnes      | 10    | 15     | 's Road, Barnes |
    | Mid(Val, Start, Length) | {4,2,9}                        | 2     | 1      | {9}             |
    | Mid(Val, Start, Length) | {4,2,9}                        | 6     | 3      | {}              |
    | Mid(Val, Start, Length) | {4,2,9}                        | 0     | 2      | {4,2}           |
    | Mid(Val, Start, Length) | {4,2,9}                        | 0     |        | {4,2,9}         |
    | Mid(Val, Start, Length) | Split(\"The quick brown fox\") | 1     | 2      | {quick,brown}   |

    The following example returns characters 8-17 from the *address* text variable:
    ```ds
    address.Mid(7, 10)
    ```
    The following example returns the fourth category from the list of categories stored in the *remember* multiple response variable:
    ```ds
    remember.Mid(3, 1)
    ```
    For respondents who chose less than four categories, this returns an empty category list ({}).
    !'
    Function Mid(Start As Long, Optional Length As Long) As Variant
    End Function

    '!
    ```ds
    (function) Right(Length: Long): Variant
    ```
    -----------------------------------
    Returns a string containing the last characters from a string, a category list containing the last categories from a category list, or an array containing the last elements from an array.
    + `Val`: *String* | *Categorical* | *Array* - *Text* value, *categorical* value, or *array* to operate on.
    + `Length`: *Long* - Number of characters, categories, or elements to return. If `Length` is greater than the number of items available, all of the items are returned.
    + `return`: *Variant* - The required characters, categories, or elements from `Val`.

    ### Remarks
    For type *Text*, the return value is of type *Text*, and contains Length characters from the end of `Val`. For type *Categorical*, the return value is of type *Categorical*, and contains `Length` categories from the end of `Val`. For an *array* (which can contain values of any type), the return value is an *array*, and contains `Length` elements from the end of `Val`. For any other type, an error occurs.
    When `Val` is *NULL*, the return value is *NULL*.

    ### Examples

    | Function call      | Val                            | Length | Result       |
    | :----------------  | :--------------------          | :----- | :----------- |
    | Right(Val, Length) | 24 St John's Road, Barnes      | 6      | Barnes       |
    | Right(Val, Length) | {4,2,9,15,6,7}                 | 1      | {7}          |
    | Right(Val, Length) | Split(\"The quick brown fox\") | 3      | {quick,brown,fox} |

    The following example returns the 10 rightmost characters stored in the *address* text variable:
    ```ds
    address.Right(10)
    ```
    The following example returns the last two categories in the list of categories stored in the *remember* multiple response variable:
    ```ds
    remember.Right(2)
    ```
    !'
    Function Right(Length As Long) As Variant
    End Function

End Class

Interface IEnumerable

    '!
    ```ds
    (function) FindItem(Key: Varaint): Varaint
    ```
    -----------------------------------
    This function returns a specified item from a list, or *NULL* if the item isn't found.
    + `List`: *Variant* - *Array*, *collection* or *Categorical* value to operate on.
    + `Key`: *Variant* - Index, name, or value of the item to be found.
    + `return`: *Variant* - A copy of the requested item if found in *List*, or *NULL* if the item is not found.

    ### Remarks
    This function can be used to look up an item in a list, without generating an error if the item doesn't exist. If `List` or `Key` are *NULL*, the return value is *NULL*.
    The way in which `Key` is used to locate an item depends on the type of the list, as follows:
    - **1. If List is a Collection** -
    `Key` is passed to the list's \"Evaluate method\", that is, the property or method that is given a COM Dispatch identifier of -5. If the list has no `Evaluate` method, `Key` is passed to the Item property of the list. If the list has neither an `Evaluate` method, nor a property or method called \"Item\" (in English only), or if accessing the `Evaluate` method or the Item property generates an error, the return value is *NULL*. Otherwise, the return value is the value returned by the `Evaluate` method or the Item property, which may be *NULL* if the item isn't found.
    - **2. If List is an Array or Categorical Value, and Key is of type Long** -
        - `Key` is taken as the positional index of an item in the list, starting at 0 for the first item. If `Key` is greater than or equal to zero and less than the number of items in List, the return value is the item at that position. Otherwise, the return value is *NULL*.
        - For example, if *List* is a *Categorical* value that contains three or more categories and `Key` is 2 (*Long*), the return value is the third category in the list.
    - **3. If List is an Array or Categorical Value, and Key is not of type Long** -
        - `Key` is compared with each list item in turn until a match is found. The way that Key is compared with each item depends on the type of the item:
            - For a *string* item, `Key` is converted to a string and compared with the item.
            - For an item that is an object, `Key` is converted to a string and compared with the value of the object's \"Name property\", that is, the property that is given a COM Dispatch identifier of -800. If the object has no \"Name property\", the `Key` is compared with the value of the object's default property, which is converted to a string if necessary. If the object has no Name or default properties, or if accessing the Name or default properties generates an error, the item is considered not to be a match for `Key`.
            - For any other type of item, Key is compared with the item using the normal conversion and comparison rules for variant types.
        - In all string comparisons, differences between upper and lower case are ignored. If a matching item is found, the return value is the matching item. Otherwise the return value is *NULL*.
        - For example, if `List` is a *Categorical* value that contains a category with a value of 2 and `Key` is “2” (*Text*) or 2.0 (*Double*), the return value is 2 (*Long*).

    ### Examples

    | Function call       |  List                           |  Key     |  Result    | Notes |
    | :-----------------  |  :----------------              |  :-----  |  :------   | :------------- |
    | FindItem(List, Key) |  {8,5,7,1,3,4,9}                |  4       |  3         | The item with a positional index of 4 (that is, the fifth item) in the categorical value is returned. |
    | FindItem(List, Key) |  {8,5,7,1,3,4,9}                |  10      |  NULL      | There is no item with a positional index of 10, so NULL is returned. |
    | FindItem(List, Key) |  {8,5,7,1,3,4,9}                |  \"4.0\" |  4         | To compare with the Long values in the categorical value, Key is converted from a Text to a Long value, and the matching item is returned. |
    | FindItem(List, Key) |  {8,5,7,1,3,4,9}                |  4.0     |  4         | To compare with the Long values in the categorical value, Key is converted from a Double to a Long value, and the matching item is returned. |
    | FindItem(List, Key) |  split(\"The quick brown fox\") |  1       |  \"quick\" | The item with a positional index of 1 (that is, the second item) in the array is returned. |
    | FindItem(List, Key) |  split(\"The quick brown fox\") |  \"THE\" |  \"The\"   | The matching Text item in the array is returned. String comparisons are always case insensitive. |
    | FindItem(List, Key) |  split(\"1 2 3 4 5\")           |  4       |  \"5\"     | Key is a Long value, so the item with a positional index of 4 in the array is returned. |
    | FindItem(List, Key) |  split(\"1 2 3 4 5\")           |  \"4\"   |  \"4\"     | Key is a Text value, so the matching text item in the array is returned. |
    | FindItem(List, Key) |  split(\"1 2 3 4 5\")           |  4.0     |  \"4\"     | Key is converted from a Double to a Text value, and the matching text item in the array is returned. |

    The `Split` function is used in some of the above examples to create an array of substrings that `FindItem` can operate on.
    The following mrScriptBasic example uses the `FindItem` function to find an item called \"Country\" in a collection:
    ```ds
    Dim myItem

    myItem = myCollection.FindItem(\"Country\")

    If myItem <> NULL Then
        ...                   ' Item found
    Else
        ...                   ' Item not found
    End If
    ```
    !'
    Function FindItem(Key As Variant) As Variant
    End Function

    '!
    ```ds
    (function) Ran([Count: Long], [Seed: Long = 0]): Varaint
    ```
    -----------------------------------
    This function returns a randomized copy of a list. The optional `Count` parameter defines how many items from the input list are included in the returned randomized list.
    + `List`: *Variant* - *Array*, *collection*, or *Categorical* value to operate on.
    + `Count`: *Long* - Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned.
    + `Seed`: *Long* - Optional. The starting point to be used for the generation of the random ordering. The default is 0.
    + `return`: *Variant* - An array consisting of a randomized copy of the input list.

    ### Remarks
    An error occurs if `List` is a collection that doesn't support the For Each...Next syntax. When List is a collection object, the return value is an array that contains copies of the objects in the collection and the input collection object is unchanged. Because the return value is an array, it does not have a `Count` property.
    If `Seed` is supplied, it is used to reset the starting point for the random number generator, as in `SetRandomSeed`, before the randomization. If `Seed` is not supplied or has a value of 0, the function will use the starting point stored for the random number generator by the mrScriptBasic engine or Evaluate component and passed as a hidden parameter. Each time you call one of the randomization functions, the starting point stored for the random number generator is updated. This means that if you call the function repeatedly without specifying the `Seed` parameter, the sequence of results is determined by the changing value passed as a hidden parameter. Specifying the `Seed` parameter is a way of resetting this sequence. It also means that the randomization can be repeated. For example, if you use this function to randomize a category list in an interview, by using the same seed value you could present the category list in the same sequence should the interview be restarted.
    The `Ran` function is similar to using the ran keyword in IBM® SPSS® Quancept™.

    ### Examples
    `Ran` is useful when you are cleaning data. For example, when a respondent has selected more than one category in response to a single response question, you can use Ran to select one of the responses randomly, as shown in the following snippet of mrScriptBasic code:
    ```ds
    If time_spent.AnswerCount() > 1 Then
    time_spent = time_spent.Ran(1)
    End If
    ```
    The next example shows using Ran with a multiple response variable called remember (which is in the IBM® SPSS® Data Collection Data File version of the Museum sample data set) in an SQL query. The example uses the `Ran` function twice, both times it is used to return one response from the list of responses stored in the variable. However, the first time the `Seed` parameter is not specified and the second time it is.
    ```sql
    SELECT Respondent.Serial,
        remember,
        Ran(remember, 1) AS Remember1,
        Ran(remember, 1, 1) AS Remember2,
        remember.AnswerCount() AS HowMany
    FROM vdata
    WHERE remember IS NOT NULL
    ```

    |       | Remember                                       | Remember1           | Remember2           | HowMany |
    | :---- | :--------------------------------------------- | :------------------ | :------------------ | :------ |
    | 1     | {dinosaurs,fish_and_reptiles,fossils,mammals,m | {fish_and_reptiles} | {dinosaurs}         | 7 |
    | 2     | {dinosaurs,fish_and_reptiles,fossils,mammals,m | {origin_of_species} | {fish_and_reptiles} | 8 |
    | 3     | {dinosaurs,fossils,birds,insects,whales,mammal | {minerals}          | {other}             | 11 |
    | 4     | {dinosaurs,conservation,birds,mammals,minerals | {other}             | {mammals}           | 6 |
    | 5     | {dinosaurs,birds,minerals,human_biology,evolut | {birds}             | {minerals}          | 5 |
    | 6     | {dinosaurs,birds,whales,mammals,origin_of_spec | {mammals}           | {dinosaurs}         | 7 |
    | 7     | {dinosaurs,birds,whales,mammals,minerals,botan | {human_biology}     | {birds}             | 8 |
    | 8     | {dinosaurs,insects,human_biology}              | {human_biology}     | {dinosaurs}         | 3 |

    Notice that the results in the Remember2 column are different from those in the Remember1 column, because the Seed parameter was used to specify a different starting point for the randomization. Although the results appear to be different in the Remember2 column for every case, in fact the choice of the category is based on the same random number each time. The reason the results appear to be different is that the cases have different numbers of responses. The HowMany column shows us how many responses have been selected in each row. We can see that:
    + In rows where 3 or 7 responses were chosen, *Remember2* contains the first response.
    + In rows where 4 or 8 responses were chosen, *Remember2* contains the second response.
    + In rows where 5 responses were chosen, *Remember2* contains the third response.
    + In rows where 6 responses were chosen, *Remember2* contains the fourth response.

    This is because if *N* is the random number being used, then:
    ```ds
    N mod 3 = 0
    N mod 4 = 1
    N mod 5 = 2
    N mod 6 = 3
    N mod 7 = 0
    N mod 8 = 1
    ```
    For example, *N* might be 777.
    !'
    Function Ran(Optional Count As Long, Optional Seed As Long = 0) As Varaint
    End Function

    '!
    ```ds
    (function) Rev(List: Variant, [Count: Long], [Policy: Long], [Seed: Long]): Array
    ```
    -----------------------------------
    This function returns an array containing copies of items from the input list, either in the normal order or in reverse order. The optional `Count` parameter defines how many items from the input list are included in the returned list.
    + `List`: *Variant* - *Array*, *collection*, or *Categorical* value to operate on.
    + `Count`: *Long* - Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned.
    + `Policy`: *Long* - Optional. Controls the way the list order is chosen. The default is 1.
    + `Seed`: *Long* - Optional. The state to be used for the reversal. The default is 0.
    + `return`: *Array* - An array consisting of a copy of the input list.

    ### Remarks
    An error occurs if `List` is a collection that doesn’t support the `For Each...Next` syntax. When List is a collection object, the return value is an array that contains copies of the objects in the collection and the input collection object is unchanged. Because the return value is an array, it does not have a `Count` property.
    This function uses the reversal state stored by the mrScriptBasic engine or Evaluate component and passed as a hidden parameter. However, when both `Policy` and `Seed` are nonzero, the reversal state is set to `Seed` before the `Policy` is applied. If the resulting reversal state is even, the list is presented in normal order; if odd, the list is reversed.
    The possible values for `Policy` are:
    - **0** - No reversal and the reversal state is set to 0.
    - **1** - The reversal state is used without changing it.
    - **2** - The reversal state is incremented by one and used.
    - **3** - 	Use the starting point of the random number generator and update both the reversal state and the random number generator starting point.
    The `Rev` function is similar to using the rev keyword in IBM® SPSS® Quancept™.

    ### Examples
    This example shows using `Rev` with *museums* (which is a multiple response variable in the IBM® SPSS® Data Collection Data File version of the Museum sample data set) in an SQL query. The example uses the `Rev` function four times, each time using a different value for the `Policy` parameter.
    ```sql
    SELECT museums AS Museums,
        Rev(museums, , 0) AS Policy0,
        Rev(museums, , 1) AS Policy1,
        Rev(museums, , 2) AS Policy2,
        Rev(museums, , 3) AS Policy3
    FROM vdata WHERE museums.AnswerCount() > 2
    ```
    Here are the results for the first five respondents:

    |       | Museums       | Policy0       | Policy1       | Policy2       | Policy3   |
    | :---- | :------------ | :-----------  | :------------ | :------------ | :-----------  |
    | 1     | {25,28,29}    | {25,28,29}    | {25,28,29}    | {29,28,25}    | {25,28,29}    |
    | 2     | {26,28,29,30} | {26,28,29,30} | {26,28,29,30} | {26,28,29,30} | {26,28,29,30} |
    | 3     | {25,26,27}    | {25,26,27}    | {25,26,27}    | {27,26,25}    | {27,26,25}    |
    | 4     | {25,28,30}    | {25,28,30}    | {25,28,30}    | {25,28,30}    | {30,28,25}    |
    | 5     | {25,26,27}    | {25,26,27}    | {25,26,27}    | {27,26,25}    | {25,26,27}    |

    In the first column, *Museums*, the responses are presented as they are stored in the variable, which is the \"normal\" order. Notice that the responses are also presented in the normal order in the next two columns:
    - The second column, *Policy0*, presents the responses in the normal order because `Policy` is set to 0 and `Seed` is not specified. This means that the list is presented in the normal order.
    - The third column, *Policy1*, presents the responses in the normal order because `Policy` is set to 1 and `Seed` is not specified. This means that whether the list is reversed or not is determined by the current setting of the reversal state. However, because the `Seed` parameter has not been specified, the reversal state defaults to 0, which is an even number, and so the list is presented in the normal order. If we changed the query to specify the `Seed` parameter as 1, the order would be reversed, because 1 is an odd number.

    In the fourth column, *Policy2*, the list is presented in normal and reverse order alternately. This is because `Policy` is set to 2, which means that each time the function is called, one is added to the reversal state, thus causing it to alternate between odd and even values.
    In the fourth column, *Policy3*, the list is presented in normal and reverse orders at random because `Policy` is set to 3. This means that the reversal state is set to a random value each time the function is called. This means that the list is presented in normal and reverse order randomly.
    !'
    Function Rev(Optional Count As Long, Optional Policy As Long, Optional Seed As Long) As Array
    End Function

    '!
    ```ds
    (function) Rot(List: Variant, [Count: Long], [Policy: Long = 2], [Seed: Long = 0]): Array
    ```
    -----------------------------------
    This function returns an array containing copies of items from the input list, in a rotated order. The optional `Count` parameter defines how many items from the input list are included in the returned list.
    + `List`: *Variant* - *Array*, *collection*, or *Categorical* value to operate on.
    + `Count`: *Long* - Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned.
    + `Policy`: *Long* - Optional. Controls the way the rotation is chosen. The default is 2.
    + `Seed`: *Long* - Optional. The state to be used for the rotation. The default is 0.
    + `return`: *Array* - An array consisting of a copy of the input list.

    ### Remarks
    An error occurs if `List` is a collection that doesn’t support the `For Each...Next` syntax. When `List` is a collection object, the return value is an array that contains copies of the objects in the collection and the input collection object is unchanged. Because the return value is an array, it does not have a `Count` property.
    This function uses the rotation state stored by the mrScriptBasic engine or Evaluate component and passed as a hidden parameter. However, when both `Policy` and `Seed` are nonzero, the rotation state is set to `Seed` before the `Policy` is applied. The resulting rotation state determines which item from the original list is to appear first in the rotated list.
    The possible values for `Policy` are:
    - **0** - No rotation and the rotation state is set to 0.
    - **1** - The rotation state is used without changing it.
    - **2** - The rotation state is incremented by one and used.
    - **3** - Use the starting point of the random number generator and update both the rotation state and the random number generator starting point.

    The rotation state is used to calculate the number of items by which the list should be \"rotated\". This is called the **offset** and is calculated as follows:
    ```ds
    Rotation_state mod Number_of_items_in_list
    ```
    For example, if the rotation state is 9 and there are 7 items in the list, the first item in the rotated list will be the third item, because the offset is 2 (which is 9 mod 7). However, if there were 5 items in the list, the rotated list would start with the fifth item, because the offset is 4 (which is 9 mod 5).
    The `Rot` function is similar to using the rot keyword in IBM® SPSS® Quancept™.

    ### Examples
    This mrScriptBasic example uses a loop to call the `Rot` function repeatedly using a `Categories` collection object as the input. Note that the function returns an array that contains copies of the objects in the `Categories` collection and does not actually change the order of the objects in the `Categories` collection. Because the return value is an array, it does not have a `Count` property.
    ```ds
    Dim MyDocument, MyCategories, MyElement
    Dim Rotated, Counter

    Set MyDocument = CreateObject(\"MDM.Document\")

    MyDocument.Open(\"C:\\Program Files\\IBM\\SPSS\\DataCollection\\6\\DDL\\Data\\Data Collection File\\museum.mdd\", , _
        MDMLib.openConstants.oREAD)

    Set MyCategories = MyDocument.Fields[\"museums\"].Categories

    For Each MyElement in MyCategories
        Debug.Log(MyElement.Name)
    Next

    For Counter = 0 To 6
        Debug.Log(mr.NewLine)
        Set Rotated = MyCategories.Rot(, 2)
        For Each MyElement in Rotated
            Debug.Log(myElement.Name)
        Next
    Next
    ```
    Here is the output:
    ```ds
    National_Museum_of_Science
    Museum_of_Design
    Institute_of_Textiles_and_Fashion
    Archeological_Museum
    National_Art_Gallery
    Northern_Gallery
    Other
    Not_answered


    Museum_of_Design
    Institute_of_Textiles_and_Fashion
    Archeological_Museum
    National_Art_Gallery
    Northern_Gallery
    Other
    Not_answered
    National_Museum_of_Science


    Institute_of_Textiles_and_Fashion
    Archeological_Museum
    National_Art_Gallery
    Northern_Gallery
    Other
    Not_answered
    National_Museum_of_Science
    Museum_of_Design


    Archeological_Museum
    National_Art_Gallery
    Northern_Gallery
    Other
    Not_answered
    National_Museum_of_Science
    Museum_of_Design
    Institute_of_Textiles_and_Fashion


    National_Art_Gallery
    Northern_Gallery
    Other
    Not_answered
    National_Museum_of_Science
    Museum_of_Design
    Institute_of_Textiles_and_Fashion
    Archeological_Museum


    Northern_Gallery
    Other
    Not_answered
    National_Museum_of_Science
    Museum_of_Design
    Institute_of_Textiles_and_Fashion
    Archeological_Museum
    National_Art_Gallery


    Other
    Not_answered
    National_Museum_of_Science
    Museum_of_Design
    Institute_of_Textiles_and_Fashion
    Archeological_Museum
    National_Art_Gallery
    Northern_Gallery


    Not_answered
    National_Museum_of_Science
    Museum_of_Design
    Institute_of_Textiles_and_Fashion
    Archeological_Museum
    National_Art_Gallery
    Northern_Gallery
    Other
    ```
    !'
    Function Rot(Optional Count As Long, Optional Policy As Long = 2, Optional Seed As Long = 0) As Array
    End Function

    '!
    ```ds
    (function) SelectRange([Range: Variant], [Count: Long]): Categorical
    ```
    -----------------------------------
    This function returns an array containing copies of selected items from the input list, in the same order as in the list.
    + `List`: *Variant* - *Array*, *collection* or *Categorical* value to operate on.
    + `Range`: *Variant* - *Text*, *Long* or *Categorical* value for selecting list items.
    + `Count`: *Long* - Optional. Number of items to return. If omitted, negative, or greater than the maximum number of items selected by `Range`, all selected items are returned.
    + `return`: *Categorical* - *Array* containing a selection of items from the list.

    ### Remarks
    If `List` is a collection, an error occurs if it does not support _NewEnum (that is, `for each ... next`). If `List` is *NULL*, an empty array is returned.
    If `Range` is of type *Categorical*, the values within it are taken as positional indexes of items in `List`, as described below. If `Range` is of type *Long*, it is taken as a single positional index. If `Range` is of type *Text*, it is assumed to be a range expression, of the same syntax as a category expression. Numbers in the range expression refer to positional indexes of items in `List`; names are used to identify list items as described below. If `Range` is *NULL*, all list items are returned. If `Range` is of any other type, an error occurs.
    Positional indexes start at 0 for the first item in `List`. Indexes less than zero or greater than or equal to the number of items in `List` are ignored. For example, in a list of 4 items, a range of \"-1..10\" will select all items, the same as \"0..3\" or \"..\".
    The way names in the range expression are used depends on the type of the items in `List`:
    - For a **string** item, the name is simply compared with the string.
    - For an item that is an **object**, the name is first compared with the value of the object's Name property, if it has one. This property is not necessarily called \"Name\", but it is defined internally as representing a name for the object. In COM, this is done by giving the property a Dispatch identifier of -800. If the object has no Name property, the name is compared with the value of the object's default property. If the object has no Name or default properties, or their values cannot be determined, or the value is not a string, an error occurs.
    - For any **other** type of item, an error occurs if `Range` contains item names. In particular, if `List` is a *Categorical* value, only numeric (positional) indexes can be used, not category values or names.

    When comparing names, differences between upper and lower case are ignored. Like out-of-range indexes, any name in Range that does not match an item in `List` is ignored. For example, if an item called \"Good\" exists but no item called \"Bad\", then the range expression \"Good..Bad\" is equivalent to \"Good..\" (selecting all items from \"Good\" to the end of `List`), \"Bad\" will select no items, \"^Bad\" will select all items, and \"^Bad, Good\" will select only \"Good\".

    ### Examples

    | Function call            | List                           | Range               | Result |
    | :---------------------   | :------------------            | :--------------     | :---------- |
    | SelectRange(List, Range) | {8,5,7,1,3,2,9}                | 2                   | {7} |
    | SelectRange(List, Range) | {8,5,7,1,3,2,9}                | {2,4}               | {7,3} |
    | SelectRange(List, Range) | {8,5,7,1,3,2,9}                | \"2 .. 4\"          | {7,1,3} |
    | SelectRange(List, Range) | {8,5,7,1,3,2,9}                | \"2 .., ^4\"        | {7,1,2,9} |
    | SelectRange(List, Range) | Split(\"The quick brown fox\") | 3                   | {fox} |
    | SelectRange(List, Range) | Split(\"The quick brown fox\") | \"quick .. jumped\" | {quick,brown,fox} |

    | Function call                   | List                           | Range    | Count  | Result |
    | :-----------------------        | :-------------------           | :------- | :----- | :-------- |
    | SelectRange(List, Range, Count) | {8,5,7,1,3,2,9}                | \"2 ..\" | 4      | {7,1,3,2} |
    | SelectRange(List, Range, Count) | {8,5,7,1,3,2,9}                | NULL     | 5      | {8,5,7,1,3} |
    | SelectRange(List, Range, Count) | Split(\"The quick brown fox\") | NULL     | 2      | {The,quick} |

    The `Split` function is used in some of these examples to create an array of substrings that SelectRange can operate on.
    !'
    Function SelectRange(Optional Range As Variant, Optional Count As Long) As Categorical
    End Function

    '!
    ```ds
    (function) SortAsc([Count: Long], [IgnoreLocale: Boolean]): Array
    ```
    -----------------------------------
    This function returns an array containing copies of items from the input list, sorted in ascending order. The optional `Count` parameter defines how many items from the input list are included in the returned list.
    + `List`: *Variant* - *Array*, *collection*, or *Categorical* value to operate on.
    + `Count`: *Long* - Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned.
    + `IgnoreLocale`: *Boolean* - Optional. When *True*, the rules of the input locale are ignored when sorting text and the text is sorted in a language-neutral way. The default is *False*.
    + `return`: *Array* - An array consisting of a sorted copy of the input list.

    ### Remarks
    An error occurs if `List` is a collection that doesn’t support the `For Each...Next` syntax. When `List` is a collection object, the return value is an array that contains copies of the objects in the collection and the input collection object is unchanged. Because the return value is an array, it does not have a `Count` property.
    The sorting method depends on the type of the items in the list. If they are simple *Long*, *Double*, *Text*, *Date*, or *Boolean* values, they are sorted in ascending order. When sorting *Boolean* values, `SortAsc` considers *False* to be less than *True*.
    If the items are objects, they are sorted by the value of their default property. An error occurs if the objects do not have a default property or its value cannot be determined.
    The input locale is used to determine the correct ordering for text values, unless IgnoreLocale is True, when the sorting is performed in a locale-independent way. The locale-independent sort is case-sensitive and is likely to give unexpected results. When the input locale is used, the sort is always case-insensitive. Note that items with the same equivalent values may not appear in the same relative order in the sorted list as in the original list.

    ### Examples
    The following mrScriptBasic example writes the short and long names of each language in the MDM Languages collection to a text file two times. First in the order in which they appear in the collection and then after using `SortAsc` to sort the collection in ascending order. The collection is sorted in ascending order of the three-character language codes stored in the Name property because it is the default property of the `Language` object.
    ```ds
    Dim MyDocument, MyLanguage, Sorted

    Set MyDocument = CreateObject(\"MDM.Document\")

    MyDocument.Open(\"C:\\Program Files\\IBM\\SPSS\\DataCollection\\6\\DDL\\Scripts\\Interview\\Projects\\Museum\\Museum.backup.mdd\", , _
        MDMLib.openConstants.oREAD)

    For Each MyLanguage in MyDocument.Languages
        Debug.Log(MyLanguage.Name + \": \" + MyLanguage.LongName)
    Next

    Debug.Log(\" \")

    Set Sorted = SortAsc(MyDocument.Languages)

    For Each MyLanguage in Sorted
        Debug.Log(MyLanguage.Name + \": \" + MyLanguage.LongName)
    Next
    ```
    Here is the output:
    ```ds
    CHS: Chinese (China)
    ZHH: Chinese (Hong Kong SAR)
    ENU: English (United States)
    ESN: Spanish (International Sort)
    JPN: Japanese
    KOR: Korean
    THA: Thai

    CHS: Chinese (China)
    ENU: English (United States)
    ESN: Spanish (International Sort)
    JPN: Japanese
    KOR: Korean
    THA: Thai
    ZHH: Chinese (Hong Kong SAR)
    ```
    !'
    Function SortAsc(Optional Count As Long, Optional IgnoreLocale As Boolean) As Array
    End Function

    '!
    ```ds
    (function) SortDesc([Count: Long], [IgnoreLocale: Boolean]): Array
    ```
    -----------------------------------
    This function returns an array containing copies of items from the input list, sorted in descending order. The optional `Count` parameter defines how many items from the input list are included in the returned list.
    + `List`: *Variant* - *Array*, *collection*, or *Categorical* value to operate on.
    + `Count`: *Long* - Optional. Number of items to return. If omitted, negative, or greater than the number of input items, all items are returned.
    + `IgnoreLocale`: *Boolean* - Optional. When *True*, the rules of the input locale are ignored when sorting text and the text is sorted in a language-neutral way. The default is *False*.
    + `return`: *Array* - An array consisting of a sorted copy of the input list.

    ### Remarks
    An error occurs if `List` is a collection that doesn’t support the `For Each...Next` syntax. When `List` is a collection object, the return value is an array that contains copies of the objects in the collection and the input collection object is unchanged. Because the return value is an array, it does not have a `Count` property.
    The sorting method depends on the type of the items in the list. If they are simple *Long*, *Double*, *Text*, *Date*, or *Boolean* values, they are sorted in descending order. When sorting *Boolean* values, `SortAsc` considers *False* to be less than *True*.
    If the items are objects, they are sorted by the value of their default property. An error occurs if the objects do not have a default property or its value cannot be determined.
    The input locale is used to determine the correct ordering for text values, unless IgnoreLocale is True, when the sorting is performed in a locale-independent way. The locale-independent sort is case-sensitive and is likely to give unexpected results. When the input locale is used, the sort is always case-insensitive. Note that items with the same equivalent values may not appear in the same relative order in the sorted list as in the original list.

    ### Examples
    This example shows using `SortDesc` in an SQL query to sort the responses given to a multiple response question.
    ```sql
    SELECT Respondent.Serial,
        Remember,
        Remember.SortDesc() AS 'Remember.SortDesc'
    FROM vdata
    WHERE Remember IS NOT NULL
    ```
    Here is the result set for the first five respondents:

    | Respondent.Serial | Remember                           | Remember.SortDesc |
    | :---------------- | :--------------------------------  | :--------------------------------- |
    | 305               | {31,33,34,38,39,44,18}             | {44,39,38,34,33,31,18} |
    | 306               | {31,33,34,38,39,40,42,18}          | {42,40,39,38,34,33,31,18} |
    | 307               | {31,34,35,36,37,38,39,42,43,44,18} | {44,43,42,39,38,37,36,35,34,31,18} |
    | 308               | {31,32,35,38,39,18}                | {39,38,35,32,31,18} |
    | 309               | {31,35,39,43,44}                   | {44,43,39,35,31} |
    | 310               | {31,35,37,38,42,43,18}             | {43,42,38,37,35,31,18} |

    !'
    Function SortDesc(Optional Count As Long, Optional IgnoreLocale As Boolean) As Array
    End Function

End Interface


