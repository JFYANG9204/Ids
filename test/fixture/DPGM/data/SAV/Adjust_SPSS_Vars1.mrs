'*****FILE VERSION=1, DATE LAST MODIFIED=2011/06/13, KO

'This script creates an Excel file which allows you to manipulate the SAV variables

#include "..\..\job.ini"
'**************************************************************************************
'**************************************************************************************
'**************************************************************************************

'CHANGE AS NEEDED:  path and name to input SAV metadata file
#define METADATA_SAV "Output\" + INPUT_METADATA + "_FINAL_SAV.mdd"

'CHANGE AS NEEDED:  path and name to input SAV file
#define SAV_FILE "Output\" + INPUT_METADATA + "_FINAL.sav"

'CHANGE AS NEEDED:  path and name to output Excel file
#define XL_FILE JOB_ROOT + "data\sav\Output\Adjust_SPSS_Vars.xls"

'CHANGE AS NEEDED:  name of Excel worksheet 
#define XL_SHEET_NAME "Name_Variables"

'CHANGE AS NEEDED:  maximum length of SPSS variable names 
#define RENAME_LENGTH 50

'**************************************************************************************
'**************************************************************************************
'**************************************************************************************


'**************************************************************************************
'No Need To Edit Below This Line
'**************************************************************************************

dim MDM
dim SAV
dim SavVar
dim MDMVar
dim iRow
dim iCol
dim iCount
dim PrevVar
dim CurVar
dim LabelLetter
dim strTemp1
dim i

Dim xlApp
Dim xlWorkbook
Dim xlWorksheet

dim arrNames[]
dim arrLabels[]
dim hashshort
Set hashshort = CreateObject("Scripting.Dictionary")

' create background non interactive instance of Excel
Set xlApp = CreateObject("Excel.Application")
xlApp.DisplayAlerts = False
    
' create a workbook
Set xlWorkbook = xlApp.Workbooks.Add()

' add my own worksheet to the workbook
xlWorkbook.Worksheets.Add()

' make the new worksheet the active sheet and give it a name
Set xlWorksheet = xlWorkbook.ActiveSheet

With xlWorksheet
        xlWorksheet.Name = XL_SHEET_NAME
end with


'**
dim DSC, DSCs
   ' Create the Data source component Collection
   Set DSCs = CreateObject("MRDSCReg.Components")

   ' Find the SPSS Statistics SAV DSC
   Set DSC = DSCs["mrSavDsc"]

   ' Create an SAV object from the .sav file
   Set SAV = DSC.Metadata.Open(SAV_FILE)

   SAV.IncludeSystemVariables = True


set MDM = createobject("MDM.Document")

'MDM.Open(MDD_FILE)
MDM.Open(METADATA_SAV,"")

With xlWorksheet

        .cells[1][1] = "Input:"
        .cells[1][2] = SAV_FILE
        .cells[2][1] = "Output:"
        .cells[2][2] = JOB_ROOT + "data\sav\Output\" + mid(left(SAV_FILE,len(SAV_FILE)-4),10) + "_out.SAV"

        .Cells[3][1] = "Original Name"
        .Cells[3][2] = "New Name"
        .Cells[3][3] = "Original Label"
        .Cells[3][4] = "New Label"
        .Cells[3][5] = "Delete"
        
        iRow = 4
        for each SavVar in SAV.Variables
                ReDim(arrNames,0,False)
                ReDim(arrLabels,0,False)
                arrNames[0] = SavVar.fullname
                'find corresponding variable in MDD
                dim strtest
                dim blnMatchVars
                if savvar.issystem = true then
                        'debug.Log(savvar.fullname)
                else
                'strTest = fnGetOriginalName(MDM.fields,arrNames[0],0)
                        for each MDMVar in MDM.Variables
                                if MDMVar.AliasName = SavVar.aliasName then
                                        'debug.Log(savvar.fullname + " aliasname matches " + mdmvar.fullName)
                                        blnMatchVars = True
                                        exit for
                                end if                          
                        next
                end if
                
                if blnMatchVars = False then
                        'no match found
                        debug.Log("Variable not included in Excel file - " + savVar.fullName)      
                end if
                
                
                
                '******************
                if SavVar.DataType = DataTypeConstants.mtCategorical And _
                (SavVar.MaxValue > 1 or SavVar.EffectiveMaxValue > 1) Then
                         For i = 0 to SavVar.SubAliases.Count-1
                                arrNames[i] = SavVar.SubAliases[i]
                                arrLabels[i] = SavVar.Elements[i].label
                        Next    
                end if
                if blnMatchVars = True then
                        for i = 0 to ubound(arrNames)
                        .Cells[iRow][1] = arrNames[i]
                
                        if SavVar.UsageType = 8 then '8 vtArray 
                        curVar = fnStripIterations(SavVar.FullName)
                        if PrevVar = CurVar then
                                iCount = iCount + 1
                        else
                                iCount = 1
                        end if
                        LabelLetter = lcase(fnConvertToLetter(iCount))
                        PrevVar = CurVar
                                else
                        LabelLetter = ""
                                end if
                
                        if Find(SavVar.fullname,"[") >-1 then
                                strTemp1 = lcase(fnstripiterations(SavVar.fullname))
                        else
                                strTemp1 = SavVar.fullname
                        end if
        
                        strTemp1 = replace(strTemp1,"[","_")
                        strTemp1 = replace(strTemp1,"]","_")
                        strTemp1 = replace(strTemp1,"{","_")
                        strTemp1 = replace(strTemp1,"}","_")
                        strTemp1 = replace(strTemp1,".","_")
                        strTemp1 = replace(strTemp1,"_slice","")
                        strTemp1 = lcase(strTemp1)
                
                        if RENAME_LENGTH > 0 then
                                if len(strTemp1) + len(labelletter) > RENAME_LENGTH then
                                        strTemp1 = fnShortenLabels(strTemp1,RENAME_LENGTH - len(labelletter))
                                        .Cells[iRow][2] = fnInsureUniqueLabelLines(hashshort,strTemp1 + LabelLetter)
                                end if
                        end if
                        
                        .Cells[iRow][3] = SavVar.Label 
                        if(arrLabels[i] <> "") then
                                if find(arrLabels[i],savvar.label)>-1 then
                                        .Cells[iRow][4] = arrLabels[i]
                                else
                                        .Cells[iRow][4] = SavVar.Label + " - " + arrLabels[i]
                                end if
                        end if
        
                        iRow = iRow + 1
                     
                        next
                end if
                blnMatchVars = False
        next
        .Range["A1:E"+Ctext(xlWorkSheet.Cells.SpecialCells(11).Row)].columnwidth = 40

end with

SAV.Close()

xlWorkbook.SaveAs(XL_FILE)
xlWorkBook.Application.Quit()
xlApp.Application.Quit()

Set xlWorksheet = Null
Set xlWorkBook = Null
Set xlApp = Null


function fnGetOriginalName(objColl,SAVVarName,i)
dim arrSplit
dim j
dim strTest
dim strTest2

if find(SAVVarName,"_") >-1 then
        arrSplit = split(SAVVarName,"_")
else
        arrSplit = SAVVarName
end if
for j = i to ubound(arrSplit)
        strTest = strTest + arrSplit[j]
        if objColl.FindItem(arrSplit[j]) is not null then
                set objColl = objColl[arrSplit[j]]
                strTest2 = strTest2 + fnGetOriginalName(objColl,arrSplit,j + 1)
        else
                strTest = strTest + "_"
        end if
next


end function


function fnStripIterations(VarName)

'this function returns the names of all fields included in a variable fullname

'VarName        text string that will be parsed

        'q1[{pepsi}].imagery[{tastesgreat}].slice returns 'q1.imagery.slice'
        
'*************************************************************************************************************************
'*************************************************************************************************************************
'*************************************************************************************************************************

    
    
    Dim objRegExp       ' Regular Expression Object
        
    ' Create built In Regular Expression object
    set objRegExp = CreateObject("VBScript.RegExp")
    objRegExp.Global = True
    ' Set the pattern To look For  tags
    objRegExp.Pattern = "\[[^\]]*\]"
        
    ' Return the original String stripped of iteration information
    fnStripIterations = objRegExp.Replace(varname, "")
        
    Set objRegExp = null
    
End function

Function fnConvertToLetter(ColumnNumber)

'this function takes a number and converts it to letters used for columns in Excel

'ColumnNumber   integer that will be converted to letter(s)
        '1 = A
        '26 = Z
        '27 = AA
        '52 = AZ
        '53 = BA
        '...

'*************************************************************************************************************************
'*************************************************************************************************************************
'*************************************************************************************************************************      
        
        dim ColumnLetter
        
        If ColumnNumber <= 0 Then
        'negative column number
        ColumnLetter = ""    
        ElseIf ColumnNumber > 16384 Then
            'column not supported (too big) in Excel 2007
            ColumnLetter = ""  
        ElseIf ColumnNumber > 702 Then
        ' triple letter columns
        ColumnLetter = _
        Chrw((Int((ColumnNumber-1-26-676) / 676)) Mod 676 + 65) + _
        Chrw((Int((ColumnNumber-1-26) / 26) Mod 26) + 65) + _
        Chrw(((ColumnNumber-1) Mod 26) + 65)
        ElseIf ColumnNumber > 26 Then
            ' double letter columns
            ColumnLetter = Chrw(Int((ColumnNumber-1) / 26) + 64) + _
                Chrw(((ColumnNumber-1) Mod 26) + 65)
        Else
            ' single letter columns
            ColumnLetter = Chrw(ColumnNumber + 64)
        End If
    
        fnConvertToLetter = ColumnLetter
        
End Function

function fnShortenLabels(strLabel, DesiredLength)

'this function shortens the variable names that are placed on the label lines.  First it removes vowels from
'the label starting from the right.  After all vowels are removed and it is still longer than the desired length,
'it will cut off characters at the right 

'strLabel               the text to be shortened
'DesiredLength  the length it should be shortened to

'*************************************************************************************************************************
'*************************************************************************************************************************
'*************************************************************************************************************************

        dim i
        'debug.Log("before:  " + strLabel)

        'remove all the underscores moving from right to left
        if len(strLabel) > DesiredLength then
                for i = len(strLabel) -1  to 0 step -1
                        select case mid(strLabel,i,1)
                                case "_"
                                        strLabel = left(strLabel,i) + mid(strLabel,i+1)
                        end select
                        if len(strLabel)=DesiredLength then exit for    
                next
        end if
        
        'remove all the vowels - moving from right to left
        for i = len(strLabel) -1  to 0 step -1
                select case mid(strLabel,i,1)
                        case "a","e","i","o","u"
                                strLabel = left(strLabel,i) + mid(strLabel,i+1)
                end select
                if len(strLabel)=DesiredLength then exit for
        next
        
        'truncate characters over desired length
        if len(strLabel) > DesiredLength then
                        strLabel = Left(strLabel,DesiredLength)
        end if

        fnShortenLabels = strLabel
        'debug.Log("after:  " + strLabel)       
end function

function fnInsureUniqueLabelLines(hash,strTemp)

dim intTemp
dim strOut
dim strTemp1
dim strTemp2
dim strTemp3

'call sbUpdateHash(hash,strTemp)
if hash.exists(strTemp) then
        if find(hash.item[strTemp],"_xx_")>0 then
                'this was already a duplicate
                intTemp = mid(hash[strTemp],find(hash.item[strTemp],"_xx_")+4)
                hash.item[strTemp] = replace(hash.item[strTemp],"_xx_" + ctext(intTemp), "_xx_" + ctext(intTemp+1))
            'debug.Log("** More than one duplicate - " + hash.item[strTemp])
        else
                hash.item[strTemp] = hash.item[strTemp] + "_xx_" + "2"
                'debug.Log("* First duplicate - " + hash.item[strTemp])
        end if
else
        hash.add(strTemp, strTemp)
end if
'debug.Log("hash count is " + ctext(hash.count))

if find(hash.item[strTemp],"_xx_")>-1 then
        'qclient_xx_1
        
        strTemp1 = left(hash.item[strTemp],find(hash.item[strTemp],"_xx_"))
                'qclient
        strTemp2 = mid(hash[strTemp],find(hash.item[strTemp],"_xx_")+4)
                '1
        strTemp3 = left(strTemp1,RENAME_LENGTH - len(ctext(clong(strTemp2))))
                'qclien
                
        if strTemp3 <> strTemp1 then
                'this will be shortened
                if hash.exists(strTemp3) then
'                       if find(hash.item[strTemp3],"_xx_")>0 then
                                'this was already a duplicate
                                intTemp = mid(hash[strTemp3],find(hash.item[strTemp3],"_xx_")+4)
                                hash.item[strTemp3] = replace(hash.item[strTemp3],"_xx_" + ctext(intTemp), "_xx_" + ctext(intTemp+1))
                        'debug.Log("** More than one duplicate - " + hash.item[strTemp])
'                       else
'                               hash.item[strTemp3] = hash.item[strTemp3] + "_xx_" + "2"
'                               'debug.Log("* First duplicate - " + hash.item[strTemp])
'                       end if
                else
                        hash.add(strTemp3, strTemp3 + "_xx_" + "2")
                end if
                
                if find(hash.item[strTemp3],"_xx_")>0 then
                        strTemp2 = mid(hash[strTemp3],find(hash.item[strTemp3],"_xx_")+4)
                else
                        strTemp2 = ""
                end if
                strTemp1 = strTemp3

        end if
        
        'update the label to what what was finally used
        hash.item[strTemp] = left(strTemp1,RENAME_LENGTH - len(strTemp2)) + "_xx_" + strTemp2
        if strTemp3 <> strTemp then
                hash.item[strTemp3] = left(strTemp1,RENAME_LENGTH - len(strTemp2)) + "_xx_" + strTemp2
        end if
else
        strTemp1 = hash.item[strTemp]
        strTemp2 = ""
end if

fnInsureUniqueLabelLines = left(strTemp1,RENAME_LENGTH - len(strTemp2)) + strTemp2





end function

