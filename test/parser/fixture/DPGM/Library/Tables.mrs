'*****FILE VERSION=9, DATE LAST MODIFIED=2012/12/12, KO

'!
'*******************************************************
'build tables

Function fnAddTable(TableDoc,strSideSpec,strTopSpec,strTitleText,strBaseText)

Function fnAddGrid(TableDoc,strSideSpec,strTopSpec,strTitleText,strBaseText)

Function fnAddGridSliceTables(TableDoc,strGridName,strTopSpec,strTitleText,strBaseText, strShow)

Function fnAddGridSliceResponseSummary(TableDoc,strFieldName,strResponse, strTopSpec,strTitleText,strBaseText,strNoneOfAbove,strAddlAEItems,strShow,blnTotal,blnBaseHide)

Function fnAddMeanSummary(TableDoc,strFieldName,strTopSpec,strTitleText,strBaseText,strShow,strAnchor,blnBaseHide,strNumDecimals)

Function fnBuildTablesGridsCode(TableDoc,strSideSpec,strTopSpec,strTitleText,strBaseText,strLabel)


'*******************************************************
'Populate tables in pieces

sbSplitPopulate(TableDoc,MaxPopTableNumber)

'*******************************************************

'build filters for grid slices

Function fnFilterGridSlices(TableDoc,strGridName,strDefineListNameOrString,DefineListOrString,IncludeOrExclude)

'*******************************************************

'create a list of fields used in table run

Sub sbCreateListOfFieldsUsed(TableDoc)

'*******************************************************

'Use properties to store information

Sub sbStoreBannerSpec(tTable, sValue)

Sub sbAddProperty(tTable, sName, sValue)

'*******************************************************

'adjust labels on tables

Sub sbSetBaseText(oTable,txtToAdd)

Sub sbRemoveSideTitle(TableDoc)

'*******************************************************

'remove tables or elements from tables

Sub sbRemoveBlankTables(TableDoc)

'*******************************************************

'add or hide bases

sub sbHideBannerBases(oTable, iHide)

sub sbAddEffectiveBase(oTable)

sub sbHideSideUnweightedBase(oTable)

'*******************************************************

'expose tables - users only call for exposetable.  All otehrs are called by that sub

sub ExposeTable(oTable)
sub ExposeLabels(objAxis,txtAxisName)
sub ExposeAnnotations(oTable)
sub ExposeFilters(oTable)
sub AddToAnnotation0(oTable,txtToAdd)
sub ExposeCells(oTable)
sub ExposeRules(oTable)

'*******************************************************

'Add Visual RfS functionality to an MTD.
sbAdddVisualRfS() - call after you have exported any tables, but before you save the MTD.
sbAddDataVisualisation() - normally just called from this sub, but could be used to just add the functionality to individual tables.

sbAddVisualRfS(TableDoc)
sbAddDataVisualisation(parentObj)

!'
''*******************************************************

Function fnBuildTablesGridsCode(TableDoc,strSideSpec,strTopSpec,strTitleText,strBaseText,strLabel)
   'this function builds basic table

    'TableDoc           TOM Document object
    'strSideSpec        side spec
    'strTopSpec         banner/top breaks spec
    'strTitle           table title - will be set into table description field
    'strBaseText        base title - only needed if base differs from default
    'strLabel                   prefix for table name - either T or TG
    'Return             returns an array of table objects


    dim arrBreaks
    dim i
    dim arrTables[]
    dim intMax

    if strTopSpec <> "" then
        arrBreaks = split(strTopSpec,";")
    else
        arrBreaks = split(" ",";")
    end if

    for i = 0 to ubound(arrBreaks)

        With TableDoc
            With .Tables
                With .AddNew(strLabel + ctext(.count + 1),strSideSpec + iif(trim(strTopSpec)<>"","*" + arrBreaks[i],""),strTitleText)
                    .sbStoreBannerSpec(arrBreaks[i])

                    if strTitleText<>NULL then
                            .Side.SubAxes[0].Label = strTitleText
                            '.description = strTitleText
                    else
                        if fnVarExists(tabledoc,.side.subaxes[0].name) then

                                if find(strSideSpec,"[{") > 0 then
                                   .Side.SubAxes[0].Label=TableDoc.DataSet.MdmDocument.Variables[ctext(.side.subaxes[0].name)].Label + " - " + TableDoc.DataSet.MdmDocument.Fields[left(strSideSpec,find(strSideSpec,"[{"))].elements[left(mid(strSideSpec,find(strSideSpec,"[{") + 2),find(mid(strSideSpec,find(strSideSpec,"[{") + 2),"}]"))].label
                                else
                                   .Side.SubAxes[0].Label=TableDoc.DataSet.MdmDocument.Variables[ctext(.side.subaxes[0].name)].Label
                                '.description=TableDoc.DataSet.MdmDocument.Variables[ctext(.side.subaxes[0].name)].Label
                              end if
                        else
                                if find(.side.subaxes[0].name,"[..]")>-1 then
                                'this is actually a grid slice and won't be in the variables collection
                                .Side.SubAxes[0].Label=TableDoc.DataSet.MdmDocument.Fields[left(.side.subaxes[0].specification,find(.side.subaxes[0].specification,"[..]"))].label
                                '.description=TableDoc.DataSet.MdmDocument.Fields[left(.side.subaxes[0].specification,find(.side.subaxes[0].specification,"[..]"))].label
                            else
                                .Side.SubAxes[0].Label=TableDoc.DataSet.MdmDocument.Fields[.side.subaxes[0].specification].label
                                '.description=TableDoc.DataSet.MdmDocument.Fields[.side.subaxes[0].specification].label
                            end if
                        end if

                    end if
                    .description = .Side.SubAxes[0].Label
                end with

                if strBaseText<>Null then
                    sbSetBaseText(.Item[strLabel+ctext(.Count)],strBaseText)
                end if

                set arrTables[arrTables.UBound()+1] = .Item[strLabel+ctext(.Count)]
            End With
        End With
    next
    fnBuildTablesGridsCode = arrTables

End Function


Function fnAddTable(TableDoc,strSideSpec,strTopSpec,strTitleText,strBaseText)

        fnAddTable = fnBuildTablesGridsCode(TableDoc,strSideSpec,strTopSpec,strTitleText,strBaseText,"T")

End Function


Function fnAddGrid(TableDoc,strSideSpec,strTopSpec,strTitleText,strBaseText)

        fnAddGrid = fnBuildTablesGridsCode(TableDoc,strSideSpec,strTopSpec,strTitleText,strBaseText,"TG")

End Function


Sub sbStoreBannerSpec(tTable, sValue)
        Dim tProperty   'iProperty object from the tables object model.

        Set tProperty = tTable.properties.CreateProperty()
        tProperty.Name = "BannerSpec"
        tProperty.Value = sValue
        tTable.Properties.Add(tProperty)
End Sub


Sub sbAddProperty(tTable, sName, sValue)
        Dim tProperty   'iProperty object from the tables object model.

        Set tProperty = tTable.properties.CreateProperty()
        tProperty.Name = sName
        tProperty.Value = sValue
        tTable.Properties.Add(tProperty)
End Sub

Function fnVarExists(TableDoc,strVar)
        on error GOTO noVar
        fnVarExists = false
        if TableDoc.dataset.mdmDocument.variables[strVar].name <> "" then fnVarExists = true
        noVar:
        err.Clear()
End Function

function fnAddGridSliceTables_old(TableDoc,strFieldName,strTopSpec,strTitleText, strBaseText, strShow)

    'this function creates individual tables for each iteration of a selected grid/field combination

    'TableDoc           TOM Document object
    'strFieldName       field name (such as "q2[..].slice")
    'strTopSpec         banner/top breaks spec
    'strTitleText       table title - will be set into table description field
    'strBaseText        base title - only needed if base differs from default
    'strShow            string of categories that control which iterations of grid will be included in summary - set to null if all columns wanted
    'Return                     returns an array of table objects

        dim arrList
        dim i
        dim slice
        dim arrBreaks
    dim j
    dim k
    dim arrTables[]
    dim objTab
    dim objField
    dim objParent
    dim blnNumeric
    dim blnMatch
    dim objColl
    dim strBracket1
    dim strBracket2

    set objField = Tabledoc.dataset.MDMDocument.fields[strFieldName]
    set objParent = objField.parent.parent

    if objParent.categories.count = 0 then
        blnNumeric = True
        set objColl = objParent.elements.elements
        strBracket1 = "["
        strBracket2 = "]."
    else
        set objColl = objParent.categories
        strBracket1 = "[{"
        strBracket2 = "}]."

        end if

    if strTopSpec <> "" then
        arrBreaks = split(strTopSpec,";")
        else
                arrBreaks = split(" ",";")
        end if
        if strShow <> Null then

        'remove the grid name and {} from strShow
        if find(strShow,"{")>-1 then
                strShow = mid(strShow,find(strShow,"{") + 1)
        end if
        if find(strShow,"}")>-1 then
            strShow = left(strShow,find(strShow,"}"))
        end if

                arrList = split(strShow,",")
                for i = 0 to ubound(arrList)
                        blnMatch = False
                        if  not(IsNullObject(finditem(objColl, arrList[i]))) then
                                with TableDoc.Tables
                                    for j = 0 to ubound(arrBreaks)
                                                for each objTab in fnAddTable(TableDoc,objParent.Name + strBracket1 + arrList[i] + strBracket2 + objField.name,arrBreaks[j],iif(strTitleText<>"",strTitleText,objParent.label) + " - " + objColl[arrList[i]].label,strBaseText)
                                                'for each objTab in fnAddTable(TableDoc,objParent.Name + strBracket1 + arrList[i] + strBracket2 + objField.name,arrBreaks[j],iif(strTitleText<>"",strTitleText,objParent.label),strBaseText)
                                                        set arrTables[arrTables.UBound()+1] = objTab
                                                next
                                        next
                                end with
                        end if
                next

        else

        for each slice in objColl
                for j = 0 to ubound(arrBreaks)
                        with TableDoc.Tables
                                        for each objTab in fnAddTable(TableDoc,objParent.name + strBracket1 + slice + strBracket2 + objField.name,arrBreaks[j],iif(strTitleText<>"",strTitleText,objParent.label) + " - " + slice.label,strBaseText)
                                        set arrTables[arrTables.UBound()+1] = objTab
                                next
                        end with
                next
                next

        end if

        fnAddGridSliceTables_old = arrTables
End function

function fnAddGridSliceTables(TableDoc,strFieldName,strTopSpec,strTitleText, strBaseText, strShow, strSpec)

    'this function creates individual tables for each iteration of a selected grid/field combination

    'TableDoc           TOM Document object
    'strFieldName       field name (such as "q2[..].slice")
    'strTopSpec         banner/top breaks spec
    'strTitleText       table title - will be set into table description field
    'strBaseText        base title - only needed if base differs from default
    'strShow            string of categories that control which iterations of grid will be included in summary - set to null if all columns wanted
    'Return                     returns an array of table objects

        dim arrList
        dim i
        dim slice
        dim arrBreaks
    dim j
    dim k
    dim arrTables[]
    dim objTab
    dim objField
    dim objParent
    dim blnNumeric
    dim blnMatch
    dim objColl
    dim strBracket1
    dim strBracket2

    set objField = Tabledoc.dataset.MDMDocument.fields[strFieldName]
    set objParent = objField.parent.parent

    if objParent.categories.count = 0 then
        blnNumeric = True
        set objColl = objParent.elements.elements
        strBracket1 = "["
        strBracket2 = "]."
    else
        set objColl = objParent.categories
        strBracket1 = "[{"
        strBracket2 = "}]."

        end if

    if strTopSpec <> "" then
        arrBreaks = split(strTopSpec,";")
        else
                arrBreaks = split(" ",";")
        end if
        if strShow <> Null then

        'remove the grid name and {} from strShow
        if find(strShow,"{")>-1 then
                strShow = mid(strShow,find(strShow,"{") + 1)
        end if
        if find(strShow,"}")>-1 then
            strShow = left(strShow,find(strShow,"}"))
        end if

                arrList = split(strShow,",")
                for i = 0 to ubound(arrList)
                        blnMatch = False
                        if  not(IsNullObject(finditem(objColl, arrList[i]))) then
                                with TableDoc.Tables
                                    for j = 0 to ubound(arrBreaks)
                                                for each objTab in fnAddTable(TableDoc,objParent.Name + strBracket1 + arrList[i] + strBracket2 + objField.name + strSpec,arrBreaks[j],iif(strTitleText<>"",strTitleText,objField.label) + " - " + objColl[arrList[i]].label,strBaseText)
                                                'for each objTab in fnAddTable(TableDoc,objParent.Name + strBracket1 + arrList[i] + strBracket2 + objField.name + strSpec,arrBreaks[j],iif(strTitleText<>"",strTitleText,objParent.label),strBaseText)
                                                        set arrTables[arrTables.UBound()+1] = objTab
                                                next
                                        next
                                end with
                        end if
                next

        else

        for each slice in objColl
                for j = 0 to ubound(arrBreaks)
                        with TableDoc.Tables
                                        for each objTab in fnAddTable(TableDoc,objParent.name + strBracket1 + slice + strBracket2 + objField.name + strSpec,arrBreaks[j],iif(strTitleText<>"",strTitleText,objField.label) + " - " + slice.label,strBaseText)
                                        set arrTables[arrTables.UBound()+1] = objTab
                                next
                        end with
                next
                next

        end if

        fnAddGridSliceTables = arrTables
End function

Function fnAddGridSliceResponseSummary(TableDoc,strFieldName,strResponse, strTopSpec,strTitleText,strBaseText,strNoneOfAbove,strAddlAEItems,strShow,blnTotal,blnBaseHide)

    'this function builds one table that is a summary of response(s) chosen across all selected iterations of a grid/field combination

    'TableDoc           TOM Document object
    'strFieldName       field name (such as "q2[..].slice")
    'strResponse            response to be summarized - can be single ("statement1"), or multiple ("statement1,statement3") to produce a net of responses given
    'strTopSpec         banner/top breaks spec
    'strTitle           table title - will be set into table description field
    'strBaseText        base title - only needed if base differs from default
    'strNoneOfAbove         label for none of the above category - set to Null if should not be included
    'strAddlAEItems         items to append to the end of axis expression this function builds (typically sigma/mean/etc.)
    'strShow            string of categories that control which iterations of grid will be included in summary - set to null if all columns wanted
    'blnTotal           set to True if table should be based to total instead of those asked each iteration
    'blnBaseHide        True/False - to hide or not hide sub-bases within the table (ishidden=?)
    'Return             returns an array of table objects

    dim slice, strAE
    dim arrList
    dim i
    dim arrBreaks
    dim j
    dim arrTables[]
    dim strNone
    dim objField
    dim objParent
    dim objSlice
    dim objTab
    dim strBase
    dim strBalance
    dim blnNumeric
    dim blnMatch
    dim objColl
    dim strBracket1
    dim strBracket2
    dim objParentofPar
    dim strStubBase

    set objField = Tabledoc.dataset.MDMDocument.fields[strFieldName]
    set objParent = objField.parent.parent


    If objParent.Parent.parent <> NULL Then
        set objParentofPar = objParent.parent.parent
    End if

    if objParent.categories.count = 0 then
        blnNumeric = True
        set objColl = objParent.elements.elements
        strBracket1 = "["
        strBracket2 = "]."
    else
        set objColl = objParent.categories
        strBracket1 = "[{"
        strBracket2 = "}]."
        end if

    if strTopSpec <> "" then
        arrBreaks = split(strTopSpec,";")
        else
                arrBreaks = split(" ",";")
        end if

    for j = 0 to ubound(arrBreaks)
        strAE = ""
        strNone = ""
        strBase = ""
        strBalance = ""

        if strShow <> Null then

                'remove the grid name and {} from strShow
                if find(strShow,"{")>-1 then
                        strShow = mid(strShow,find(strShow,"{") + 1)
                end if
                if find(strShow,"}")>-1 then
                    strShow = left(strShow,find(strShow,"}"))
                end if

                arrList = split(strShow,",")
                for i = 0 to ubound(arrList)
                        blnMatch = False
                        if not(IsNullObject(finditem(objColl, arrList[i]))) then
                            set objSlice = objColl[arrList[i]]
                            strStubBase=""
                            strStubBase=",base_"+ctext(objSlice.Name)+" base('"+objParent.Name + strBracket1 + objSlice.name + strBracket2 + objField.name + " is not null"+"') [ishidden="+ctext(blnBaseHide)+"],"

                            if (UCASE(blnTotal) = "FALSE") then
                                        strAE = strAE + strStubBase
                            else
                                        strAE = strAE + ","
                            end if

                            strAE = strAE + iif(blnNumeric = true,"_","") + objSlice.Name + " '" + Replace(objSlice.Label,"'","''") + "' expression('" + objParent.name + strBracket1 + objSlice.name + strBracket2 + objField.name + ".ContainsAny({" + strResponse + "})')"
                            strNone = strNone + objParent.Name + strBracket1 + objSlice.name + strBracket2 + objField.name + ".ContainsAny({" + strResponse + "}) or "
                            strBase = strBase + objParent.Name + strBracket1 + objslice.name + strBracket2 + objField.name + " is not null or "
                            strBalance = strBalance + objParent.Name + strBracket1 + objslice.name + strBracket2 + objField.name + " is not null or "
                         end if
                        next
                else
                        If objParentofPar = NULL Then
                        for each slice in objColl
                                strStubBase=""
                                    strStubBase=",base_"+ctext(slice)+" base('"+objParent.Name + strBracket1 + slice.name + strBracket2 + objField.name + " is not null"+"') [ishidden="+ctext(blnBaseHide)+"],"

                                if (UCASE(blnTotal) = "FALSE") then
                                        strAE = strAE + strStubBase
                                else
                                        strAE = strAE + ","
                                end if

                                strAE = strAE + iif(blnNumeric = true,"_","") + slice.Name + " '" + Replace(slice.Label,"'","''") + "' expression('" + objParent.Name + strBracket1 + slice + strBracket2 + objField.name + ".ContainsAny({" + strResponse + "})')"
                                strNone = strNone + objParent.Name + strBracket1 + slice.name + strBracket2 + objField.name + ".ContainsAny({" + strResponse + "}) or "
                                strBase = strBase + objParent.Name + strBracket1 + slice.name + strBracket2 + objField.name + " is not null or "
                                strBalance = strBalance + objParent.Name + strBracket1 + slice.name + strBracket2 + objField.name + " is not null or "
                        next

                        Else
                            for each slice in objColl
                                        strStubBase=""
                                        strStubBase=",base_"+ctext(slice)+" base('"+objParent.Name + strBracket1 + slice.name + strBracket2 + objField.name + " is not null"+"') [ishidden="+ctext(blnBaseHide)+"],"
                            if (UCASE(blnTotal) = "FALSE") then
                                        strAE = strAE +strStubBase
                            else
                                        strAE = strAE +","
                            end if

                                     strAE = strAE + iif(blnNumeric = true,"_","") + slice.Name + " '" + Replace(slice.Label,"'","''") + "' expression('"+ objParentofPar.name + "[..]." + objParent.Name + strBracket1 + slice + strBracket2 + objField.name + ".ContainsAny({" + strResponse + "})')"
                                     'debug.Log(strAE)
                                     strNone = strNone +objParentofPar.name +"[..]." + objParent.Name + strBracket1 + slice.name + strBracket2 + objField.name + ".ContainsAny({" + strResponse + "}) or "
                                     strBase = strBase +objParentofPar.name +"[..]." +objParent.Name + strBracket1 + slice.name + strBracket2 + objField.name + " is not null or "
                                     strBalance = strBalance +objParentofPar.name +"[..]." +objParent.Name + strBracket1 + slice.name + strBracket2 + objField.name + " is not null or "
                        Next
                     End if

                end if
                strNone = Left(strNone,Len(strNone)-3)

                strBase = Left(strBase,Len(strBase)-4)
                strBalance = Left(strBalance,Len(strBalance)-4)

        strNone = iif(strNoneOfAbove <> "",",_NoneOfTheAbove '" + strNoneOfAbove + "' expression('not (" + strNone + ")" + iif(blnTotal = false,"and (" + strBalance + ")')","')"),"")


        if blnBaseHide = TRUE then
            strBase = ",base('" + strBase + "')"
        else
            strBase = ""
        end if

        if (UCASE(blnTotal) = "FALSE") then
'                    strAE = "axis({e1 '' text()," +strBase+",e2 '' text()" + strAE
                    strAE = "axis({e1 '' text(),base 'Base : "+strBaseText+"' base(),e2 '' text()" + strAE
        else
                    strAE = "axis({e1 '' text(),base 'Base : Total Respondent' base(),e2 '' text()" + strAE
        end if


        strAE = strAE + strNone + iif(strAddlAEItems<>"","," + strAddlAEItems,"") + ",e3 '' text(),sigma 'Sigma' subtotal()})"
'        debug.Log(strAE)

                        'Uncomment in order to see the code created in the log file
                        'debug.Log("Result from fnAddGridSliceResponseSummary: " + strAE)

            if (UCASE(blnTotal) = "FALSE") then
                for each objTab in fnAddTable(TableDoc,strAE,arrBreaks[j],iif(strTitleText<>"",strTitleText,objParent.label),NULL)
                        set arrTables[arrTables.UBound()+1] = objTab
                next
            end if

            if (UCASE(blnTotal) = "TRUE") then
                for each objTab in fnAddTable(TableDoc,strAE,arrBreaks[j],iif(strTitleText<>"",strTitleText,objParent.label),strBaseText)
                        set arrTables[arrTables.UBound()+1] = objTab
                next
            end if

        next
        fnAddGridSliceResponseSummary = arrTables
End Function


Function fnAddMeanSummary(TableDoc,strFieldName,strTopSpec, strTitleText,strBaseText,strShow,strAnchor,blnBaseHide,strNumDecimals)

        'this function builds a mean summary table for each iteration of a selected grid/field combination

        'Factors need to be defined in MDD for statement/Rating category - can be applied directly to metadata
        'or via sbSetAxisExpression

    'TableDoc           TOM Document object
    'strFieldName       field name (such as "q2[..].slice")
    'strTopSpec         banner/top breaks spec
    'strTitleText       table title - will be set into table description field
    'strBaseText        base title - only needed if base differs from default
    'strShow            string of categories that control which iterations of grid will be included in summary - set to null if all columns wanted
    'strAnchor          string of categories not to get sorted on table
    'blnBaseHide        string set TRUE for hiding bases, FALSE for displaying the bases above each and every attribute
    'strNumDecimals     To display number of decimals for mean value
    'Return                     returns an array of table objects

    dim slice
    dim strAE
    dim inneriter
    dim i
    dim j
    dim X
    dim innerslice
    dim arrBreaks
    dim break
    dim objTab
    dim arrList
    dim arrTables[]
    dim objField
    dim objParent
    dim blnNumeric
    dim objColl
    dim strBracket1
    dim strBracket2
    dim arrFactors
    dim facinc
    dim arrAnchor
    dim anc
    dim strAncAE
    dim baseFilt
    dim sliceholder

    set objField = Tabledoc.dataset.MDMDocument.fields[strFieldName]
    set objParent = objField.parent.parent

    if objParent.categories.count = 0 then
        blnNumeric = True
        set objColl = objParent.elements.elements
        strBracket1 = "["
        strBracket2 = "]."
    else
        set objColl = objParent.categories
        strBracket1 = "[{"
        strBracket2 = "}]."
        end if

        ''''Copying factor values into an Array
        ''''' Not Required Now arrFactors=split(strFactors,",")

    'remove the grid name and {} from strAnchor
    if find(strAnchor,"{")>-1 then
        strAnchor = mid(strAnchor,find(strAnchor,"{") + 1)
    end if
        if find(strAnchor,"}")>-1 then
                strAnchor = left(strAnchor,find(strAnchor,"}"))
        end if
        ''''Copying the elements/stubs that need to be fixed/showed at the bottom of the table
        arrAnchor=split(strAnchor,",")

    if strShow <> Null then

        'remove the grid name and {} from strShow
        if find(strShow,"{")>-1 then
                strShow = mid(strShow,find(strShow,"{") + 1)
        end if
        if find(strShow,"}")>-1 then
            strShow = left(strShow,find(strShow,"}"))
        end if

                'build the expression to make a summary of the iterations included in strShow
                arrList = split(strShow,",")

                for i = 0 to ubound(arrList)
                    if not(IsNullObject(finditem(objColl, arrList[i]))) then

                        '''''Is not Numeric Grid
                        If not (objField.DataType = 1 Or objField.DataType=6) Then

                                                        '''Base element - for categorical Grids
                                                        sliceholder=split(objField.Replace("..","").replace("[","").replace("]",""),".")
                                                        baseFilt=ctext(objParent.name)+strBracket1+arrList[i]+strBracket2+ctext(sliceholder[1])
                                    strAE=strAE+"meanbase"+arrList[i]+" 'Base' base('"+baseFilt+"') [isfixed=false,ishidden="+ctext(blnBaseHide)+"],"

                                For Each innerslice in objField.Elements.Elements
                                        ''''''Anchoring elements for categorical grid slices - InnerSlices
                                        if find(strAnchor,arrList[i])<>-1 and trim(ctext(innerslice.factor))<>"" then
                                                strAncAE =  strAncAE + arrList[i]+Ctext(innerslice.name)+" expression('"+objParent.name + strBracket1 + arrList[i] + strBracket2 + objField.name+".containsAny({"+Ctext(innerslice.name)+"})') [ishidden=true,factor="+ctext(innerslice.factor)+"],"
                                        elseif trim(ctext(innerslice.factor))<>"" then
                                                strAE =  strAE + arrList[i]+Ctext(innerslice.name)+" expression('"+objParent.name + strBracket1 + arrList[i] + strBracket2 + objField.name+".containsAny({"+Ctext(innerslice.name)+"})') [ishidden=true,factor="+ctext(innerslice.factor)+"],"
                                        end if
                                Next
                                '''''Anchoring elements for categorical grid slices
                                if find(strAnchor,arrList[i])<>-1 then
                                        strAncAE =  strAncAE + "mean"+ctext(arrList[i])+Ctext(innerslice.name)+" '"+Replace(objColl[arrList[i]].label,"'","''")+"' mean() [isfixed=true,CalculationScope=PrecedingElements,decimals="+ctext(strNumDecimals)+"],_"
                                else
                                        strAE=strAE+"mean"+ctext(arrList[i])+Ctext(innerslice.name)+" '"+Replace(objColl[arrList[i]].label,"'","''")+"' mean() [isfixed=false,CalculationScope=PrecedingElements,decimals="+ctext(strNumDecimals)+"],_"
                                end if

                        else ''''If it's a Numeric Grid

                                                        '''Base element - for Numeric Grids
                                    strAE=strAE+"meanbase"+arrList[i]+" 'Base' base('LevelId={"+arrList[i]+"}') [isfixed=false,ishidden="+ctext(blnBaseHide)+"],"

                                '''''Anchoring elements for categorical grid slices
                                if find(strAnchor,arrList[i])<>-1 then
                                    strAncAE =  strAncAE + "mean"+ctext(arrList[i])+" '"+Replace(objColl[arrList[i]].label,"'","''")+"' mean("+strFieldName+",'LevelId={"+arrList[i]+"}') [isfixed=true,CalculationScope=PrecedingElements,decimals="+ctext(strNumDecimals)+"],"
                            else
                                strAE=strAE+"mean"+ctext(arrList[i])+" '"+Replace(objColl[arrList[i]].label,"'","''")+"' mean("+strFieldName+",'LevelId={"+arrList[i]+"}') [isfixed=false,CalculationScope=PrecedingElements,decimals="+ctext(strNumDecimals)+"],"
                            end if
                        end iF '''End of Not Numeric Grid IF condition
                                        end if
                                next

                ''''''Combining NormalSlices + Fixed slices to the end
                strAE=strAE+strAncAE

                '''''Is not Numeric Grid
                If not (objField.DataType = 1 Or objField.DataType=6) Then
                        strAE="axis({e1 '' text(),base(),e2 '' text(),"+left(strAE,len(strAE)-2)+"})"
                else
                        strAE=strFieldName+"{e1 '' text(),base(),e2 '' text(),"+left(strAE,len(strAE)-1)+"}"
                End If
                'debug.Log("strAE :"+ctext(strAE))

        else '''STRSHOW is blank
        'build the expression to make a summary of all the iterations
        i = 0
        For Each slice in objColl

                '''''Is not Numeric Grid
                If not (objField.DataType = 1 Or objField.DataType=6) Then

                                '''Base element - for categorical Grids
                                sliceholder=split(objField.Replace("..","").replace("[","").replace("]",""),".")
                                baseFilt=ctext(objParent.name)+strBracket1+slice.name+strBracket2+ctext(sliceholder[1])
                    strAE=strAE+"meanbase"+slice.name+" 'Base' base('"+baseFilt+"') [isfixed=false,ishidden="+ctext(blnBaseHide)+"],"

                    For Each innerslice in objField.Elements.Elements
                        '''''Anchoring elements for categorical grid slices - InnerSlices
                        if find(strAnchor,slice.name)<>-1 and trim(ctext(innerslice.factor))<>"" then
                                strAncAE =  strAncAE + slice.name+Ctext(innerslice.name)+" expression('"+objParent.name + strBracket1 + slice.name + strBracket2 + objField.name+".containsAny({"+Ctext(innerslice.name)+"})') [ishidden=true,factor="+ctext(innerslice.factor)+"],"
                        elseif trim(ctext(innerslice.factor))<>"" then
                                strAE =  strAE + slice.name+Ctext(innerslice.name)+" expression('"+objParent.name + strBracket1 + slice.name + strBracket2 + objField.name+".containsAny({"+Ctext(innerslice.name)+"})') [ishidden=true,factor="+ctext(innerslice.factor)+"],"
                        end if
                        Next

                        '''''Anchoring elements for categorical grid slices
                    if find(strAnchor,slice.name)<>-1 then
                                        strAncAE =  strAncAE+"mean"+slice.name+Ctext(innerslice.name)+" '"+Replace(slice.label,"'","''")+"' mean() [isfixed=true,CalculationScope=PrecedingElements,decimals="+ctext(strNumDecimals)+"],_"
                    else
                                        strAE=strAE+"mean"+slice.name+Ctext(innerslice.name)+" '"+Replace(slice.label,"'","''")+"' mean() [isfixed=false,CalculationScope=PrecedingElements,decimals="+ctext(strNumDecimals)+"],_"
                    end if

                                i = i + 1

                        Else


                                '''Base element - for Numerical Grids
                    strAE=strAE+"meanbase"+slice.name+" 'Base' base('LevelId={"+Slice.name+"}') [isfixed=false,ishidden="+ctext(blnBaseHide)+"],"

                                '''''Anchoring elements for numeric grid slices
                        if find(strAnchor,slice.name)<>-1 then
                        strAncAE =  strAncAE+"mean"+ctext(Slice.name)+" '"+Replace(Slice.label,"'","''")+"' mean("+strFieldName+",'LevelId={"+Slice.name+"}') [isfixed=true,CalculationScope=PrecedingElements,decimals="+ctext(strNumDecimals)+"],"
                        else
                        strAE=strAE+"mean"+ctext(Slice.name)+" '"+Replace(Slice.label,"'","''")+"' mean("+strFieldName+",'LevelId={"+Slice.name+"}') [isfixed=false,CalculationScope=PrecedingElements,decimals="+ctext(strNumDecimals)+"],"
                        end if
                        End If '''End of Not Mumeric Grid IF condition

        Next

        ''''''Combining NormalSlices + Fixed slices to the end
        strAE=strAE+strAncAE

        '''''Is not Numeric Grid
        If not (objField.DataType = 1 Or objField.DataType=6) Then
              if blnBaseHide = TRUE then
                strAE="axis({e1 '' text(),base(),e2 '' text(),"+left(strAE,len(strAE)-2)+"})"
              else
                strAE="axis({e1 '' text(),"+left(strAE,len(strAE)-2)+"})"
              end if
        else
              if blnBaseHide = TRUE then
                strAE=strFieldName+"{e1 '' text(),base(),e2 '' text(),"+left(strAE,len(strAE)-1)+"}"
              else
                strAE=strFieldName+"{e1 '' text(),"+left(strAE,len(strAE)-1)+"}"
              end if
        End If
                '''debug.Log("strAE :"+ctext(strAE))
    end if


'''''Full Variable
    If strTopSpec <> "" then
            arrBreaks = split(strTopSpec,";")
    Else
            arrBreaks = split(" ",";")
    End If
    Dim Property

    for j = 0 to ubound(arrBreaks)
            for each objTab in fnAddTable(TableDoc,strAE,arrBreaks[j],iif(strTitleText<>"",strTitleText,objParent.label),strBaseText)

            ''''Changing to HDATA if the Grid is Numeric
            If objField.DataType = 1 Or objField.DataType=6 Then
                    TableDoc.Tables[objTab.Name].level="Hdata"
            End If

            set arrTables[arrTables.UBound()+1] = objTab

           next
    Next

   fnAddMeanSummary = arrTables

End Function


Function fnFilterGridSlices(TableDoc,strGridName, strDefineListNameOrString,DefineListOrString,IncludeOrExclude)

    'this Function will return iterations of a grid that will be included in table spec
    'allows user to pass the name of a define list in metadata or a string of category names
    'allows user to include or exclude the items contained in the definelist or string

    'TableDoc                                   TOM Document object
    'strGridName                                grid name
        'strDefineListNameOrString      name of definelist to be used as filter, or string with categories to be used as filter
        'DefineListOrString                     can be "definelist" or "string" - tells function how to build filter
        'IncludeOrExclude                       can be "include" or "exclude"
        '                                                               -if include, then all entries in definelist or string will be included in output
        '                                                               -if exclude, then all entries in definelist or string will be excluded from output
        'Return                                         returns a string that can be used as input for table building functions

    dim TableCategory
    dim SubListElement
    dim curGrid
    dim blnMatch
    dim i
    dim j
    dim arrList
    dim arrList2
    dim strTemp
    dim objColl
    dim blnNumeric


    if TableDoc.Dataset.MDMDocument.fields[strGridName].categories.count = 0 then
        blnNumeric = True
        set objColl = TableDoc.Dataset.MDMDocument.fields[strGridName].elements.elements
    else
        set objColl = TableDoc.Dataset.MDMDocument.fields[strGridName].categories
        end if

    for each TableCategory in objColl
        select case ucase(DefineListOrString)

                case "DEFINELIST"
                for each SubListElement in TableDoc.Dataset.MdmDocument.types[strDefineListNameOrString].elements
                        select case ucase(IncludeOrExclude)

                        case "INCLUDE"
                                blnMatch = False
                            if SublistElement.name = TableCategory.name then
                                'found a match - keep it in the grid
                                blnMatch = True
                                exit for
                            end if
                        case "EXCLUDE"
                            blnMatch = True
                            if SublistElement.name = TableCategory.name then
                                'found a match - remove it from the grid
                                blnMatch = False
                                exit for
                            end if
                    end select
                next
            case "STRING"

                'remove the {} from strDefineListNameOrString
                        if find(strDefineListNameOrString,"{")>-1 then
                                strDefineListNameOrString = mid(strDefineListNameOrString,find(strDefineListNameOrString,"{") + 1)
                        end if
                        if find(strDefineListNameOrString,"}")>-1 then
                        strDefineListNameOrString = left(strDefineListNameOrString,find(strDefineListNameOrString,"}"))
                        end if

                arrList = split(strDefineListNameOrString,",")
                for i = 0 to ubound(arrList)
                    select case ucase(IncludeOrExclude)
                        case "INCLUDE"
                                blnMatch = False
                            if ucase(arrList[i]) = ucase(TableCategory.name) then
                                'found a match - keep it in the grid
                                blnMatch = True
                                exit for
                            end if
                        case "EXCLUDE"
                            blnMatch = True
                            if ucase(arrList[i]) = ucase(TableCategory.name) then
                                'found a match - remove it from the grid
                                blnMatch = False
                                exit for
                            end if
                     end select
                 next
             end select

             if blnMatch = True then
                'this slice will be included
                 fnFilterGridSlices = fnFilterGridSlices + iif(fnFilterGridSlices<>"",",","") + tablecategory.name
             end if
         next

                'code for re-ordering output to match the order of categories in string or define list
                arrList2 = split(fnFilterGridSlices,",")
                select case ucase(DefineListOrString)

                case "DEFINELIST"
                select case ucase(IncludeOrExclude)
                        case "INCLUDE"
                                        for each SubListElement in TableDoc.Dataset.MdmDocument.types[strDefineListNameOrString].elements
                                                for j = 0 to ubound(arrList2)
                                                        if ucase(SublistElement.name) = ucase(arrList2[j]) then
                                                                strTemp = strTemp + iif(strTemp<>"",",","") + arrList2[j]
                                                        end if
                                                next
                                        next
                                case "EXCLUDE"
                                        strTemp = fnFilterGridSlices
                        end select
                case "STRING"
                select case ucase(IncludeOrExclude)
                        case "INCLUDE"
                                        arrList = split(strDefineListNameOrString,",")
                                        for i = 0 to ubound(arrList)
                                                for j = 0 to ubound(arrList2)
                                                        if ucase(arrList[i]) = ucase(arrList2[j]) then
                                                                strTemp = strTemp + iif(strTemp<>"",",","") + arrList2[j]
                                                        end if
                                                next
                                                next
                                        case "EXCLUDE"
                                                strTemp = fnFilterGridSlices
                                end select
                end select

                fnFilterGridSlices = strGridName + "{" + strTemp + "}"
End Function




'********************************************

Sub sbCreateListOfFieldsUsed(TableDoc)
'''***************** CODE BELOW TO GENERATE A LIST OF ALL FIELDS USED

        'identify all the fields that were used in tables

        dim arrAxes[1], x, TempTab, strOut
        for each TempTab in TableDoc.Tables
                'debug.Log(temptab.name)
        fnGetAllAxesUsed(TempTab, arrAxes,"Fields")
        next

        debug.Log("** FIELDS USED:")
        for x = 0 to ubound(arrAxes)
        'debug.Log(arrAxes[x])
        strOut = strOut + arrAxes[x] + ", "
        if len(strOut)>500 then
                debug.Log(strOut + " _")
                strOut = ""
        end if
        next

        debug.Log(strOut)

End Sub


Function fnGetAllAxesUsed(oTable, arrAxes,VarsOrFields)

    with oTable
        if .isemptytop = false then
                with .top
                        .fnNavigateAxes("."+.name, arrAxes,VarsOrFields)
                end with
                end if

                if .isemptyside = false then
                with .side
                        .fnNavigateAxes("."+.name, arrAxes,VarsOrFields)
                end with
                end if
    end with
    fnGetAllAxesUsed = arrAxes
End Function

Function fnNavigateAxes(objAxis,txtAxisName, arrAxes[],VarsOrFields)
        Dim i,j,blnMatch, strMatch

        with objAxis
           for i = 0 to .subaxes.count-1

                        'debug.Log(.subaxes[i].name)
                        if VarsOrFields = "Vars" then
                                strMatch = .subaxes[i].name
                        end if
                        if VarsOrFields = "Fields" then
                                if find(.subaxes[i].name,"[") <> -1 then
                                        'get the field level from any grid slices
                                        strMatch = left(.subaxes[i].name,Find(.subaxes[i].name,"["))
                                else
                                        strMatch = .subaxes[i].name
                                end if
                                'get any helper fields
                                if find(strMatch,".") <> -1 then
                                        strMatch = left(strMatch,find(strMatch,"."))
                                end if

                        end if

                        for j = 0 to ubound(arrAxes)
                                'if .subaxes[i].name = arrAxes[j] then
                                if strMatch = arrAxes[j] then
                                        blnMatch = true
                                        exit for
                                end if
                        next

                        if arrAxes[0] = null then
                                'arrAxes[0] = .subaxes[i].name
                                arrAxes[0] = strMatch
                        else
                                if blnMatch = false then
                                '       arrAxes[ubound(arrAxes) + 1] = .subaxes[i].name
                                        arrAxes[ubound(arrAxes) + 1] = strMatch
                                end if
                        end if

                        'Use recursion to handle any nesting
                        .subaxes[i].fnNavigateAxes(txtAxisName+".Subaxes["+ctext(i)+"]", arrAxes,VarsOrFields)

                next
        end with

        fnNavigateAxes = arrAxes

End Function


Sub sbRemoveBlankTables(TableDoc)
    Dim i
    with TableDoc
        for i=.Tables.Count-1 to 0 step -1
            Select case .Tables[i].Base
               case -1
                    debug.Log("WARNING: Unable to determine if table - Table Number: " + .tables[i].name + " and Titled - " + trim(.tables[i].Description) + " is empty. Not removed")
                case 0
                    debug.Log("Table Number: "  + .tables[i].name + " and Titled " + trim(.tables[i].Description) + " has been removed")
                    .Tables.Remove(i)
            end select
        next
    end with
End Sub



Sub sbRemoveSideTitle(TableDoc)
    Dim myTab
    for each myTab in TableDoc.Tables
        myTab.side.SubAxes[0].Label=""
    next
End Sub



'*****Tables sbSetBaseText Insert FILE VERSION=1, DATE LAST MODIFIED=2011/06/13, KO
Sub sbSetBaseText(oTable,txtToAdd)
    Dim txtLabel
'    txtLabel="<br> {TableDescription \n} </br>" + BASETITLE
'    txtLabel=txtLabel+txtToAdd
'    txtLabel=txtLabel+""
'    oTable.Annotations[1].specification=txtLabel
    txtLabel=BASETITLE+txtToAdd
    oTable.Side.SubAxes[0].Elements.Item["base"].Label =txtLabel
End Sub
'*****END OF Tables sbSetBaseText  Insert



sub sbHideBannerBases(oTable,iHide)
        'Hides instances of base and effective base that it finds in the top banners of a table
        'will ignore the first base in first top.subaxes.

        'oTable - Table axis object - initial call will be table.side or table.top and then
        'this sub will call itself recursively to find all subaxes

        'iHide = 1 - keep first weighted base (or unweighted base if not a weighted variable)
        'iHide = 2 - keep first unweighted base
        'iHide = 3 - keep first weighted and unweighted bases
        'iHide = 4 - hide all bases

        Dim subAxis,elm, baseHidden, eBaseHidden, subsubaxis
        Dim j
        Dim blnWeighted, iCount

        if left(oTable.parentobject.parent.name,2) <> "TG" then
            for each subAxis in oTable.SubAxes
                        iCount = iCount + 1

            j = 0
            blnWeighted = False
                        for each elm in subAxis.Elements
                j = j + 1
                                if j = 1 and elm.type = 24 then
                                        blnWeighted = True
                                end if
                                if not(iCount = 1 and j <= 2) then 'do not remove very first instance of base on first subaxis
                                        select case elm.type
                                                case 1 'elementtype.eBase
                                                        elm.IsHidden=True
                                                case 24 'elementtype.eUnweightedBase
                                                        elm.IsHidden=True
                                        end select
                                else
                                      if blnWeighted = True then
                                                select case elm.type

                                                        case 1 'elementtype.eBase
                                                                if iHide = 1 then
                                                                        elm.IsHidden=False
                                                                end if
                                                                if iHide = 2 then
                                                                        elm.IsHidden=True
                                                                end if
                                                                if iHide = 3 then
                                                                        elm.IsHidden=False
                                                                end if
                                                                if iHide = 4 then
                                                                        elm.IsHidden=True
                                                                end if
                                                        case 24 'elementtype.eUnweightedBase
                                                                if iHide = 1 then
                                                                        elm.IsHidden=True
                                                                end if
                                                                 if iHide = 2 then
                                                                         elm.IsHidden=False
                                                                 end if
                                                                 if iHide = 3 then
                                                                         elm.IsHidden=False
                                                                 end if
                                                                 if iHide = 4 then
                                                                         elm.IsHidden=True
                                                                end if

                                                end select
                                        else

                                      if blnWeighted = False then
                                                select case elm.type

                                                        case 1 'elementtype.eBase
                                                                if iHide = 1 then
                                                                        elm.IsHidden=False
                                                                end if
                                                                if iHide = 2 then
                                                                        elm.IsHidden=False
                                                                end if
                                                                if iHide = 3 then
                                                                        elm.IsHidden=False
                                                                end if
                                                                if iHide = 4 then
                                                                        elm.IsHidden=True
                                                                end if


                                                end select

                                        end if
                                        end if
                                end if
                        next

                next
           end if
end sub


sub sbAddEffectiveBase(oTable,basetext)
        'Adds an effective base after every visible base it finds in the side axes of a table

        'oTable - Table Object

        Dim subAxis,i

        if not oTable.IsEmptySide then

                for each subAxis in oTable.Side.SubAxes
                        for i=subAxis.Elements.Count-1 to 0 step -1 'Have to loop backwards as we are adding to this collection
                                if subAxis.Elements[i].type=1 and not subAxis.Elements[i].IsHidden then '1 = elementtype.eBase
                                        subAxis.Elements.AddNew("e" + ctext(subAxis.Elements.Count+1),3,i+1) '3 = elementtype.eEffectiveBase
                                        subAxis.Elements[i+1].label = basetext
                                end if
                        next
                next
        end if
end sub

sub sbHideSideUnweightedBase(oTable)
        'Hides all unweighted bases in the side axes of a table

        'oTable - Table Object

        Dim subAxis,i

        if not oTable.IsEmptySide then

                for each subAxis in oTable.Side.SubAxes
                        for i= 0 to subAxis.Elements.Count-1
                                if subAxis.Elements[i].type=24 and not subAxis.Elements[i].IsHidden then '24 = eUnweightedBase
                                        subAxis.Elements[i].IsHidden = true
                                end if
                        next
                next
        end if
end sub


sub sbSetSideUnweightedBaseText(oTable,basetext)
        'Hides all unweighted bases in the side axes of a table

        'oTable - Table Object

        Dim subAxis,i

        if not oTable.IsEmptySide then

                for each subAxis in oTable.Side.SubAxes
                        for i= 0 to subAxis.Elements.Count-1
                                if subAxis.Elements[i].type=24 and not subAxis.Elements[i].IsHidden then '24 = eUnweightedBase
                                        subAxis.Elements[i].label = basetext
                                end if
                        next
                next
        end if
end sub


sub sbExposeTable(oTable)


        with oTable
                if .isemptytop = false then
                        with .top
                                .ExposeLabels("."+.name)
                        end with
                end if
                if .isemptyside = false then
                        with .side
                                .ExposeLabels("."+.name)
                        end with
                end if

                .ExposeAnnotations()
                .ExposeFilters()
                .ExposeCells()
                .ExposeRules()
        end with

end sub

sub ExposeLabels(objAxis,txtAxisName)
        Dim i,j

        with objAxis
           for i=0 to .subaxes.count-1
                .subaxes[i].label=txtAxisName+".Subaxes["+ctext(i)+"].Label"
                for j=0 to .subaxes[i].elements.count-1
                           .subaxes[i].elements[j].label=txtAxisName+".Subaxes["+ctext(i)+"].Elements["+ctext(j)+"].Label"
                        next

                        'Use recursion to handle any nesting
                        .subaxes[i].ExposeLabels(txtAxisName+".Subaxes["+ctext(i)+"]")
                next
        end with

end sub

'These obviously only expose what is applied to the table at the time of exposure.  There's nothing to stop
'you changing the table after you've done this and making a lie of the labels.

sub ExposeAnnotations(oTable)
        Dim i, txtLabel

        'TO DO: Check what happens with Global Annotations

        for i=0 to oTable.annotations.count-1
                txtLabel=".Annotations["+ctext(i)+"].Specification="""+oTable.annotations[i].specification+"""<br/><br/>"
                txtLabel=replace(txtLabel,"{","&#123;")
                txtLabel=replace(txtLabel,"}","&#125;")
                oTable.annotations[i].specification=txtLabel
        next
end sub


sub ExposeFilters(oTable)
        oTable.AddToAnnotation0("Global Filters:<br/>{Filters\g}")
        oTable.AddToAnnotation0("Table Filters:<br/>{Filters\t}")
end sub


sub AddToAnnotation0(oTable,txtToAdd)
        Dim txtLabel

        txtLabel=oTable.Annotations[0].specification

        txtLabel=txtLabel+"<span style=""color:red"">"

        txtLabel=txtlabel+txtToAdd

        txtLabel=txtLabel+"</span><br/><br/>"

   oTable.Annotations[0].specification=txtLabel

end sub

sub ExposeCells(oTable)
        oTable.AddToAnnotation0("Cell Items:<br/>{CellContents}")
end sub

sub ExposeRules(oTable)
        oTable.AddToAnnotation0("Rules:<br/>{Rules}")
end sub


sub sbSplitPopulate(TableDoc,MaxPopTableNumber)
        'Purpose:      Allows you to populate tables in chunks specified by the value input for MaxPopTableNumber parameter
        'Parameters:   TableDoc - must pass TableDoc
        '              MaxPopTableNumber - value of the number of tables you wanted populated at a time.

        With TableDoc
        If MaxPopTableNumber = 0 Then
             .Populate()
        Else
            Dim oPopTable,iPopTableNum,strPopTableNames
            iPopTableNum = 0
            strPopTableNames = ""
            For Each oPopTable in TableDoc.Tables
                iPopTableNum = iPopTableNum + 1
                If iPopTableNum = 1 Then
                    strPopTableNames = oPopTable.Name
                Else
                    strPopTableNames = strPopTableNames + "," + oPopTable.Name
                End If

                If iPopTableNum >= MaxPopTableNumber Then
                    .Populate(strPopTableNames)
                    iPopTableNum = 0
                    strPopTableNames = ""
                End If
            Next

            If iPopTableNum > 0 Then
                .Populate(strPopTableNames)
                iPopTableNum = 0
                strPopTableNames = ""
            End If
        End IF
        End With 'TableDoc
end sub

sub sbAddVisualRfS(TableDoc)
        Dim curTable

        with TableDoc

                'Add it to all the existing tables
                for each curTable in .Tables
                        sbAddDataVisualisation(curTable)
                next

                'Add it the defaults so it is there for any further tables created within reporter
                sbAddDataVisualisation(.Default)

                sbAddDataVisualisation(.ProfileDefault)

        end with
end sub

sub sbAddDataVisualisation(parentObj)
        'parentObj is either of type iTable or iTableDefaults i.e. something with an annotations property.

        with parentObj
                with .annotations[2]
                        .specification=.specification+"<script type='text/javascript'>var strURL='http://dtrjs.grpitsrv.com';</script><script type='text/javascript' src='http://dtrjs.grpitsrv.com/DVMRHead.js'></script>"
                        'Add the MetadataLocation annotation macro
                        .specification=.specification+"<span id='MetaDataLocation' style='visibility:hidden;'>{MetaDataLocation}</span>"
                        'Create the div we will be putting our chart into
                        .specification=.specification+"<div id='vizContainer' style='visibility:hidden;'><div id='vizChart'></div><span id='vizInstructions' style='font-weight:bold;'></span></div>"
                end with
                with .annotations[7]
                        'Add the link to our javascript
                        .specification=.specification+"<script type='text/javascript' src='http://dtrjs.grpitsrv.com/DVMRFoot.js'></script>"
                end with
        end with
end sub

function fnAddGridSliceTablesHD(TableDoc,strFieldName,strTopSpec,strTitleText, strBaseText, strShow,strDriver)
    'this function creates individual tables for each iteration of a selected grid/field combination

    'TableDoc           TOM Document object
    'strFieldName       field name (such as "q2[..].slice")
    'strTopSpec         banner/top breaks spec
    'strTitleText       table title - will be set into table description field
    'strBaseText        base title - only needed if base differs from default
    'strShow            string of categories that control which iterations of grid will be included in summary - set to null if all columns wanted
    'strDriver                  <Variable> Variable to use as iterator for slices, or
    '                                   "" - uses levelid, or
    '                                   ALL - gives slices by all iterations of all Loops at all levels (may generate many tables)
    'Return                     returns an array of table objects

    dim arrList
    dim i
    dim arrBreaks
    dim j
    dim k
    dim arrTables[]
    dim objTab
    dim objField
    dim objParent
    dim arrBuild
    dim arrVars
    dim strIterations
    dim strIterationLabels
    dim lngLevels
    Dim loopIt, itext, itType, strLab
    Dim MDM, strTemp, objElm, strfiltlevel, arrtemp,lngelmshow

' Validity checks
        if find(strFieldname,"+") > -1 then
                Debug.Log("ERROR: Specification " + strfieldname + " is not suitable for fnAddGridSliceTables - only one variable should be specified")
                exit function
        end if
        lngLevels=Tabledoc.dataset.MDMDocument.fields[strFieldName].leveldepth
        if lngLevels < 2 then 'it's not a variable from a grid or loop
                Debug.Log("ERROR: Variable " + strfieldname + " is not suitable for fnAddGridSliceTables due to not having enough level depth")
                exit function
        end if
        set arrbuild=Split(strFieldname,"]")
        if right(arrbuild[ubound(arrbuild)-1],2) <> ".." then 'should be .. at lowest level
                Debug.Log("ERROR: Variable " + strfieldname + " is not suitable for fnAddGridSliceTables as last part of variable should be [..] level")
                exit function
        end if
    if ucase(strDriver)="ALL" then
            set objField = Tabledoc.dataset.MDMDocument.fields[strFieldName]
            set objParent = objField.parent.parent

            set arrBuild = fnGetLevels(objField,strFieldName) 'full string of fields and responses
            set arrVars = split(fnExpandArray("",arrBuild),",")


                if strTopSpec <> "" then
                        arrBreaks = split(strTopSpec,";")
                else
                        arrBreaks = split(" ",";")
                end if
                if strShow <> Null then

                        'remove the grid name and {} from strShow
                                if find(strShow,"{")>-1 then
                                        strShow = mid(strShow,find(strShow,"{") + 1)
                                end if
                                if find(strShow,"}")>-1 then
                                        strShow = left(strShow,find(strShow,"}"))
                                end if

                                arrList = split(strShow,",")

                                for k = 0 to ubound(arrList)
                                        for i = 0 to ubound(arrVars)
                                                if arrVars[i]="" then exit for
                                                strIterations = fnGetIterations(arrVars[i])
                                                if ucase(arrList[k]) = ucase(strIterations[ubound(strIterations)]) then
                                                        strIterationLabels = fnGetIterationLabels(Tabledoc.dataset.MDMdocument,fnGetFieldandIterations(arrVars[i]))
                                                        with TableDoc.Tables
                                                                for j = 0 to ubound(arrBreaks)
                                                                        for each objTab in fnAddTable(TableDoc,arrVars[i],arrBreaks[j],iif(strTitleText<>"",strTitleText,objField.label) + " - " + strIterationLabels,strBaseText)
                                                                                objTab.filters.addnew("Iteration_Filter","True",iif(len(Ctext(strIterationLabels))>0,Ctext(strIterationLabels),"Iteration " + ctext(i)))
                                                                                set arrTables[arrTables.UBound()+1] = objTab
                                                                        next ' objtab
                                                                next 'j
                                                        end with 'TableDoc.Tables
                             end if
                        next 'i
                                next 'k

                else

                        for i = 0 to ubound(arrVars)
                                for j = 0 to ubound(arrBreaks)
                                                        if arrVars[i]="" then exit for
                                                        with TableDoc.Tables
                                                                strIterationLabels = fnGetIterationLabels(Tabledoc.dataset.MDMdocument,fnGetFieldandIterations(arrVars[i]))
                                                                for each objTab in fnAddTable(TableDoc,arrVars[i],arrBreaks[j],iif(strTitleText<>"",strTitleText,objField.label) + " - " + strIterationLabels,strBaseText)
                                                                        objTab.filters.addnew("Iteration_Filter","True",iif(len(Ctext(strIterationLabels))>0,Ctext(strIterationLabels),"Iteration " + ctext(i)))
                                                                        set arrTables[arrTables.UBound()+1] = objTab
                                                                next 'objtab
                                                        end with 'TableDoc.Tables
                                                next 'j
                                        next 'i

                        end if
        else ' Summarised version
                Dim strFldLab
                set MDM = tabledoc.dataset.mdmdocument

                set objField = MDM.fields[strFieldName]
                strFldLab=objField.label
                Select Case lngLevels
                        Case 2
                                if len(strDriver) <= 0 or lcase(strDriver)="levelid" then
                                        strDriver="levelid"
                                        if finditem(MDM.fields[strfieldname].parent.parent.fields,"levelid") is not null then
                                                set objField = MDM.fields[objField.parent.parent.name+"[..]."+strdriver]
                                                strfiltlevel=MDM.fields[strfieldname].parent.parent.name
                                        else
                                                set objField = MDM.fields[strfieldname].parent.parent
                                                strfiltlevel=objfield.name
                                        end if
                                        if objfield.leveldepth=1 then
                                                itType=objfield.iteratortype
                                        else
                                                itType=objfield.parent.parent.iteratortype
                                        end if
                                else
                                        ' Check if supplied driver variable exists at same level as original field
                                        ' some loops will have levelid but it isn't detected by finditem or MDM Explorer, but it can still be used
                                        if finditem(objfield.parent.parent.fields,strDriver) is not null then
                                                set objField = MDM.fields[objField.parent.parent.name+"[..]."+strdriver]
                                                strfiltlevel=objfield.parent.parent.name
                                        else
                                                Debug.Log("ERROR: Variable " + strDriver + " is not suitable for fnAddGridSliceTables as it does not exist at the same level as " + strfieldname)
                                        end if
                                        itType=2
                                end if

                        Case Else

                                set arrbuild=split(strFieldName,"].")
                                arrTemp=split(arrbuild[0],"[")
                                strTemp=arrTemp[0]
                                For i=1 to ubound(arrbuild)-2
                                        arrTemp=split(arrbuild[i],"[")
                                        strTemp=strTemp + "[..]." +arrbuild[i]
                                Next 'i
                                strfiltlevel=strTemp
                                if len(strDriver) <= 0 or lcase(strDriver)="levelid" then
                                        strDriver="levelid"
                                        With MDM
                                                if finditem(.fields[strfieldname].parent.parent.fields,"levelid") is not null then
                                                        set objField = .fields[.fields[strfieldname].parent.parent.fullname+"[..]."+strdriver]
                                                        strfiltlevel=MDM.fields[strfieldname].parent.parent.fullname
                                                else
                                                        set objField = .fields[strfieldname].parent.parent
                                                        strfiltlevel=objfield.fullname
                                                end if
                                        End With 'MDM
                                        if objfield.leveldepth=1 then
                                                itType=objfield.iteratortype
                                        else
                                                itType=objfield.parent.parent.iteratortype
                                        end if
                                else
                                        if finditem(objfield.parent.parent.fields,strDriver) is not null then
                                                set objField = MDM.fields[objField.parent.parent.fullname+"[..]."+strdriver]
                                                strfiltlevel=objfield.parent.parent.fullname
                                        else
                                                Debug.Log("ERROR: Variable " + strDriver + " is not suitable for fnAddGridSliceTables as it does not exist at the same level as " + strfieldname)
                                                EXIT FUNCTION
                                        end if
                                        itType=2
                                end if

                End Select

                if strTopSpec <> "" then
                arrBreaks = split(strTopSpec,";")
            else
                arrBreaks = split(" ",";")
            end if

            ' Limit iterations
                if strShow <> Null then

                        'remove the grid name and {} from strShow
                        if find(strShow,"{")>-1 then strShow = mid(strShow,find(strShow,"{") + 1)
                        if find(strShow,"}")>-1 then strShow = left(strShow,find(strShow,"}"))
                else
                For each objElm in objfield.elements.elements
                        if len(strShow)>0 then strShow=strShow + ","
                        strShow=strShow+objelm.name
                        Next 'objelm
                end if

                arrList = split(strShow,",")

            for j = 0 to ubound(arrBreaks)
                i=0
                ' Numeric loop has no categories but does have elements

                        for lngelmshow = 0 to ubound(arrList) ' as defined in Strshow

                                i=i+1
                        'If this errors then the element name specified in StrShow doesn't exist in this field
                                set objElm=objfield.elements.elements[arrlist[lngelmshow]]
                                strIterationLabels = fnGetIterationLabels(Tabledoc.dataset.MDMdocument,fnGetFieldandIterations(strfieldname))
                                'strLab=iif(strTitleText<>"",strTitleText,objField.label) + " - " +Ctext(objelm.label)
                                'strLab=iif(strTitleText<>"",strTitleText,objField.label) + " - " +Ctext(objelm.label)
                                strLab=iif(strTitleText<>"",strTitleText,strFldLab) + " - " +Ctext(objelm.label)
                                if itType <> 2 then
                                        strLab=iif(strTitleText<>"",strTitleText,strFldLab) + iif(len(strIterationLabels) > 0, " - " + strIterationLabels,"") + " - " + "Iteration - " + strLab
                                else
                                        strLab=iif(strTitleText<>"",strTitleText,strFldLab) + iif(len(strIterationLabels) > 0, " - " + strIterationLabels,"") + " - " +Ctext(objelm.label)
                                end if

                                for each objTab in fnAddTable(TableDoc,strFieldName,arrBreaks[j],StrLab,strBaseText)
                                        if itType=2 then ' categoric

                                                objTab.filters.addnew("Iteration_Filter",strDriver+".containsany({" + objelm.name+"})",iif(len(strIterationLabels) > 0 and len(Ctext(objelm.label))>0,strIterationLabels + " - " + objelm.label, iif(len(strIterationLabels) > 0, strIterationLabels,iif(len(Ctext(objelm.label))>0,Ctext(objelm.label),"Iteration " + ctext(i)))),strfiltlevel)

                                        else 'numeric
                                                objTab.filters.addnew("Iteration_Filter",strDriver+"=" + ctext(objelm.name),iif(len(strIterationLabels) > 0 and len(Ctext(objelm.label))>0,strIterationLabels + " - " + objelm.label,iif(len(strIterationLabels) > 0, strIterationLabels,iif(len(Ctext(objelm.label))>0,Ctext(objelm.label),"Iteration " + ctext(i)))),strfiltlevel)
                                        end if
                                        objtab.Level="HDATA" 'new setup defaults to lowest level
                                        set arrTables[arrTables.UBound()+1] = objTab
                                next ' objtab
                                nextelm:
                        Next ' lngelmshow
                next 'j (breaks)
        end if
        fnAddGridSliceTablesHD = arrTables
End function

Function fnAddGridSliceResponseSummaryHD(TableDoc,strFieldName,strResponse, strTopSpec,strTitleText,strBaseText,strNoneOfAbove,strAddlAEItems,strShow,blnTotal,blnBaseHide,strDriver)
    'this function builds one table that is a summary of response(s) chosen across all selected iterations of a grid/field combination

        'TableDoc           TOM Document object
        'strFieldName
'       'strResponse        response to be summarized - can be single ("statement1"), or multiple ("statement1,statement3") to produce a net of responses given
'       'strTopSpec         banner/top breaks spec
'       'strTitle           table title - will be set into table description field
'       'strBaseText        base title - only needed if base differs from default
'       'strNoneOfAbove     label for none of the above category - set to Null if should not be included
'       'strAddlAEItems     items to append to the end of axis expression this function builds (typically sigma/mean/etc.)
'       'strShow            string of categories that control which iterations of lowest level of grid will be included in summary - set to null if all columns wanted
'       'blnTotal           set to True if table should be based to total instead of those asked each iteration
'       'blnBaseHide        True/False - to hide or not hide sub-bases within the table (ishidden=?)
'       'strDriver          Variable to use as iterator for slices
'
'       'Return                         returns an array of table objects

    dim i, j, k
    dim strAE
    dim strNone
    dim strBase
    dim strBalance
    dim strName
    dim strStubBase
    dim strFields
    dim blnNumeric
    dim arrBreaks
    dim objVar
    dim MDM
    dim strFieldLabels
    dim strIterationLabels
    dim strIterations
    dim objTab
    dim arrTables[]
    dim objField
    dim arrBuild
    dim arrVars
    dim blnInclude
    dim lngLevels
    dim objElm
    dim strI
    Dim strShow2
    dim strTemp,strCloseBrackets
    Dim strLevPref, strLevs, arrLevs, strAddlev

        set MDM = tabledoc.dataset.mdmdocument

        set objField = MDM.fields[strFieldName]

        ' Checks for validity

        lngLevels=objfield.leveldepth
        if lngLevels < 2 then 'it's not a variable from a grid or loop
                Debug.Log("ERROR: Variable " + strfieldname + " is not suitable for fnAddGridSliceResponseSummary due to not having enough level depth")
                exit function
        end if

        if strNoneOfAbove <> "" and ucase(blntotal)="FALSE" then 'questionable combination
                        Debug.Log("WARNING: Variable " + strfieldname + " has included None of the Above but is not rebased to Total in fnAddGridSliceResponseSummary")
        end if

        if ucase(blnBaseHide)="FALSE" and ucase(blntotal)="TRUE" then 'Base to Total takes preference
                        Debug.Log("WARNING: Variable " + strfieldname + " is rebased to Total, but requests individual bases to be shown. Only the Total will be shown (fnAddGridSliceResponseSummary)")
        end if

        strFieldlabels=iif(len(objfield.label) > 0, objfield.label, iif(len(objfield.parent.parent.label) > 0, objfield.parent.parent.label, objfield.name))
' Build table statement
        strTemp=""
        strStubBase="sum"
        strCloseBrackets=""
        set arrbuild=split(strFieldName,"[")
        ' Lowest level must be [..]
        if left(arrbuild[ubound(arrbuild)],2) <> ".." then
                Debug.Log("ERROR: Variable " + strfieldname + " is not suitable for fnAddGridSliceResponseSummary - lowest level of spec must be [..]")
                exit function
        end if

        strlevPref=""' should end up at the lowest level
        For i=0 to ubound(arrbuild)-1

                strTemp=strTemp+arrbuild[i] + "["
                if i>0 then
                        strStubBase=strStubBase+"(SUM("+mid(arrbuild[i],find(arrbuild[i],"]")+2) + "."
                        strCloseBrackets=strCloseBrackets+"))"
                        strLevPref=strLevPref+"^."
                        if left(arrbuild[i],2) <> ".." then
                                if len(strLevs)> 0 then strLevs=strLevs+";"
                                strLevs=strLevs + left(arrbuild[i],find(arrbuild[i],"]"))
                        end if
                else
                        strStubBase=strStubBase+"("+arrbuild[i]+"."
                        strCloseBrackets=strCloseBrackets+")"
                end if

        Next 'i

        arrLevs=split(strLevs,";")
        strAddLev=""
        if len(arrLevs) > 0 then
                For i=0 to ubound(arrLevs)
                        strAddlev=strAddlev + " and " + strLevPref + "levelid=" + arrLevs[i]
                        strLevPref=mid(strLevPref,2)
                Next 'i
        end if


        ' Select variable over which responses will be summarised
        if len(strDriver) <= 0 then
                strDriver="levelid"
        else
                strTemp=strTemp+"..]."+ strDriver
        end if

        set objField = MDM.fields[strTemp]
        if strShow <> Null then
                'remove the {} from strShow
                strShow = replace(strShow,"{","")
                strShow = replace(strShow,"}","")
        end if

    if strTopSpec <> "" then
        arrBreaks = split(strTopSpec,";")
    else
        arrBreaks = split(" ",";")
    end if

    ' Make each element #element# so don't mistake eg _1 for _11

        strShow2="#" + replace(strshow,",","#")+"#"

    for j = 0 to ubound(arrBreaks)

        strAE = ""
        strNone = ""
        strBalance = ""
        strBase = "TotalBase '" + replace(BASETITLE,": ","") + "' base()"
        strTemp="axis({"
        if UCASE(blnTotal)="TRUE" then
                strTemp=strTemp + "base() [Ishidden=True], " + strBase
        end if
        i=0

                For each objElm in objfield.elements.elements
                ' Include element if including all, or element is in list of those to include
                        if strShow = "" or find(strShow2,"#" + objElm.name+"#") >-1 then
                                i=i+1
                                strI=ctext(i)

                                if UCASE(blnTotal)="FALSE" then ' include individual bases
                                        if i >1 then strtemp=strtemp + ","
                                        strTemp=strTemp + "base_" + strI + " base('" + strStubBase + "(" + strDriver+".ContainsAny({"+objElm.name+"})" + strAddlev + strcloseBrackets+")')"
                                        if blnBaseHide and i>1 then
                                                strTemp=strTemp + " [ishidden=True]"
                                        end if
                                end if
                                strTemp=strTemp + ", _" + strI + " '" + objElm.label+ "' expression('" + strStubBase + "(" + strdriver + ".ContainsAny({" + objElm.name+"}) And " + mid(arrbuild[ubound(arrbuild)],find(arrbuild[ubound(arrbuild)],"]") + 2) +".ContainsAny({"+strresponse+"})" + strAddlev + strCloseBrackets + ")')"
                                if i >1 then strNone=strNone + ","
                                strNone=strNone + objelm.name
                        end if
                Next 'objElm

                ' Extra bits

                if strNoneOfAbove <> "" then
                strTemp=strTemp + ",_NoneOfTheAbove '" + strNoneOfAbove + "' expression('"
                if ucase(blnTotal)="FALSE" then
                        strTemp=strTemp + strStubBase + "(" + strDriver + " is not null) "+ strclosebrackets + " and "
                end if
                strTemp=strTemp + "not(" + strStubBase + "(" + strDriver + ".containsany({" + strNone + "}) and " + mid(arrbuild[ubound(arrbuild)],find(arrbuild[ubound(arrbuild)],"]") + 2) + ".containsany({" + strResponse + "}) " + strclosebrackets + "))')"
                end if
                strtemp=strtemp + iif(strAddlAEItems<>"","," + strAddlAEItems,"")
                strtemp=strtemp + "})"


        'Uncomment in order to see the code created in the log file
        'debug.Log("Result from fnAddGridSliceResponseSummary: " + strTemp)

''''                for each objTab in fnAddTable(TableDoc,strTemp,arrBreaks[j],iif(strTitleText<>"",strTitleText,strFieldLabels),strBaseText)
''''                        set arrTables[arrTables.UBound()+1] = objTab
''''                next
            if (UCASE(blnTotal) = "FALSE") then
                for each objTab in fnAddTable(TableDoc,strTemp,arrBreaks[j],iif(strTitleText<>"",strTitleText,strFieldLabels),NULL)
                        set arrTables[arrTables.UBound()+1] = objTab
                next
            end if

            if (UCASE(blnTotal) = "TRUE") then
                for each objTab in fnAddTable(TableDoc,strTemp,arrBreaks[j],iif(strTitleText<>"",strTitleText,strFieldLabels),strBaseText)
                        set arrTables[arrTables.UBound()+1] = objTab
                next
            end if

        next 'j (breaks)

    fnAddGridSliceResponseSummaryHD = arrTables
End Function

Function fnGetLevels(objField, strFieldName)
        'returns an array of all the components of each level of strFieldName
        '"q10[..].brand[..].slice" returns as
        '{q10;[{JohnsonJohnson}];[{Merck}];[{Pfizer}],brand;[{drug}];[{grocery}];[{Convenience}],slice;[{VeryLikely}];[{SomewhatLikely}];[{NeitherLikelynorUnlikely}];[{SomewhatUnlikely}];[{VeryUnlikely}];[{DK}]}

        'the output of this function can be used by other functions to build summary tables or axis expressions that include every iteration of a grid


        dim arrHelp, arrHelp2
        dim j, k
        dim strTemp
        dim oDictFilters
        dim i
        dim cat
        dim ele
        dim arrTest[]

        set oDictFilters = createobject("scripting.dictionary")

        arrHelp = split(strfieldname,"].")
        strTemp = ""
        for j = 0 to ubound(arrHelp)
                arrHelp2 = split(arrhelp[j],"[")
                for k = 0 to ubound(arrHelp2)
                        if k = 0 then
                                'first position just holds field name
                        else
                                if arrhelp2[k] <> ".." then
                                        if find(arrHelp2[0],".")>-1 then
                                                odictfilters.Add(mid(ucase(arrHelp2[0]),find(arrHelp2[0],".")+1),arrHelp2[k])
                                        else
                                                odictfilters.Add(ucase(arrHelp2[0]),arrHelp2[k])
                                        end if
                                end if
                        end if
                next
        next


        '*************************************
        i = 0

        do while objField.objecttypevalue <> 27 'document level
                        if objField.name <> "@class" and objField.objecttypevalue = 3 then
                                'a block
                                arrTest[objField.LevelDepth - 1] = objField.name + "." + arrTest[objField.LevelDepth - 1]
                        elseif objField.name = "@class" and objField.objecttypevalue = 3 then
                                'ignore
                                'debug.Log("Ignored:  " + objField.fullname)
                        elseif objfield.objecttypevalue = 1 or objfield.objecttypevalue = 0 then
                                'arrays and variables
                                strTemp = ""

                                if oDictFilters.Exists(ucase(objField.name)) then
                                        strTemp = strTemp + "[" + oDictFilters[ucase(objField.name)] + "];"

                                else
                                        if objfield.categories.count > 0 then
                                                'categorical
                                                for each cat in objField.categories
                                                        strTemp = strTemp + "[{" + cat.name + "}];"
                                                next
                                        else

                                                'numeric iterators
                                                for each ele in objField.elements
                                                    strTemp = strTemp + "[" + ele.name + "];"
                                                next

                                        end if
                                end if
                                strTemp = left(strTemp,len(strTemp)-1)
                                arrTest[objField.LevelDepth - 1] = objField.name + ";" + strTemp
                        else
                                debug.Log("Skipped:  " + objField.fullname)
                        end if
                set objField = objField.parent
        loop


        fnGetLevels = arrTest

End Function


function fnExpandArray(qbase,arr)
        dim arrBase,newBase,thisBase,item
        dim outputdelim
        outputdelim = ","
        arrBase = arr[0].Split(";")
        newBase = qbase + arrBase[0]
        if arr.Len()=1 then
                fnExpandArray=newBase + outputdelim
                exit function
        end if
        for item=1 to (arrBase.Len()-1)
                thisBase = newBase + arrBase[item]
                if arr.Len() > 1 then fnExpandArray = fnExpandArray + fnExpandArray(thisBase + ".",arr.Right(arr.Len()-1))
        next
end function


function fnGetIterationLabels(MDM,strFieldIter)
        dim arrFields
        dim objField
        dim i
        dim strLabel
        dim strField
        dim strElement

        strFieldIter = replace(ctext(strFieldIter),"{","")
        strFieldIter = replace(ctext(strFieldIter),"}","")

        set arrFields = split(strFieldIter,",")
        set objField = MDM

        for i = 0 to (ubound(arrFields) - 1)
                strField = left(arrFields[i],find(arrFields[i],";"))
                strElement = mid(arrFields[i],find(arrFields[i],";")+ 1 )
                if strelement=".." then goto allsel
                set objField = objField.fields[strField]

                strLabel = strLabel + iif(strLabel <>"" and objField.elements[strElement].label <> ""," - ","") + objField.elements[strElement].Label
                        allsel:
        next

        fnGetIterationLabels = strLabel

end function


function fnGetFieldandIterations(VarName)
'this function returns the iteration information from the original string

'VarName        text string that will be parsed

        'q1[{pepsi}].imagery[{tastesgreat}].slice returns
                'arrTemp[0] = "q1;pepsi"
                'arrTemp[1] = "imagery;tastesgreat"

        dim arrTemp
        dim arrTemp2[]

        dim i
        arrTemp = split(VarName,"].")

        for i =0 to ubound(arrTemp)
                arrTemp2[i] = arrTemp[i]
                arrTemp2[i] = replace(arrTemp2[i],"[",";")
                'arrTemp2[i] = replace(arrTemp[i],"]","") 'shouldn't be needed
                arrTemp2[i] = replace(arrTemp2[i],"{","")
                arrTemp2[i] = replace(arrTemp2[i],"}","")
        next
        fnGetFieldAndIterations = arrTemp2
end function


function fnGetIterations(VarName)
'this function returns the iteration information from the original string

'VarName        text string that will be parsed

        'q1[{pepsi}].imagery[{tastesgreat}].slice returns
                'arrClean[0] = "pepsi"
                'arrClean[1] = "tastesgreat"

    Dim objRegExp       ' Regular Expression Object
        Dim colMatches, objMatch, arrClean[]
        dim i

    set objRegExp = CreateObject("VBScript.RegExp")
    objRegExp.Global = True
    ' Set the pattern To look For  tags
        objRegExp.Pattern = "\[[^\]]*\]"

        Set colMatches = objRegExp.Execute(varname)

        i = 0

        For Each objMatch in colMatches
                'debug.Log(objMatch.Value)
                arrClean[i] = replace(objMatch.value,"[","")
                arrClean[i] = replace(arrClean[i],"]","")
                arrClean[i] = replace(arrClean[i],"{","")
                arrClean[i] = replace(arrClean[i],"}","")
                i = i + 1
        Next

        ' Return only the iteration information from the original string
        fnGetIterations = arrClean

        Set objRegExp = null

End function

sub sbSplitPopulateAccelerated(TableDoc,iTablesPerThread,strjob_root,strOutputFolder,strOutputName,booRemoveBlanks)

	'Objects
	Dim ofso, oWShell, oFile, oFolder, batFile, batFile1
	'Strings
	dim strSession, strWorkingFolder, strMergedMtdFileName
	'Integers
	dim  iLog, iThread, iNumberOfThreads, iThreadsRunning, i, iCores
	'Arrays
	dim arrThreadInfo[3][], arrThreadTables[2][], arrThreadStatus [2][]
	'Boolean
	dim booDonePopulating
	'XML Objects
	Dim xmlMergedMtd, xmlThreadMtd, xmlTables, xmlTable

	'arrThreadInfo Structure (string)
	'[0] = MTD File Name
	'[1] = Log File Name
	'[2] = command line string for debugging

	'arrThreadTables structure (numeric)
	'[0] = Start Table Number
	'[1] = End Table Number

	'arrThreadStatus (boolean)
	'[0] = Thread Running
	'[1] = Thread Done

	Set ofso = CreateObject("Scripting.FileSystemObject")
	Set oWShell = CreateObject("WScript.Shell")
	Set xmlMergedMtd = CreateObject("Microsoft.XMLDOM")
	Set xmlThreadMtd = CreateObject("Microsoft.XMLDOM")

	'Determine number of cores based on environment variables
	strSession = oWshell.ExpandEnvironmentStrings("%SESSIONNAME%")
	Select case Left(strSession,3)
		case "Ses" 'Local Desktop
			iCores = CLong(oWshell.ExpandEnvironmentStrings("%NUMBER_OF_PROCESSORS%")) - 1
		case "Con" 'Local Desktop
			iCores = CLong(oWshell.ExpandEnvironmentStrings("%NUMBER_OF_PROCESSORS%")) - 1 '+8
		case "RDP" 'Remote Desktop
			iCores = CLong(oWshell.ExpandEnvironmentStrings("%NUMBER_OF_PROCESSORS%"))
		case else 'Citrix or unknown
			iCores = 1
	End Select

	'Create time based working/output folder
	'Format is Date_Time_OutputName
	strWorkingFolder = strOutputFolder + fnCreateFormattedTimeNow() + "_" + strOutputName
	ofso.CreateFolder(strWorkingFolder)

	'Create a unique name for the merged output file
	'so that previous versions will not be overwritten
	strMergedMtdFileName = strOutputFolder + "\" + strOutputName + ".mtd"

  ''''
  Dim run_times
  run_times = int(TableDoc.Tables.Count / 500) + 1

	''''Calculate iTablesPerThread
	if TableDoc.Tables.Count/run_times mod iCores <> 0 then
		iTablesPerThread = (TableDoc.Tables.Count/run_times / iCores) + 1
	else
		iTablesPerThread = (TableDoc.Tables.Count/run_times / iCores)
	end if

	'Calculate the tables per thread
	if TableDoc.Tables.Count mod iTablesPerThread <> 0 then
		iNumberOfThreads = (TableDoc.Tables.Count / iTablesPerThread) + 1
	else
		iNumberOfThreads = (TableDoc.Tables.Count / iTablesPerThread)
	end if

	Debug.log("Running " + ctext(iNumberOfThreads) + " thread" + iif(iNumberOfThreads>1,"s","")  + " with " + ctext(iTablesPerThread) + " tables per thread. Max Cores used is " + ctext(iCores))

	'set up threads to execute
	For iThread = 1 To iNumberOfThreads
		'Get The number of tables stored
		arrThreadTables[0][iThread-1] = (iThread-1) * iTablesPerThread
		If (iThread = iNumberOfThreads) Then
			arrThreadTables[1][iThread-1] = TableDoc.Tables.Count - 1
		Else
			arrThreadTables[1][iThread-1] = arrThreadTables[0][iThread-1] + iTablesPerThread - 1
		End If

		'Set MTD File
		arrThreadInfo[0][iThread - 1] = strWorkingFolder + "\" + strOutputName + "_Tables" + ctext(arrThreadTables[0][iThread-1]) + "To" + ctext(arrThreadTables[1][iThread-1]) + ".mtd"
		'Set Log file
		arrThreadInfo[1][iThread - 1] = strWorkingFolder + "\Log_" + ctext(arrThreadTables[0][iThread-1]) + "To" + ctext(arrThreadTables[1][iThread-1]) + ".txt"
		'Set initial Run status
		arrThreadStatus[0][iThread-1] = False
		arrThreadStatus[1][iThread-1] = False
	Next

	iThread = 0
	iThreadsRunning = 0
	booDonePopulating = False
	do until booDonePopulating =  True
		if iThreadsRunning < iCores and iThread < iNumberOfThreads then
			iThreadsRunning = iThreadsRunning + 1
			iThread = iThread + 1
			'Create the command line
			arrThreadInfo[2][iThread-1] = "mrScriptCl """ + strjob_root + "Library\SingleThreadPopulate.mrs""" + _
				 " /a:MTD_FILE_PA=""" + strjob_root + strOutputFolder + strOutputName + "_UnPopulated.mtd""" + _
				 " /a:THREAD_MTD_FILE_PA=""" + strjob_root + arrThreadInfo[0][iThread - 1] + """" + _
				 " /a:LOG_FILE_PA=""" + strjob_root + arrThreadInfo[1][iThread - 1] + """" + _
				 " /d:START_TABLE_PA=""" + ctext(arrThreadTables[0][iThread - 1]) + """" + _
				 " /d:END_TABLE_PA=""" + ctext(arrThreadTables[1][iThread - 1]) + """" + _
				 " /d:REMOVEBLANKTABLES_PA=""" + ctext(booRemoveBlanks) + """"

      set batFile1=ofso.createtextfile(strjob_root + arrThreadInfo[0][iThread - 1] + ".bat",true,false)
      batFile1.WriteLine(arrThreadInfo[2][iThread-1])
      batFile1.Close()

			'Run the command, but don't wait for it
			''''oWShell.Run(arrThreadInfo[2][iThread-1], 0, False)
			oWShell.Run(strjob_root + arrThreadInfo[0][iThread - 1] + ".bat", 0, False)
			'Set the thread as running
			arrThreadStatus[0][iThread-1] = True
		else
			'need to wait until a thread finishes
			Sleep(100)
			for i = 0 to uBound(arrThreadStatus,2)
				'if arrThreadStatus[0][i] = True and not(oFso.FileExists(arrThreadInfo[1][i])) then
				'	Debug.log(arrThreadInfo[2][i])
				'	err.Raise(0,"Tables.mrs",arrThreadInfo[1][i] + ": Something went wrong with the SingleThreadPopulate Script. Use the above line on a command prompt to see what is wrong")
				'end if
				if oFso.FileExists(arrThreadInfo[1][i]) Then
					if arrThreadStatus[0][i] = True then
						arrThreadStatus[0][i] = False
					arrThreadStatus[1][i] = True
						iThreadsRunning = iThreadsRunning - 1
					end if
				end if
			next
			'Checking for completion
			for i = 0 to uBound(arrThreadStatus,2)
				if arrThreadStatus[1][i] = True then
					booDonePopulating = True
				else
					booDonePopulating = False
					exit For
				end if
			next
		end if
	Loop


	'waiting for files to be unlocked

Sleep:
	for i = 0 to iNumberOfThreads - 1
		if not(oFso.FileExists(arrThreadInfo[0][i])) then
			Sleep(100)
			GOTO Sleep
    end if
	next


	'Checking log files to ensure no population errors
	For iThread = 0 To iNumberOfThreads - 1
		Set oFile = ofso.OpenTextFile(arrThreadInfo[1][iThread])
		If (Find(oFile.ReadAll(), "ERROR") >= 0) Then
			Err.Raise(1, "Tables.mrs", "Error in file " + arrThreadInfo[1][iThread] + ", exiting")
		End If
	Next

	Dim copycsvstring
	'Merge MTD parts
	For iThread = 0 To iNumberOfThreads - 1
		If (iThread = 0) Then
			' First mtd, use this as the basis for the merged mtd
			xmlMergedMtd.Load(arrThreadInfo[0][iThread])
			Set xmlTables = xmlMergedMtd.GetElementsByTagName("Tables")
		Else
			' Load the table XML for this thread
			xmlThreadMtd.Load(arrThreadInfo[0][iThread])
			' Copy tables from the thread XML to the merged XML
			For Each xmlTable In xmlThreadMtd.getElementsByTagName("Table")
				xmlTables[0].AppendChild(xmlTable)
			Next
		End If

    copycsvstring = copycsvstring + strjob_root + arrThreadInfo[0][iThread] + ".csv+^" + mr.newline

	Next

	'Save the merged XML
	xmlMergedMtd.Save(strMergedMtdFileName)
	Set xmlMergedMtd = Null

  ''''Merge csv
  ''''Err.Raise(1, "Tables.mrs", "Copy " + left(copycsvstring,len(copycsvstring)-1) + " " + strjob_root + strOutputFolder + strOutputName + ".csv /y")
  set batFile=ofso.createtextfile(strWorkingFolder + "\mergecsv.bat",true,false)
  batFile.WriteLine("Copy " + left(copycsvstring,len(copycsvstring)-4) + " " + strjob_root + strOutputFolder + strOutputName + ".csv /y")
  batFile.Close()
  oWShell.Run(strWorkingFolder + "\mergecsv.bat", 0, True)

	'Delete unpopulated MTD to prevent unintended usage
	oFso.DeleteFile(strOutputFolder + strOutputName + "_Unpopulated.mtd")

	'Delete intermediate files
	set oFolder = oFso.GetFolder(strWorkingFolder)
	for each ofile in oFolder.Files
		oFile.Delete()
	Next

	'Delete working folder
	oFso.DeleteFolder(strWorkingFolder)

	'Open Saved MTD for export and post population scripts
	TableDoc.Open(strMergedMtdFileName)

end sub

Function fnCreateFormattedTimeNow()
    Dim CurrentTime

    CurrentTime = Now()
    fnCreateFormattedTimeNow = CText(DatePart(CurrentTime, "yyyy")) + "-" + _
	Format(DatePart(CurrentTime, "m"), "d2") + "-" + Format(DatePart(CurrentTime, "d"), "d2") + "_" + _
	Format(DatePart(CurrentTime, "h"), "d2") + Format(DatePart(CurrentTime, "n"), "d2") + _
	Format(DatePart(CurrentTime, "s"), "d2")
End Function
